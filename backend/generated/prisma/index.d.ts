
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Faculty
 * 
 */
export type Faculty = $Result.DefaultSelection<Prisma.$FacultyPayload>
/**
 * Model SubjectTaught
 * 
 */
export type SubjectTaught = $Result.DefaultSelection<Prisma.$SubjectTaughtPayload>
/**
 * Model FacultyQualification
 * 
 */
export type FacultyQualification = $Result.DefaultSelection<Prisma.$FacultyQualificationPayload>
/**
 * Model OutReachActivities
 * 
 */
export type OutReachActivities = $Result.DefaultSelection<Prisma.$OutReachActivitiesPayload>
/**
 * Model EventType
 * 
 */
export type EventType = $Result.DefaultSelection<Prisma.$EventTypePayload>
/**
 * Model EventsOrganised
 * 
 */
export type EventsOrganised = $Result.DefaultSelection<Prisma.$EventsOrganisedPayload>
/**
 * Model Awards
 * 
 */
export type Awards = $Result.DefaultSelection<Prisma.$AwardsPayload>
/**
 * Model TeachingExperience
 * 
 */
export type TeachingExperience = $Result.DefaultSelection<Prisma.$TeachingExperiencePayload>
/**
 * Model CitationMetrics
 * 
 */
export type CitationMetrics = $Result.DefaultSelection<Prisma.$CitationMetricsPayload>
/**
 * Model TYPES
 * 
 */
export type TYPES = $Result.DefaultSelection<Prisma.$TYPESPayload>
/**
 * Model Publications
 * 
 */
export type Publications = $Result.DefaultSelection<Prisma.$PublicationsPayload>
/**
 * Model JournalPublicationDetails
 * 
 */
export type JournalPublicationDetails = $Result.DefaultSelection<Prisma.$JournalPublicationDetailsPayload>
/**
 * Model BookPublicationDetails
 * 
 */
export type BookPublicationDetails = $Result.DefaultSelection<Prisma.$BookPublicationDetailsPayload>
/**
 * Model ConferencePaperDetails
 * 
 */
export type ConferencePaperDetails = $Result.DefaultSelection<Prisma.$ConferencePaperDetailsPayload>
/**
 * Model FacultyPublicationLink
 * 
 */
export type FacultyPublicationLink = $Result.DefaultSelection<Prisma.$FacultyPublicationLinkPayload>
/**
 * Model Patents
 * 
 */
export type Patents = $Result.DefaultSelection<Prisma.$PatentsPayload>
/**
 * Model ResearchProjects
 * 
 */
export type ResearchProjects = $Result.DefaultSelection<Prisma.$ResearchProjectsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const event_type: {
  Workshop: 'Workshop',
  Seminar: 'Seminar',
  Conference: 'Conference',
  Other: 'Other'
};

export type event_type = (typeof event_type)[keyof typeof event_type]


export const role_type: {
  Speaker: 'Speaker',
  Attendee: 'Attendee',
  Organizer: 'Organizer'
};

export type role_type = (typeof role_type)[keyof typeof role_type]


export const publication_type: {
  publication: 'publication',
  patent: 'patent',
  research_project: 'research_project'
};

export type publication_type = (typeof publication_type)[keyof typeof publication_type]

}

export type event_type = $Enums.event_type

export const event_type: typeof $Enums.event_type

export type role_type = $Enums.role_type

export const role_type: typeof $Enums.role_type

export type publication_type = $Enums.publication_type

export const publication_type: typeof $Enums.publication_type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Departments
 * const departments = await prisma.department.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Departments
   * const departments = await prisma.department.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faculty`: Exposes CRUD operations for the **Faculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faculties
    * const faculties = await prisma.faculty.findMany()
    * ```
    */
  get faculty(): Prisma.FacultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subjectTaught`: Exposes CRUD operations for the **SubjectTaught** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubjectTaughts
    * const subjectTaughts = await prisma.subjectTaught.findMany()
    * ```
    */
  get subjectTaught(): Prisma.SubjectTaughtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facultyQualification`: Exposes CRUD operations for the **FacultyQualification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacultyQualifications
    * const facultyQualifications = await prisma.facultyQualification.findMany()
    * ```
    */
  get facultyQualification(): Prisma.FacultyQualificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outReachActivities`: Exposes CRUD operations for the **OutReachActivities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutReachActivities
    * const outReachActivities = await prisma.outReachActivities.findMany()
    * ```
    */
  get outReachActivities(): Prisma.OutReachActivitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventType`: Exposes CRUD operations for the **EventType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventTypes
    * const eventTypes = await prisma.eventType.findMany()
    * ```
    */
  get eventType(): Prisma.EventTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventsOrganised`: Exposes CRUD operations for the **EventsOrganised** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventsOrganiseds
    * const eventsOrganiseds = await prisma.eventsOrganised.findMany()
    * ```
    */
  get eventsOrganised(): Prisma.EventsOrganisedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.awards`: Exposes CRUD operations for the **Awards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Awards
    * const awards = await prisma.awards.findMany()
    * ```
    */
  get awards(): Prisma.AwardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teachingExperience`: Exposes CRUD operations for the **TeachingExperience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeachingExperiences
    * const teachingExperiences = await prisma.teachingExperience.findMany()
    * ```
    */
  get teachingExperience(): Prisma.TeachingExperienceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.citationMetrics`: Exposes CRUD operations for the **CitationMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CitationMetrics
    * const citationMetrics = await prisma.citationMetrics.findMany()
    * ```
    */
  get citationMetrics(): Prisma.CitationMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tYPES`: Exposes CRUD operations for the **TYPES** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TYPES
    * const tYPES = await prisma.tYPES.findMany()
    * ```
    */
  get tYPES(): Prisma.TYPESDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publications`: Exposes CRUD operations for the **Publications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publications
    * const publications = await prisma.publications.findMany()
    * ```
    */
  get publications(): Prisma.PublicationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalPublicationDetails`: Exposes CRUD operations for the **JournalPublicationDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalPublicationDetails
    * const journalPublicationDetails = await prisma.journalPublicationDetails.findMany()
    * ```
    */
  get journalPublicationDetails(): Prisma.JournalPublicationDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookPublicationDetails`: Exposes CRUD operations for the **BookPublicationDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookPublicationDetails
    * const bookPublicationDetails = await prisma.bookPublicationDetails.findMany()
    * ```
    */
  get bookPublicationDetails(): Prisma.BookPublicationDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferencePaperDetails`: Exposes CRUD operations for the **ConferencePaperDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferencePaperDetails
    * const conferencePaperDetails = await prisma.conferencePaperDetails.findMany()
    * ```
    */
  get conferencePaperDetails(): Prisma.ConferencePaperDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facultyPublicationLink`: Exposes CRUD operations for the **FacultyPublicationLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacultyPublicationLinks
    * const facultyPublicationLinks = await prisma.facultyPublicationLink.findMany()
    * ```
    */
  get facultyPublicationLink(): Prisma.FacultyPublicationLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patents`: Exposes CRUD operations for the **Patents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patents
    * const patents = await prisma.patents.findMany()
    * ```
    */
  get patents(): Prisma.PatentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.researchProjects`: Exposes CRUD operations for the **ResearchProjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResearchProjects
    * const researchProjects = await prisma.researchProjects.findMany()
    * ```
    */
  get researchProjects(): Prisma.ResearchProjectsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Department: 'Department',
    Faculty: 'Faculty',
    SubjectTaught: 'SubjectTaught',
    FacultyQualification: 'FacultyQualification',
    OutReachActivities: 'OutReachActivities',
    EventType: 'EventType',
    EventsOrganised: 'EventsOrganised',
    Awards: 'Awards',
    TeachingExperience: 'TeachingExperience',
    CitationMetrics: 'CitationMetrics',
    TYPES: 'TYPES',
    Publications: 'Publications',
    JournalPublicationDetails: 'JournalPublicationDetails',
    BookPublicationDetails: 'BookPublicationDetails',
    ConferencePaperDetails: 'ConferencePaperDetails',
    FacultyPublicationLink: 'FacultyPublicationLink',
    Patents: 'Patents',
    ResearchProjects: 'ResearchProjects'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "department" | "faculty" | "subjectTaught" | "facultyQualification" | "outReachActivities" | "eventType" | "eventsOrganised" | "awards" | "teachingExperience" | "citationMetrics" | "tYPES" | "publications" | "journalPublicationDetails" | "bookPublicationDetails" | "conferencePaperDetails" | "facultyPublicationLink" | "patents" | "researchProjects"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Faculty: {
        payload: Prisma.$FacultyPayload<ExtArgs>
        fields: Prisma.FacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findFirst: {
            args: Prisma.FacultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findMany: {
            args: Prisma.FacultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          create: {
            args: Prisma.FacultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          createMany: {
            args: Prisma.FacultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacultyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          delete: {
            args: Prisma.FacultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          update: {
            args: Prisma.FacultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          deleteMany: {
            args: Prisma.FacultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacultyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          upsert: {
            args: Prisma.FacultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          aggregate: {
            args: Prisma.FacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaculty>
          }
          groupBy: {
            args: Prisma.FacultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultyCountArgs<ExtArgs>
            result: $Utils.Optional<FacultyCountAggregateOutputType> | number
          }
        }
      }
      SubjectTaught: {
        payload: Prisma.$SubjectTaughtPayload<ExtArgs>
        fields: Prisma.SubjectTaughtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectTaughtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectTaughtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload>
          }
          findFirst: {
            args: Prisma.SubjectTaughtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectTaughtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload>
          }
          findMany: {
            args: Prisma.SubjectTaughtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload>[]
          }
          create: {
            args: Prisma.SubjectTaughtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload>
          }
          createMany: {
            args: Prisma.SubjectTaughtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectTaughtCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload>[]
          }
          delete: {
            args: Prisma.SubjectTaughtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload>
          }
          update: {
            args: Prisma.SubjectTaughtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload>
          }
          deleteMany: {
            args: Prisma.SubjectTaughtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectTaughtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectTaughtUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload>[]
          }
          upsert: {
            args: Prisma.SubjectTaughtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTaughtPayload>
          }
          aggregate: {
            args: Prisma.SubjectTaughtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubjectTaught>
          }
          groupBy: {
            args: Prisma.SubjectTaughtGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectTaughtGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectTaughtCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectTaughtCountAggregateOutputType> | number
          }
        }
      }
      FacultyQualification: {
        payload: Prisma.$FacultyQualificationPayload<ExtArgs>
        fields: Prisma.FacultyQualificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultyQualificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultyQualificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload>
          }
          findFirst: {
            args: Prisma.FacultyQualificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultyQualificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload>
          }
          findMany: {
            args: Prisma.FacultyQualificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload>[]
          }
          create: {
            args: Prisma.FacultyQualificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload>
          }
          createMany: {
            args: Prisma.FacultyQualificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacultyQualificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload>[]
          }
          delete: {
            args: Prisma.FacultyQualificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload>
          }
          update: {
            args: Prisma.FacultyQualificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload>
          }
          deleteMany: {
            args: Prisma.FacultyQualificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacultyQualificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacultyQualificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload>[]
          }
          upsert: {
            args: Prisma.FacultyQualificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyQualificationPayload>
          }
          aggregate: {
            args: Prisma.FacultyQualificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacultyQualification>
          }
          groupBy: {
            args: Prisma.FacultyQualificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultyQualificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultyQualificationCountArgs<ExtArgs>
            result: $Utils.Optional<FacultyQualificationCountAggregateOutputType> | number
          }
        }
      }
      OutReachActivities: {
        payload: Prisma.$OutReachActivitiesPayload<ExtArgs>
        fields: Prisma.OutReachActivitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutReachActivitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutReachActivitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload>
          }
          findFirst: {
            args: Prisma.OutReachActivitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutReachActivitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload>
          }
          findMany: {
            args: Prisma.OutReachActivitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload>[]
          }
          create: {
            args: Prisma.OutReachActivitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload>
          }
          createMany: {
            args: Prisma.OutReachActivitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutReachActivitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload>[]
          }
          delete: {
            args: Prisma.OutReachActivitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload>
          }
          update: {
            args: Prisma.OutReachActivitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload>
          }
          deleteMany: {
            args: Prisma.OutReachActivitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutReachActivitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutReachActivitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload>[]
          }
          upsert: {
            args: Prisma.OutReachActivitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutReachActivitiesPayload>
          }
          aggregate: {
            args: Prisma.OutReachActivitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutReachActivities>
          }
          groupBy: {
            args: Prisma.OutReachActivitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutReachActivitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutReachActivitiesCountArgs<ExtArgs>
            result: $Utils.Optional<OutReachActivitiesCountAggregateOutputType> | number
          }
        }
      }
      EventType: {
        payload: Prisma.$EventTypePayload<ExtArgs>
        fields: Prisma.EventTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          findFirst: {
            args: Prisma.EventTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          findMany: {
            args: Prisma.EventTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>[]
          }
          create: {
            args: Prisma.EventTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          createMany: {
            args: Prisma.EventTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>[]
          }
          delete: {
            args: Prisma.EventTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          update: {
            args: Prisma.EventTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          deleteMany: {
            args: Prisma.EventTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>[]
          }
          upsert: {
            args: Prisma.EventTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          aggregate: {
            args: Prisma.EventTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventType>
          }
          groupBy: {
            args: Prisma.EventTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EventTypeCountAggregateOutputType> | number
          }
        }
      }
      EventsOrganised: {
        payload: Prisma.$EventsOrganisedPayload<ExtArgs>
        fields: Prisma.EventsOrganisedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventsOrganisedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventsOrganisedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload>
          }
          findFirst: {
            args: Prisma.EventsOrganisedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventsOrganisedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload>
          }
          findMany: {
            args: Prisma.EventsOrganisedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload>[]
          }
          create: {
            args: Prisma.EventsOrganisedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload>
          }
          createMany: {
            args: Prisma.EventsOrganisedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventsOrganisedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload>[]
          }
          delete: {
            args: Prisma.EventsOrganisedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload>
          }
          update: {
            args: Prisma.EventsOrganisedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload>
          }
          deleteMany: {
            args: Prisma.EventsOrganisedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventsOrganisedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventsOrganisedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload>[]
          }
          upsert: {
            args: Prisma.EventsOrganisedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsOrganisedPayload>
          }
          aggregate: {
            args: Prisma.EventsOrganisedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventsOrganised>
          }
          groupBy: {
            args: Prisma.EventsOrganisedGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventsOrganisedGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventsOrganisedCountArgs<ExtArgs>
            result: $Utils.Optional<EventsOrganisedCountAggregateOutputType> | number
          }
        }
      }
      Awards: {
        payload: Prisma.$AwardsPayload<ExtArgs>
        fields: Prisma.AwardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AwardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AwardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload>
          }
          findFirst: {
            args: Prisma.AwardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AwardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload>
          }
          findMany: {
            args: Prisma.AwardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload>[]
          }
          create: {
            args: Prisma.AwardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload>
          }
          createMany: {
            args: Prisma.AwardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AwardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload>[]
          }
          delete: {
            args: Prisma.AwardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload>
          }
          update: {
            args: Prisma.AwardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload>
          }
          deleteMany: {
            args: Prisma.AwardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AwardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AwardsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload>[]
          }
          upsert: {
            args: Prisma.AwardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardsPayload>
          }
          aggregate: {
            args: Prisma.AwardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAwards>
          }
          groupBy: {
            args: Prisma.AwardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AwardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AwardsCountArgs<ExtArgs>
            result: $Utils.Optional<AwardsCountAggregateOutputType> | number
          }
        }
      }
      TeachingExperience: {
        payload: Prisma.$TeachingExperiencePayload<ExtArgs>
        fields: Prisma.TeachingExperienceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeachingExperienceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeachingExperienceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload>
          }
          findFirst: {
            args: Prisma.TeachingExperienceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeachingExperienceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload>
          }
          findMany: {
            args: Prisma.TeachingExperienceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload>[]
          }
          create: {
            args: Prisma.TeachingExperienceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload>
          }
          createMany: {
            args: Prisma.TeachingExperienceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeachingExperienceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload>[]
          }
          delete: {
            args: Prisma.TeachingExperienceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload>
          }
          update: {
            args: Prisma.TeachingExperienceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload>
          }
          deleteMany: {
            args: Prisma.TeachingExperienceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeachingExperienceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeachingExperienceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload>[]
          }
          upsert: {
            args: Prisma.TeachingExperienceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingExperiencePayload>
          }
          aggregate: {
            args: Prisma.TeachingExperienceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeachingExperience>
          }
          groupBy: {
            args: Prisma.TeachingExperienceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeachingExperienceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeachingExperienceCountArgs<ExtArgs>
            result: $Utils.Optional<TeachingExperienceCountAggregateOutputType> | number
          }
        }
      }
      CitationMetrics: {
        payload: Prisma.$CitationMetricsPayload<ExtArgs>
        fields: Prisma.CitationMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CitationMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CitationMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload>
          }
          findFirst: {
            args: Prisma.CitationMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CitationMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload>
          }
          findMany: {
            args: Prisma.CitationMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload>[]
          }
          create: {
            args: Prisma.CitationMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload>
          }
          createMany: {
            args: Prisma.CitationMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CitationMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload>[]
          }
          delete: {
            args: Prisma.CitationMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload>
          }
          update: {
            args: Prisma.CitationMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload>
          }
          deleteMany: {
            args: Prisma.CitationMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CitationMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CitationMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload>[]
          }
          upsert: {
            args: Prisma.CitationMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationMetricsPayload>
          }
          aggregate: {
            args: Prisma.CitationMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCitationMetrics>
          }
          groupBy: {
            args: Prisma.CitationMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CitationMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CitationMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<CitationMetricsCountAggregateOutputType> | number
          }
        }
      }
      TYPES: {
        payload: Prisma.$TYPESPayload<ExtArgs>
        fields: Prisma.TYPESFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TYPESFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TYPESFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload>
          }
          findFirst: {
            args: Prisma.TYPESFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TYPESFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload>
          }
          findMany: {
            args: Prisma.TYPESFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload>[]
          }
          create: {
            args: Prisma.TYPESCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload>
          }
          createMany: {
            args: Prisma.TYPESCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TYPESCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload>[]
          }
          delete: {
            args: Prisma.TYPESDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload>
          }
          update: {
            args: Prisma.TYPESUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload>
          }
          deleteMany: {
            args: Prisma.TYPESDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TYPESUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TYPESUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload>[]
          }
          upsert: {
            args: Prisma.TYPESUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TYPESPayload>
          }
          aggregate: {
            args: Prisma.TYPESAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTYPES>
          }
          groupBy: {
            args: Prisma.TYPESGroupByArgs<ExtArgs>
            result: $Utils.Optional<TYPESGroupByOutputType>[]
          }
          count: {
            args: Prisma.TYPESCountArgs<ExtArgs>
            result: $Utils.Optional<TYPESCountAggregateOutputType> | number
          }
        }
      }
      Publications: {
        payload: Prisma.$PublicationsPayload<ExtArgs>
        fields: Prisma.PublicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload>
          }
          findFirst: {
            args: Prisma.PublicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload>
          }
          findMany: {
            args: Prisma.PublicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload>[]
          }
          create: {
            args: Prisma.PublicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload>
          }
          createMany: {
            args: Prisma.PublicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublicationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload>[]
          }
          delete: {
            args: Prisma.PublicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload>
          }
          update: {
            args: Prisma.PublicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload>
          }
          deleteMany: {
            args: Prisma.PublicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PublicationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload>[]
          }
          upsert: {
            args: Prisma.PublicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationsPayload>
          }
          aggregate: {
            args: Prisma.PublicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublications>
          }
          groupBy: {
            args: Prisma.PublicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicationsCountArgs<ExtArgs>
            result: $Utils.Optional<PublicationsCountAggregateOutputType> | number
          }
        }
      }
      JournalPublicationDetails: {
        payload: Prisma.$JournalPublicationDetailsPayload<ExtArgs>
        fields: Prisma.JournalPublicationDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalPublicationDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalPublicationDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload>
          }
          findFirst: {
            args: Prisma.JournalPublicationDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalPublicationDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload>
          }
          findMany: {
            args: Prisma.JournalPublicationDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload>[]
          }
          create: {
            args: Prisma.JournalPublicationDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload>
          }
          createMany: {
            args: Prisma.JournalPublicationDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalPublicationDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload>[]
          }
          delete: {
            args: Prisma.JournalPublicationDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload>
          }
          update: {
            args: Prisma.JournalPublicationDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload>
          }
          deleteMany: {
            args: Prisma.JournalPublicationDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalPublicationDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalPublicationDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload>[]
          }
          upsert: {
            args: Prisma.JournalPublicationDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPublicationDetailsPayload>
          }
          aggregate: {
            args: Prisma.JournalPublicationDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalPublicationDetails>
          }
          groupBy: {
            args: Prisma.JournalPublicationDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalPublicationDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalPublicationDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<JournalPublicationDetailsCountAggregateOutputType> | number
          }
        }
      }
      BookPublicationDetails: {
        payload: Prisma.$BookPublicationDetailsPayload<ExtArgs>
        fields: Prisma.BookPublicationDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookPublicationDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookPublicationDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload>
          }
          findFirst: {
            args: Prisma.BookPublicationDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookPublicationDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload>
          }
          findMany: {
            args: Prisma.BookPublicationDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload>[]
          }
          create: {
            args: Prisma.BookPublicationDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload>
          }
          createMany: {
            args: Prisma.BookPublicationDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookPublicationDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload>[]
          }
          delete: {
            args: Prisma.BookPublicationDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload>
          }
          update: {
            args: Prisma.BookPublicationDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload>
          }
          deleteMany: {
            args: Prisma.BookPublicationDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookPublicationDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookPublicationDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload>[]
          }
          upsert: {
            args: Prisma.BookPublicationDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPublicationDetailsPayload>
          }
          aggregate: {
            args: Prisma.BookPublicationDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookPublicationDetails>
          }
          groupBy: {
            args: Prisma.BookPublicationDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookPublicationDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookPublicationDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<BookPublicationDetailsCountAggregateOutputType> | number
          }
        }
      }
      ConferencePaperDetails: {
        payload: Prisma.$ConferencePaperDetailsPayload<ExtArgs>
        fields: Prisma.ConferencePaperDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferencePaperDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferencePaperDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload>
          }
          findFirst: {
            args: Prisma.ConferencePaperDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferencePaperDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload>
          }
          findMany: {
            args: Prisma.ConferencePaperDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload>[]
          }
          create: {
            args: Prisma.ConferencePaperDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload>
          }
          createMany: {
            args: Prisma.ConferencePaperDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferencePaperDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload>[]
          }
          delete: {
            args: Prisma.ConferencePaperDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload>
          }
          update: {
            args: Prisma.ConferencePaperDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload>
          }
          deleteMany: {
            args: Prisma.ConferencePaperDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferencePaperDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferencePaperDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload>[]
          }
          upsert: {
            args: Prisma.ConferencePaperDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePaperDetailsPayload>
          }
          aggregate: {
            args: Prisma.ConferencePaperDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferencePaperDetails>
          }
          groupBy: {
            args: Prisma.ConferencePaperDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferencePaperDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferencePaperDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferencePaperDetailsCountAggregateOutputType> | number
          }
        }
      }
      FacultyPublicationLink: {
        payload: Prisma.$FacultyPublicationLinkPayload<ExtArgs>
        fields: Prisma.FacultyPublicationLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultyPublicationLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultyPublicationLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload>
          }
          findFirst: {
            args: Prisma.FacultyPublicationLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultyPublicationLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload>
          }
          findMany: {
            args: Prisma.FacultyPublicationLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload>[]
          }
          create: {
            args: Prisma.FacultyPublicationLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload>
          }
          createMany: {
            args: Prisma.FacultyPublicationLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacultyPublicationLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload>[]
          }
          delete: {
            args: Prisma.FacultyPublicationLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload>
          }
          update: {
            args: Prisma.FacultyPublicationLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload>
          }
          deleteMany: {
            args: Prisma.FacultyPublicationLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacultyPublicationLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacultyPublicationLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload>[]
          }
          upsert: {
            args: Prisma.FacultyPublicationLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPublicationLinkPayload>
          }
          aggregate: {
            args: Prisma.FacultyPublicationLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacultyPublicationLink>
          }
          groupBy: {
            args: Prisma.FacultyPublicationLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultyPublicationLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultyPublicationLinkCountArgs<ExtArgs>
            result: $Utils.Optional<FacultyPublicationLinkCountAggregateOutputType> | number
          }
        }
      }
      Patents: {
        payload: Prisma.$PatentsPayload<ExtArgs>
        fields: Prisma.PatentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>
          }
          findFirst: {
            args: Prisma.PatentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>
          }
          findMany: {
            args: Prisma.PatentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>[]
          }
          create: {
            args: Prisma.PatentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>
          }
          createMany: {
            args: Prisma.PatentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>[]
          }
          delete: {
            args: Prisma.PatentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>
          }
          update: {
            args: Prisma.PatentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>
          }
          deleteMany: {
            args: Prisma.PatentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>[]
          }
          upsert: {
            args: Prisma.PatentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>
          }
          aggregate: {
            args: Prisma.PatentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatents>
          }
          groupBy: {
            args: Prisma.PatentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatentsCountArgs<ExtArgs>
            result: $Utils.Optional<PatentsCountAggregateOutputType> | number
          }
        }
      }
      ResearchProjects: {
        payload: Prisma.$ResearchProjectsPayload<ExtArgs>
        fields: Prisma.ResearchProjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchProjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchProjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload>
          }
          findFirst: {
            args: Prisma.ResearchProjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchProjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload>
          }
          findMany: {
            args: Prisma.ResearchProjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload>[]
          }
          create: {
            args: Prisma.ResearchProjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload>
          }
          createMany: {
            args: Prisma.ResearchProjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchProjectsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload>[]
          }
          delete: {
            args: Prisma.ResearchProjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload>
          }
          update: {
            args: Prisma.ResearchProjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload>
          }
          deleteMany: {
            args: Prisma.ResearchProjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchProjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResearchProjectsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload>[]
          }
          upsert: {
            args: Prisma.ResearchProjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectsPayload>
          }
          aggregate: {
            args: Prisma.ResearchProjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchProjects>
          }
          groupBy: {
            args: Prisma.ResearchProjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchProjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchProjectsCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchProjectsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    department?: DepartmentOmit
    faculty?: FacultyOmit
    subjectTaught?: SubjectTaughtOmit
    facultyQualification?: FacultyQualificationOmit
    outReachActivities?: OutReachActivitiesOmit
    eventType?: EventTypeOmit
    eventsOrganised?: EventsOrganisedOmit
    awards?: AwardsOmit
    teachingExperience?: TeachingExperienceOmit
    citationMetrics?: CitationMetricsOmit
    tYPES?: TYPESOmit
    publications?: PublicationsOmit
    journalPublicationDetails?: JournalPublicationDetailsOmit
    bookPublicationDetails?: BookPublicationDetailsOmit
    conferencePaperDetails?: ConferencePaperDetailsOmit
    facultyPublicationLink?: FacultyPublicationLinkOmit
    patents?: PatentsOmit
    researchProjects?: ResearchProjectsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    Faculty: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | DepartmentCountOutputTypeCountFacultyArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountFacultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
  }


  /**
   * Count Type FacultyCountOutputType
   */

  export type FacultyCountOutputType = {
    SubjectsTaught: number
    Qualifications: number
    OutreachActivities: number
    EventsOrganised: number
    Awards: number
    TeachingExperiences: number
    CitationMetrics: number
    Publications: number
    Patents: number
    ResearchProjects: number
  }

  export type FacultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubjectsTaught?: boolean | FacultyCountOutputTypeCountSubjectsTaughtArgs
    Qualifications?: boolean | FacultyCountOutputTypeCountQualificationsArgs
    OutreachActivities?: boolean | FacultyCountOutputTypeCountOutreachActivitiesArgs
    EventsOrganised?: boolean | FacultyCountOutputTypeCountEventsOrganisedArgs
    Awards?: boolean | FacultyCountOutputTypeCountAwardsArgs
    TeachingExperiences?: boolean | FacultyCountOutputTypeCountTeachingExperiencesArgs
    CitationMetrics?: boolean | FacultyCountOutputTypeCountCitationMetricsArgs
    Publications?: boolean | FacultyCountOutputTypeCountPublicationsArgs
    Patents?: boolean | FacultyCountOutputTypeCountPatentsArgs
    ResearchProjects?: boolean | FacultyCountOutputTypeCountResearchProjectsArgs
  }

  // Custom InputTypes
  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyCountOutputType
     */
    select?: FacultyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountSubjectsTaughtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectTaughtWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountQualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyQualificationWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountOutreachActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutReachActivitiesWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountEventsOrganisedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsOrganisedWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountAwardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardsWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountTeachingExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingExperienceWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountCitationMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitationMetricsWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyPublicationLinkWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountPatentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatentsWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountResearchProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchProjectsWhereInput
  }


  /**
   * Count Type EventTypeCountOutputType
   */

  export type EventTypeCountOutputType = {
    EventsOrganised: number
  }

  export type EventTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EventsOrganised?: boolean | EventTypeCountOutputTypeCountEventsOrganisedArgs
  }

  // Custom InputTypes
  /**
   * EventTypeCountOutputType without action
   */
  export type EventTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTypeCountOutputType
     */
    select?: EventTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventTypeCountOutputType without action
   */
  export type EventTypeCountOutputTypeCountEventsOrganisedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsOrganisedWhereInput
  }


  /**
   * Count Type TYPESCountOutputType
   */

  export type TYPESCountOutputType = {
    Publications: number
    Patents: number
    ResearchProjects: number
  }

  export type TYPESCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publications?: boolean | TYPESCountOutputTypeCountPublicationsArgs
    Patents?: boolean | TYPESCountOutputTypeCountPatentsArgs
    ResearchProjects?: boolean | TYPESCountOutputTypeCountResearchProjectsArgs
  }

  // Custom InputTypes
  /**
   * TYPESCountOutputType without action
   */
  export type TYPESCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPESCountOutputType
     */
    select?: TYPESCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TYPESCountOutputType without action
   */
  export type TYPESCountOutputTypeCountPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationsWhereInput
  }

  /**
   * TYPESCountOutputType without action
   */
  export type TYPESCountOutputTypeCountPatentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatentsWhereInput
  }

  /**
   * TYPESCountOutputType without action
   */
  export type TYPESCountOutputTypeCountResearchProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchProjectsWhereInput
  }


  /**
   * Count Type PublicationsCountOutputType
   */

  export type PublicationsCountOutputType = {
    FacultyPublicationLink: number
  }

  export type PublicationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FacultyPublicationLink?: boolean | PublicationsCountOutputTypeCountFacultyPublicationLinkArgs
  }

  // Custom InputTypes
  /**
   * PublicationsCountOutputType without action
   */
  export type PublicationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationsCountOutputType
     */
    select?: PublicationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PublicationsCountOutputType without action
   */
  export type PublicationsCountOutputTypeCountFacultyPublicationLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyPublicationLinkWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    DepartmentID: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    DepartmentID: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    DepartmentID: number | null
    DepartmentName: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    DepartmentID: number | null
    DepartmentName: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    DepartmentID: number
    DepartmentName: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    DepartmentID?: true
  }

  export type DepartmentSumAggregateInputType = {
    DepartmentID?: true
  }

  export type DepartmentMinAggregateInputType = {
    DepartmentID?: true
    DepartmentName?: true
  }

  export type DepartmentMaxAggregateInputType = {
    DepartmentID?: true
    DepartmentName?: true
  }

  export type DepartmentCountAggregateInputType = {
    DepartmentID?: true
    DepartmentName?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    DepartmentID: number
    DepartmentName: string
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    DepartmentID?: boolean
    DepartmentName?: boolean
    Faculty?: boolean | Department$FacultyArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    DepartmentID?: boolean
    DepartmentName?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    DepartmentID?: boolean
    DepartmentName?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    DepartmentID?: boolean
    DepartmentName?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"DepartmentID" | "DepartmentName", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | Department$FacultyArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      DepartmentID: number
      DepartmentName: string
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `DepartmentID`
     * const departmentWithDepartmentIDOnly = await prisma.department.findMany({ select: { DepartmentID: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `DepartmentID`
     * const departmentWithDepartmentIDOnly = await prisma.department.createManyAndReturn({
     *   select: { DepartmentID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `DepartmentID`
     * const departmentWithDepartmentIDOnly = await prisma.department.updateManyAndReturn({
     *   select: { DepartmentID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends Department$FacultyArgs<ExtArgs> = {}>(args?: Subset<T, Department$FacultyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly DepartmentID: FieldRef<"Department", 'Int'>
    readonly DepartmentName: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.Faculty
   */
  export type Department$FacultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    cursor?: FacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Faculty
   */

  export type AggregateFaculty = {
    _count: FacultyCountAggregateOutputType | null
    _avg: FacultyAvgAggregateOutputType | null
    _sum: FacultySumAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  export type FacultyAvgAggregateOutputType = {
    FacultyID: number | null
    DepartmentID: number | null
  }

  export type FacultySumAggregateOutputType = {
    FacultyID: number | null
    DepartmentID: number | null
  }

  export type FacultyMinAggregateOutputType = {
    FacultyID: number | null
    FirstName: string | null
    LastName: string | null
    Gender: string | null
    DOB: Date | null
    Role: string | null
    Phone_no: string | null
    Email: string | null
    DepartmentID: number | null
  }

  export type FacultyMaxAggregateOutputType = {
    FacultyID: number | null
    FirstName: string | null
    LastName: string | null
    Gender: string | null
    DOB: Date | null
    Role: string | null
    Phone_no: string | null
    Email: string | null
    DepartmentID: number | null
  }

  export type FacultyCountAggregateOutputType = {
    FacultyID: number
    FirstName: number
    LastName: number
    Gender: number
    DOB: number
    Role: number
    Phone_no: number
    Email: number
    DepartmentID: number
    _all: number
  }


  export type FacultyAvgAggregateInputType = {
    FacultyID?: true
    DepartmentID?: true
  }

  export type FacultySumAggregateInputType = {
    FacultyID?: true
    DepartmentID?: true
  }

  export type FacultyMinAggregateInputType = {
    FacultyID?: true
    FirstName?: true
    LastName?: true
    Gender?: true
    DOB?: true
    Role?: true
    Phone_no?: true
    Email?: true
    DepartmentID?: true
  }

  export type FacultyMaxAggregateInputType = {
    FacultyID?: true
    FirstName?: true
    LastName?: true
    Gender?: true
    DOB?: true
    Role?: true
    Phone_no?: true
    Email?: true
    DepartmentID?: true
  }

  export type FacultyCountAggregateInputType = {
    FacultyID?: true
    FirstName?: true
    LastName?: true
    Gender?: true
    DOB?: true
    Role?: true
    Phone_no?: true
    Email?: true
    DepartmentID?: true
    _all?: true
  }

  export type FacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculty to aggregate.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faculties
    **/
    _count?: true | FacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacultyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacultySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyMaxAggregateInputType
  }

  export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaculty[P]>
      : GetScalarType<T[P], AggregateFaculty[P]>
  }




  export type FacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithAggregationInput | FacultyOrderByWithAggregationInput[]
    by: FacultyScalarFieldEnum[] | FacultyScalarFieldEnum
    having?: FacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyCountAggregateInputType | true
    _avg?: FacultyAvgAggregateInputType
    _sum?: FacultySumAggregateInputType
    _min?: FacultyMinAggregateInputType
    _max?: FacultyMaxAggregateInputType
  }

  export type FacultyGroupByOutputType = {
    FacultyID: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    _count: FacultyCountAggregateOutputType | null
    _avg: FacultyAvgAggregateOutputType | null
    _sum: FacultySumAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  type GetFacultyGroupByPayload<T extends FacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyGroupByOutputType[P]>
        }
      >
    >


  export type FacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FacultyID?: boolean
    FirstName?: boolean
    LastName?: boolean
    Gender?: boolean
    DOB?: boolean
    Role?: boolean
    Phone_no?: boolean
    Email?: boolean
    DepartmentID?: boolean
    Department?: boolean | DepartmentDefaultArgs<ExtArgs>
    SubjectsTaught?: boolean | Faculty$SubjectsTaughtArgs<ExtArgs>
    Qualifications?: boolean | Faculty$QualificationsArgs<ExtArgs>
    OutreachActivities?: boolean | Faculty$OutreachActivitiesArgs<ExtArgs>
    EventsOrganised?: boolean | Faculty$EventsOrganisedArgs<ExtArgs>
    Awards?: boolean | Faculty$AwardsArgs<ExtArgs>
    TeachingExperiences?: boolean | Faculty$TeachingExperiencesArgs<ExtArgs>
    CitationMetrics?: boolean | Faculty$CitationMetricsArgs<ExtArgs>
    Publications?: boolean | Faculty$PublicationsArgs<ExtArgs>
    Patents?: boolean | Faculty$PatentsArgs<ExtArgs>
    ResearchProjects?: boolean | Faculty$ResearchProjectsArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>

  export type FacultySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FacultyID?: boolean
    FirstName?: boolean
    LastName?: boolean
    Gender?: boolean
    DOB?: boolean
    Role?: boolean
    Phone_no?: boolean
    Email?: boolean
    DepartmentID?: boolean
    Department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>

  export type FacultySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FacultyID?: boolean
    FirstName?: boolean
    LastName?: boolean
    Gender?: boolean
    DOB?: boolean
    Role?: boolean
    Phone_no?: boolean
    Email?: boolean
    DepartmentID?: boolean
    Department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>

  export type FacultySelectScalar = {
    FacultyID?: boolean
    FirstName?: boolean
    LastName?: boolean
    Gender?: boolean
    DOB?: boolean
    Role?: boolean
    Phone_no?: boolean
    Email?: boolean
    DepartmentID?: boolean
  }

  export type FacultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"FacultyID" | "FirstName" | "LastName" | "Gender" | "DOB" | "Role" | "Phone_no" | "Email" | "DepartmentID", ExtArgs["result"]["faculty"]>
  export type FacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Department?: boolean | DepartmentDefaultArgs<ExtArgs>
    SubjectsTaught?: boolean | Faculty$SubjectsTaughtArgs<ExtArgs>
    Qualifications?: boolean | Faculty$QualificationsArgs<ExtArgs>
    OutreachActivities?: boolean | Faculty$OutreachActivitiesArgs<ExtArgs>
    EventsOrganised?: boolean | Faculty$EventsOrganisedArgs<ExtArgs>
    Awards?: boolean | Faculty$AwardsArgs<ExtArgs>
    TeachingExperiences?: boolean | Faculty$TeachingExperiencesArgs<ExtArgs>
    CitationMetrics?: boolean | Faculty$CitationMetricsArgs<ExtArgs>
    Publications?: boolean | Faculty$PublicationsArgs<ExtArgs>
    Patents?: boolean | Faculty$PatentsArgs<ExtArgs>
    ResearchProjects?: boolean | Faculty$ResearchProjectsArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacultyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type FacultyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $FacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Faculty"
    objects: {
      Department: Prisma.$DepartmentPayload<ExtArgs>
      SubjectsTaught: Prisma.$SubjectTaughtPayload<ExtArgs>[]
      Qualifications: Prisma.$FacultyQualificationPayload<ExtArgs>[]
      OutreachActivities: Prisma.$OutReachActivitiesPayload<ExtArgs>[]
      EventsOrganised: Prisma.$EventsOrganisedPayload<ExtArgs>[]
      Awards: Prisma.$AwardsPayload<ExtArgs>[]
      TeachingExperiences: Prisma.$TeachingExperiencePayload<ExtArgs>[]
      CitationMetrics: Prisma.$CitationMetricsPayload<ExtArgs>[]
      Publications: Prisma.$FacultyPublicationLinkPayload<ExtArgs>[]
      Patents: Prisma.$PatentsPayload<ExtArgs>[]
      ResearchProjects: Prisma.$ResearchProjectsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      FacultyID: number
      FirstName: string
      LastName: string
      Gender: string
      DOB: Date
      Role: string
      Phone_no: string
      Email: string
      DepartmentID: number
    }, ExtArgs["result"]["faculty"]>
    composites: {}
  }

  type FacultyGetPayload<S extends boolean | null | undefined | FacultyDefaultArgs> = $Result.GetResult<Prisma.$FacultyPayload, S>

  type FacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacultyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacultyCountAggregateInputType | true
    }

  export interface FacultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faculty'], meta: { name: 'Faculty' } }
    /**
     * Find zero or one Faculty that matches the filter.
     * @param {FacultyFindUniqueArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultyFindUniqueArgs>(args: SelectSubset<T, FacultyFindUniqueArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faculty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacultyFindUniqueOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultyFindUniqueOrThrowArgs>(args: SelectSubset<T, FacultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultyFindFirstArgs>(args?: SelectSubset<T, FacultyFindFirstArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultyFindFirstOrThrowArgs>(args?: SelectSubset<T, FacultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faculties
     * const faculties = await prisma.faculty.findMany()
     * 
     * // Get first 10 Faculties
     * const faculties = await prisma.faculty.findMany({ take: 10 })
     * 
     * // Only select the `FacultyID`
     * const facultyWithFacultyIDOnly = await prisma.faculty.findMany({ select: { FacultyID: true } })
     * 
     */
    findMany<T extends FacultyFindManyArgs>(args?: SelectSubset<T, FacultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faculty.
     * @param {FacultyCreateArgs} args - Arguments to create a Faculty.
     * @example
     * // Create one Faculty
     * const Faculty = await prisma.faculty.create({
     *   data: {
     *     // ... data to create a Faculty
     *   }
     * })
     * 
     */
    create<T extends FacultyCreateArgs>(args: SelectSubset<T, FacultyCreateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faculties.
     * @param {FacultyCreateManyArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacultyCreateManyArgs>(args?: SelectSubset<T, FacultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Faculties and returns the data saved in the database.
     * @param {FacultyCreateManyAndReturnArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Faculties and only return the `FacultyID`
     * const facultyWithFacultyIDOnly = await prisma.faculty.createManyAndReturn({
     *   select: { FacultyID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacultyCreateManyAndReturnArgs>(args?: SelectSubset<T, FacultyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Faculty.
     * @param {FacultyDeleteArgs} args - Arguments to delete one Faculty.
     * @example
     * // Delete one Faculty
     * const Faculty = await prisma.faculty.delete({
     *   where: {
     *     // ... filter to delete one Faculty
     *   }
     * })
     * 
     */
    delete<T extends FacultyDeleteArgs>(args: SelectSubset<T, FacultyDeleteArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faculty.
     * @param {FacultyUpdateArgs} args - Arguments to update one Faculty.
     * @example
     * // Update one Faculty
     * const faculty = await prisma.faculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacultyUpdateArgs>(args: SelectSubset<T, FacultyUpdateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faculties.
     * @param {FacultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
     * @example
     * // Delete a few Faculties
     * const { count } = await prisma.faculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacultyDeleteManyArgs>(args?: SelectSubset<T, FacultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacultyUpdateManyArgs>(args: SelectSubset<T, FacultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties and returns the data updated in the database.
     * @param {FacultyUpdateManyAndReturnArgs} args - Arguments to update many Faculties.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Faculties and only return the `FacultyID`
     * const facultyWithFacultyIDOnly = await prisma.faculty.updateManyAndReturn({
     *   select: { FacultyID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacultyUpdateManyAndReturnArgs>(args: SelectSubset<T, FacultyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Faculty.
     * @param {FacultyUpsertArgs} args - Arguments to update or create a Faculty.
     * @example
     * // Update or create a Faculty
     * const faculty = await prisma.faculty.upsert({
     *   create: {
     *     // ... data to create a Faculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faculty we want to update
     *   }
     * })
     */
    upsert<T extends FacultyUpsertArgs>(args: SelectSubset<T, FacultyUpsertArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyCountArgs} args - Arguments to filter Faculties to count.
     * @example
     * // Count the number of Faculties
     * const count = await prisma.faculty.count({
     *   where: {
     *     // ... the filter for the Faculties we want to count
     *   }
     * })
    **/
    count<T extends FacultyCountArgs>(
      args?: Subset<T, FacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyAggregateArgs>(args: Subset<T, FacultyAggregateArgs>): Prisma.PrismaPromise<GetFacultyAggregateType<T>>

    /**
     * Group by Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyGroupByArgs['orderBy'] }
        : { orderBy?: FacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Faculty model
   */
  readonly fields: FacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SubjectsTaught<T extends Faculty$SubjectsTaughtArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$SubjectsTaughtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Qualifications<T extends Faculty$QualificationsArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$QualificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OutreachActivities<T extends Faculty$OutreachActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$OutreachActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EventsOrganised<T extends Faculty$EventsOrganisedArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$EventsOrganisedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Awards<T extends Faculty$AwardsArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$AwardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TeachingExperiences<T extends Faculty$TeachingExperiencesArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$TeachingExperiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CitationMetrics<T extends Faculty$CitationMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$CitationMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Publications<T extends Faculty$PublicationsArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$PublicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Patents<T extends Faculty$PatentsArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$PatentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ResearchProjects<T extends Faculty$ResearchProjectsArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$ResearchProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Faculty model
   */
  interface FacultyFieldRefs {
    readonly FacultyID: FieldRef<"Faculty", 'Int'>
    readonly FirstName: FieldRef<"Faculty", 'String'>
    readonly LastName: FieldRef<"Faculty", 'String'>
    readonly Gender: FieldRef<"Faculty", 'String'>
    readonly DOB: FieldRef<"Faculty", 'DateTime'>
    readonly Role: FieldRef<"Faculty", 'String'>
    readonly Phone_no: FieldRef<"Faculty", 'String'>
    readonly Email: FieldRef<"Faculty", 'String'>
    readonly DepartmentID: FieldRef<"Faculty", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Faculty findUnique
   */
  export type FacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findUniqueOrThrow
   */
  export type FacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findFirst
   */
  export type FacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findFirstOrThrow
   */
  export type FacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findMany
   */
  export type FacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculties to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty create
   */
  export type FacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a Faculty.
     */
    data: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
  }

  /**
   * Faculty createMany
   */
  export type FacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Faculty createManyAndReturn
   */
  export type FacultyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Faculty update
   */
  export type FacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a Faculty.
     */
    data: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
    /**
     * Choose, which Faculty to update.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty updateMany
   */
  export type FacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to update.
     */
    limit?: number
  }

  /**
   * Faculty updateManyAndReturn
   */
  export type FacultyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Faculty upsert
   */
  export type FacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the Faculty to update in case it exists.
     */
    where: FacultyWhereUniqueInput
    /**
     * In case the Faculty found by the `where` argument doesn't exist, create a new Faculty with this data.
     */
    create: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
    /**
     * In case the Faculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
  }

  /**
   * Faculty delete
   */
  export type FacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter which Faculty to delete.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty deleteMany
   */
  export type FacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculties to delete
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to delete.
     */
    limit?: number
  }

  /**
   * Faculty.SubjectsTaught
   */
  export type Faculty$SubjectsTaughtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
    where?: SubjectTaughtWhereInput
    orderBy?: SubjectTaughtOrderByWithRelationInput | SubjectTaughtOrderByWithRelationInput[]
    cursor?: SubjectTaughtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectTaughtScalarFieldEnum | SubjectTaughtScalarFieldEnum[]
  }

  /**
   * Faculty.Qualifications
   */
  export type Faculty$QualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
    where?: FacultyQualificationWhereInput
    orderBy?: FacultyQualificationOrderByWithRelationInput | FacultyQualificationOrderByWithRelationInput[]
    cursor?: FacultyQualificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyQualificationScalarFieldEnum | FacultyQualificationScalarFieldEnum[]
  }

  /**
   * Faculty.OutreachActivities
   */
  export type Faculty$OutreachActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
    where?: OutReachActivitiesWhereInput
    orderBy?: OutReachActivitiesOrderByWithRelationInput | OutReachActivitiesOrderByWithRelationInput[]
    cursor?: OutReachActivitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutReachActivitiesScalarFieldEnum | OutReachActivitiesScalarFieldEnum[]
  }

  /**
   * Faculty.EventsOrganised
   */
  export type Faculty$EventsOrganisedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    where?: EventsOrganisedWhereInput
    orderBy?: EventsOrganisedOrderByWithRelationInput | EventsOrganisedOrderByWithRelationInput[]
    cursor?: EventsOrganisedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsOrganisedScalarFieldEnum | EventsOrganisedScalarFieldEnum[]
  }

  /**
   * Faculty.Awards
   */
  export type Faculty$AwardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
    where?: AwardsWhereInput
    orderBy?: AwardsOrderByWithRelationInput | AwardsOrderByWithRelationInput[]
    cursor?: AwardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AwardsScalarFieldEnum | AwardsScalarFieldEnum[]
  }

  /**
   * Faculty.TeachingExperiences
   */
  export type Faculty$TeachingExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
    where?: TeachingExperienceWhereInput
    orderBy?: TeachingExperienceOrderByWithRelationInput | TeachingExperienceOrderByWithRelationInput[]
    cursor?: TeachingExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachingExperienceScalarFieldEnum | TeachingExperienceScalarFieldEnum[]
  }

  /**
   * Faculty.CitationMetrics
   */
  export type Faculty$CitationMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
    where?: CitationMetricsWhereInput
    orderBy?: CitationMetricsOrderByWithRelationInput | CitationMetricsOrderByWithRelationInput[]
    cursor?: CitationMetricsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitationMetricsScalarFieldEnum | CitationMetricsScalarFieldEnum[]
  }

  /**
   * Faculty.Publications
   */
  export type Faculty$PublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    where?: FacultyPublicationLinkWhereInput
    orderBy?: FacultyPublicationLinkOrderByWithRelationInput | FacultyPublicationLinkOrderByWithRelationInput[]
    cursor?: FacultyPublicationLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyPublicationLinkScalarFieldEnum | FacultyPublicationLinkScalarFieldEnum[]
  }

  /**
   * Faculty.Patents
   */
  export type Faculty$PatentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    where?: PatentsWhereInput
    orderBy?: PatentsOrderByWithRelationInput | PatentsOrderByWithRelationInput[]
    cursor?: PatentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatentsScalarFieldEnum | PatentsScalarFieldEnum[]
  }

  /**
   * Faculty.ResearchProjects
   */
  export type Faculty$ResearchProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    where?: ResearchProjectsWhereInput
    orderBy?: ResearchProjectsOrderByWithRelationInput | ResearchProjectsOrderByWithRelationInput[]
    cursor?: ResearchProjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchProjectsScalarFieldEnum | ResearchProjectsScalarFieldEnum[]
  }

  /**
   * Faculty without action
   */
  export type FacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
  }


  /**
   * Model SubjectTaught
   */

  export type AggregateSubjectTaught = {
    _count: SubjectTaughtCountAggregateOutputType | null
    _avg: SubjectTaughtAvgAggregateOutputType | null
    _sum: SubjectTaughtSumAggregateOutputType | null
    _min: SubjectTaughtMinAggregateOutputType | null
    _max: SubjectTaughtMaxAggregateOutputType | null
  }

  export type SubjectTaughtAvgAggregateOutputType = {
    FacultyID: number | null
  }

  export type SubjectTaughtSumAggregateOutputType = {
    FacultyID: number | null
  }

  export type SubjectTaughtMinAggregateOutputType = {
    FacultyID: number | null
    Level: string | null
    SubjectName: string | null
    CourseCode: string | null
    ProgramName: string | null
    Note: string | null
  }

  export type SubjectTaughtMaxAggregateOutputType = {
    FacultyID: number | null
    Level: string | null
    SubjectName: string | null
    CourseCode: string | null
    ProgramName: string | null
    Note: string | null
  }

  export type SubjectTaughtCountAggregateOutputType = {
    FacultyID: number
    Level: number
    SubjectName: number
    CourseCode: number
    ProgramName: number
    Note: number
    _all: number
  }


  export type SubjectTaughtAvgAggregateInputType = {
    FacultyID?: true
  }

  export type SubjectTaughtSumAggregateInputType = {
    FacultyID?: true
  }

  export type SubjectTaughtMinAggregateInputType = {
    FacultyID?: true
    Level?: true
    SubjectName?: true
    CourseCode?: true
    ProgramName?: true
    Note?: true
  }

  export type SubjectTaughtMaxAggregateInputType = {
    FacultyID?: true
    Level?: true
    SubjectName?: true
    CourseCode?: true
    ProgramName?: true
    Note?: true
  }

  export type SubjectTaughtCountAggregateInputType = {
    FacultyID?: true
    Level?: true
    SubjectName?: true
    CourseCode?: true
    ProgramName?: true
    Note?: true
    _all?: true
  }

  export type SubjectTaughtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubjectTaught to aggregate.
     */
    where?: SubjectTaughtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectTaughts to fetch.
     */
    orderBy?: SubjectTaughtOrderByWithRelationInput | SubjectTaughtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectTaughtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectTaughts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectTaughts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubjectTaughts
    **/
    _count?: true | SubjectTaughtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectTaughtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectTaughtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectTaughtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectTaughtMaxAggregateInputType
  }

  export type GetSubjectTaughtAggregateType<T extends SubjectTaughtAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjectTaught]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjectTaught[P]>
      : GetScalarType<T[P], AggregateSubjectTaught[P]>
  }




  export type SubjectTaughtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectTaughtWhereInput
    orderBy?: SubjectTaughtOrderByWithAggregationInput | SubjectTaughtOrderByWithAggregationInput[]
    by: SubjectTaughtScalarFieldEnum[] | SubjectTaughtScalarFieldEnum
    having?: SubjectTaughtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectTaughtCountAggregateInputType | true
    _avg?: SubjectTaughtAvgAggregateInputType
    _sum?: SubjectTaughtSumAggregateInputType
    _min?: SubjectTaughtMinAggregateInputType
    _max?: SubjectTaughtMaxAggregateInputType
  }

  export type SubjectTaughtGroupByOutputType = {
    FacultyID: number
    Level: string
    SubjectName: string
    CourseCode: string | null
    ProgramName: string | null
    Note: string | null
    _count: SubjectTaughtCountAggregateOutputType | null
    _avg: SubjectTaughtAvgAggregateOutputType | null
    _sum: SubjectTaughtSumAggregateOutputType | null
    _min: SubjectTaughtMinAggregateOutputType | null
    _max: SubjectTaughtMaxAggregateOutputType | null
  }

  type GetSubjectTaughtGroupByPayload<T extends SubjectTaughtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectTaughtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectTaughtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectTaughtGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectTaughtGroupByOutputType[P]>
        }
      >
    >


  export type SubjectTaughtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FacultyID?: boolean
    Level?: boolean
    SubjectName?: boolean
    CourseCode?: boolean
    ProgramName?: boolean
    Note?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjectTaught"]>

  export type SubjectTaughtSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FacultyID?: boolean
    Level?: boolean
    SubjectName?: boolean
    CourseCode?: boolean
    ProgramName?: boolean
    Note?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjectTaught"]>

  export type SubjectTaughtSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FacultyID?: boolean
    Level?: boolean
    SubjectName?: boolean
    CourseCode?: boolean
    ProgramName?: boolean
    Note?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjectTaught"]>

  export type SubjectTaughtSelectScalar = {
    FacultyID?: boolean
    Level?: boolean
    SubjectName?: boolean
    CourseCode?: boolean
    ProgramName?: boolean
    Note?: boolean
  }

  export type SubjectTaughtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"FacultyID" | "Level" | "SubjectName" | "CourseCode" | "ProgramName" | "Note", ExtArgs["result"]["subjectTaught"]>
  export type SubjectTaughtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type SubjectTaughtIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type SubjectTaughtIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $SubjectTaughtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubjectTaught"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      FacultyID: number
      Level: string
      SubjectName: string
      CourseCode: string | null
      ProgramName: string | null
      Note: string | null
    }, ExtArgs["result"]["subjectTaught"]>
    composites: {}
  }

  type SubjectTaughtGetPayload<S extends boolean | null | undefined | SubjectTaughtDefaultArgs> = $Result.GetResult<Prisma.$SubjectTaughtPayload, S>

  type SubjectTaughtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectTaughtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectTaughtCountAggregateInputType | true
    }

  export interface SubjectTaughtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubjectTaught'], meta: { name: 'SubjectTaught' } }
    /**
     * Find zero or one SubjectTaught that matches the filter.
     * @param {SubjectTaughtFindUniqueArgs} args - Arguments to find a SubjectTaught
     * @example
     * // Get one SubjectTaught
     * const subjectTaught = await prisma.subjectTaught.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectTaughtFindUniqueArgs>(args: SelectSubset<T, SubjectTaughtFindUniqueArgs<ExtArgs>>): Prisma__SubjectTaughtClient<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubjectTaught that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectTaughtFindUniqueOrThrowArgs} args - Arguments to find a SubjectTaught
     * @example
     * // Get one SubjectTaught
     * const subjectTaught = await prisma.subjectTaught.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectTaughtFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectTaughtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectTaughtClient<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubjectTaught that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTaughtFindFirstArgs} args - Arguments to find a SubjectTaught
     * @example
     * // Get one SubjectTaught
     * const subjectTaught = await prisma.subjectTaught.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectTaughtFindFirstArgs>(args?: SelectSubset<T, SubjectTaughtFindFirstArgs<ExtArgs>>): Prisma__SubjectTaughtClient<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubjectTaught that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTaughtFindFirstOrThrowArgs} args - Arguments to find a SubjectTaught
     * @example
     * // Get one SubjectTaught
     * const subjectTaught = await prisma.subjectTaught.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectTaughtFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectTaughtFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectTaughtClient<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubjectTaughts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTaughtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubjectTaughts
     * const subjectTaughts = await prisma.subjectTaught.findMany()
     * 
     * // Get first 10 SubjectTaughts
     * const subjectTaughts = await prisma.subjectTaught.findMany({ take: 10 })
     * 
     * // Only select the `FacultyID`
     * const subjectTaughtWithFacultyIDOnly = await prisma.subjectTaught.findMany({ select: { FacultyID: true } })
     * 
     */
    findMany<T extends SubjectTaughtFindManyArgs>(args?: SelectSubset<T, SubjectTaughtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubjectTaught.
     * @param {SubjectTaughtCreateArgs} args - Arguments to create a SubjectTaught.
     * @example
     * // Create one SubjectTaught
     * const SubjectTaught = await prisma.subjectTaught.create({
     *   data: {
     *     // ... data to create a SubjectTaught
     *   }
     * })
     * 
     */
    create<T extends SubjectTaughtCreateArgs>(args: SelectSubset<T, SubjectTaughtCreateArgs<ExtArgs>>): Prisma__SubjectTaughtClient<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubjectTaughts.
     * @param {SubjectTaughtCreateManyArgs} args - Arguments to create many SubjectTaughts.
     * @example
     * // Create many SubjectTaughts
     * const subjectTaught = await prisma.subjectTaught.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectTaughtCreateManyArgs>(args?: SelectSubset<T, SubjectTaughtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubjectTaughts and returns the data saved in the database.
     * @param {SubjectTaughtCreateManyAndReturnArgs} args - Arguments to create many SubjectTaughts.
     * @example
     * // Create many SubjectTaughts
     * const subjectTaught = await prisma.subjectTaught.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubjectTaughts and only return the `FacultyID`
     * const subjectTaughtWithFacultyIDOnly = await prisma.subjectTaught.createManyAndReturn({
     *   select: { FacultyID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectTaughtCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectTaughtCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubjectTaught.
     * @param {SubjectTaughtDeleteArgs} args - Arguments to delete one SubjectTaught.
     * @example
     * // Delete one SubjectTaught
     * const SubjectTaught = await prisma.subjectTaught.delete({
     *   where: {
     *     // ... filter to delete one SubjectTaught
     *   }
     * })
     * 
     */
    delete<T extends SubjectTaughtDeleteArgs>(args: SelectSubset<T, SubjectTaughtDeleteArgs<ExtArgs>>): Prisma__SubjectTaughtClient<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubjectTaught.
     * @param {SubjectTaughtUpdateArgs} args - Arguments to update one SubjectTaught.
     * @example
     * // Update one SubjectTaught
     * const subjectTaught = await prisma.subjectTaught.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectTaughtUpdateArgs>(args: SelectSubset<T, SubjectTaughtUpdateArgs<ExtArgs>>): Prisma__SubjectTaughtClient<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubjectTaughts.
     * @param {SubjectTaughtDeleteManyArgs} args - Arguments to filter SubjectTaughts to delete.
     * @example
     * // Delete a few SubjectTaughts
     * const { count } = await prisma.subjectTaught.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectTaughtDeleteManyArgs>(args?: SelectSubset<T, SubjectTaughtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubjectTaughts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTaughtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubjectTaughts
     * const subjectTaught = await prisma.subjectTaught.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectTaughtUpdateManyArgs>(args: SelectSubset<T, SubjectTaughtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubjectTaughts and returns the data updated in the database.
     * @param {SubjectTaughtUpdateManyAndReturnArgs} args - Arguments to update many SubjectTaughts.
     * @example
     * // Update many SubjectTaughts
     * const subjectTaught = await prisma.subjectTaught.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubjectTaughts and only return the `FacultyID`
     * const subjectTaughtWithFacultyIDOnly = await prisma.subjectTaught.updateManyAndReturn({
     *   select: { FacultyID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectTaughtUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectTaughtUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubjectTaught.
     * @param {SubjectTaughtUpsertArgs} args - Arguments to update or create a SubjectTaught.
     * @example
     * // Update or create a SubjectTaught
     * const subjectTaught = await prisma.subjectTaught.upsert({
     *   create: {
     *     // ... data to create a SubjectTaught
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubjectTaught we want to update
     *   }
     * })
     */
    upsert<T extends SubjectTaughtUpsertArgs>(args: SelectSubset<T, SubjectTaughtUpsertArgs<ExtArgs>>): Prisma__SubjectTaughtClient<$Result.GetResult<Prisma.$SubjectTaughtPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubjectTaughts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTaughtCountArgs} args - Arguments to filter SubjectTaughts to count.
     * @example
     * // Count the number of SubjectTaughts
     * const count = await prisma.subjectTaught.count({
     *   where: {
     *     // ... the filter for the SubjectTaughts we want to count
     *   }
     * })
    **/
    count<T extends SubjectTaughtCountArgs>(
      args?: Subset<T, SubjectTaughtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectTaughtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubjectTaught.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTaughtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectTaughtAggregateArgs>(args: Subset<T, SubjectTaughtAggregateArgs>): Prisma.PrismaPromise<GetSubjectTaughtAggregateType<T>>

    /**
     * Group by SubjectTaught.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTaughtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectTaughtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectTaughtGroupByArgs['orderBy'] }
        : { orderBy?: SubjectTaughtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectTaughtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectTaughtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubjectTaught model
   */
  readonly fields: SubjectTaughtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubjectTaught.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectTaughtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubjectTaught model
   */
  interface SubjectTaughtFieldRefs {
    readonly FacultyID: FieldRef<"SubjectTaught", 'Int'>
    readonly Level: FieldRef<"SubjectTaught", 'String'>
    readonly SubjectName: FieldRef<"SubjectTaught", 'String'>
    readonly CourseCode: FieldRef<"SubjectTaught", 'String'>
    readonly ProgramName: FieldRef<"SubjectTaught", 'String'>
    readonly Note: FieldRef<"SubjectTaught", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubjectTaught findUnique
   */
  export type SubjectTaughtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
    /**
     * Filter, which SubjectTaught to fetch.
     */
    where: SubjectTaughtWhereUniqueInput
  }

  /**
   * SubjectTaught findUniqueOrThrow
   */
  export type SubjectTaughtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
    /**
     * Filter, which SubjectTaught to fetch.
     */
    where: SubjectTaughtWhereUniqueInput
  }

  /**
   * SubjectTaught findFirst
   */
  export type SubjectTaughtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
    /**
     * Filter, which SubjectTaught to fetch.
     */
    where?: SubjectTaughtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectTaughts to fetch.
     */
    orderBy?: SubjectTaughtOrderByWithRelationInput | SubjectTaughtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubjectTaughts.
     */
    cursor?: SubjectTaughtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectTaughts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectTaughts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubjectTaughts.
     */
    distinct?: SubjectTaughtScalarFieldEnum | SubjectTaughtScalarFieldEnum[]
  }

  /**
   * SubjectTaught findFirstOrThrow
   */
  export type SubjectTaughtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
    /**
     * Filter, which SubjectTaught to fetch.
     */
    where?: SubjectTaughtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectTaughts to fetch.
     */
    orderBy?: SubjectTaughtOrderByWithRelationInput | SubjectTaughtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubjectTaughts.
     */
    cursor?: SubjectTaughtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectTaughts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectTaughts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubjectTaughts.
     */
    distinct?: SubjectTaughtScalarFieldEnum | SubjectTaughtScalarFieldEnum[]
  }

  /**
   * SubjectTaught findMany
   */
  export type SubjectTaughtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
    /**
     * Filter, which SubjectTaughts to fetch.
     */
    where?: SubjectTaughtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectTaughts to fetch.
     */
    orderBy?: SubjectTaughtOrderByWithRelationInput | SubjectTaughtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubjectTaughts.
     */
    cursor?: SubjectTaughtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectTaughts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectTaughts.
     */
    skip?: number
    distinct?: SubjectTaughtScalarFieldEnum | SubjectTaughtScalarFieldEnum[]
  }

  /**
   * SubjectTaught create
   */
  export type SubjectTaughtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
    /**
     * The data needed to create a SubjectTaught.
     */
    data: XOR<SubjectTaughtCreateInput, SubjectTaughtUncheckedCreateInput>
  }

  /**
   * SubjectTaught createMany
   */
  export type SubjectTaughtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubjectTaughts.
     */
    data: SubjectTaughtCreateManyInput | SubjectTaughtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubjectTaught createManyAndReturn
   */
  export type SubjectTaughtCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * The data used to create many SubjectTaughts.
     */
    data: SubjectTaughtCreateManyInput | SubjectTaughtCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubjectTaught update
   */
  export type SubjectTaughtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
    /**
     * The data needed to update a SubjectTaught.
     */
    data: XOR<SubjectTaughtUpdateInput, SubjectTaughtUncheckedUpdateInput>
    /**
     * Choose, which SubjectTaught to update.
     */
    where: SubjectTaughtWhereUniqueInput
  }

  /**
   * SubjectTaught updateMany
   */
  export type SubjectTaughtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubjectTaughts.
     */
    data: XOR<SubjectTaughtUpdateManyMutationInput, SubjectTaughtUncheckedUpdateManyInput>
    /**
     * Filter which SubjectTaughts to update
     */
    where?: SubjectTaughtWhereInput
    /**
     * Limit how many SubjectTaughts to update.
     */
    limit?: number
  }

  /**
   * SubjectTaught updateManyAndReturn
   */
  export type SubjectTaughtUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * The data used to update SubjectTaughts.
     */
    data: XOR<SubjectTaughtUpdateManyMutationInput, SubjectTaughtUncheckedUpdateManyInput>
    /**
     * Filter which SubjectTaughts to update
     */
    where?: SubjectTaughtWhereInput
    /**
     * Limit how many SubjectTaughts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubjectTaught upsert
   */
  export type SubjectTaughtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
    /**
     * The filter to search for the SubjectTaught to update in case it exists.
     */
    where: SubjectTaughtWhereUniqueInput
    /**
     * In case the SubjectTaught found by the `where` argument doesn't exist, create a new SubjectTaught with this data.
     */
    create: XOR<SubjectTaughtCreateInput, SubjectTaughtUncheckedCreateInput>
    /**
     * In case the SubjectTaught was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectTaughtUpdateInput, SubjectTaughtUncheckedUpdateInput>
  }

  /**
   * SubjectTaught delete
   */
  export type SubjectTaughtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
    /**
     * Filter which SubjectTaught to delete.
     */
    where: SubjectTaughtWhereUniqueInput
  }

  /**
   * SubjectTaught deleteMany
   */
  export type SubjectTaughtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubjectTaughts to delete
     */
    where?: SubjectTaughtWhereInput
    /**
     * Limit how many SubjectTaughts to delete.
     */
    limit?: number
  }

  /**
   * SubjectTaught without action
   */
  export type SubjectTaughtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTaught
     */
    select?: SubjectTaughtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTaught
     */
    omit?: SubjectTaughtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTaughtInclude<ExtArgs> | null
  }


  /**
   * Model FacultyQualification
   */

  export type AggregateFacultyQualification = {
    _count: FacultyQualificationCountAggregateOutputType | null
    _avg: FacultyQualificationAvgAggregateOutputType | null
    _sum: FacultyQualificationSumAggregateOutputType | null
    _min: FacultyQualificationMinAggregateOutputType | null
    _max: FacultyQualificationMaxAggregateOutputType | null
  }

  export type FacultyQualificationAvgAggregateOutputType = {
    QualificationID: number | null
    FacultyID: number | null
  }

  export type FacultyQualificationSumAggregateOutputType = {
    QualificationID: number | null
    FacultyID: number | null
  }

  export type FacultyQualificationMinAggregateOutputType = {
    QualificationID: number | null
    FacultyID: number | null
    Degree: string | null
    Institution: string | null
    YearOfCompletion: Date | null
  }

  export type FacultyQualificationMaxAggregateOutputType = {
    QualificationID: number | null
    FacultyID: number | null
    Degree: string | null
    Institution: string | null
    YearOfCompletion: Date | null
  }

  export type FacultyQualificationCountAggregateOutputType = {
    QualificationID: number
    FacultyID: number
    Degree: number
    Institution: number
    YearOfCompletion: number
    _all: number
  }


  export type FacultyQualificationAvgAggregateInputType = {
    QualificationID?: true
    FacultyID?: true
  }

  export type FacultyQualificationSumAggregateInputType = {
    QualificationID?: true
    FacultyID?: true
  }

  export type FacultyQualificationMinAggregateInputType = {
    QualificationID?: true
    FacultyID?: true
    Degree?: true
    Institution?: true
    YearOfCompletion?: true
  }

  export type FacultyQualificationMaxAggregateInputType = {
    QualificationID?: true
    FacultyID?: true
    Degree?: true
    Institution?: true
    YearOfCompletion?: true
  }

  export type FacultyQualificationCountAggregateInputType = {
    QualificationID?: true
    FacultyID?: true
    Degree?: true
    Institution?: true
    YearOfCompletion?: true
    _all?: true
  }

  export type FacultyQualificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacultyQualification to aggregate.
     */
    where?: FacultyQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyQualifications to fetch.
     */
    orderBy?: FacultyQualificationOrderByWithRelationInput | FacultyQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultyQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacultyQualifications
    **/
    _count?: true | FacultyQualificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacultyQualificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacultyQualificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyQualificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyQualificationMaxAggregateInputType
  }

  export type GetFacultyQualificationAggregateType<T extends FacultyQualificationAggregateArgs> = {
        [P in keyof T & keyof AggregateFacultyQualification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacultyQualification[P]>
      : GetScalarType<T[P], AggregateFacultyQualification[P]>
  }




  export type FacultyQualificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyQualificationWhereInput
    orderBy?: FacultyQualificationOrderByWithAggregationInput | FacultyQualificationOrderByWithAggregationInput[]
    by: FacultyQualificationScalarFieldEnum[] | FacultyQualificationScalarFieldEnum
    having?: FacultyQualificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyQualificationCountAggregateInputType | true
    _avg?: FacultyQualificationAvgAggregateInputType
    _sum?: FacultyQualificationSumAggregateInputType
    _min?: FacultyQualificationMinAggregateInputType
    _max?: FacultyQualificationMaxAggregateInputType
  }

  export type FacultyQualificationGroupByOutputType = {
    QualificationID: number
    FacultyID: number
    Degree: string
    Institution: string
    YearOfCompletion: Date
    _count: FacultyQualificationCountAggregateOutputType | null
    _avg: FacultyQualificationAvgAggregateOutputType | null
    _sum: FacultyQualificationSumAggregateOutputType | null
    _min: FacultyQualificationMinAggregateOutputType | null
    _max: FacultyQualificationMaxAggregateOutputType | null
  }

  type GetFacultyQualificationGroupByPayload<T extends FacultyQualificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyQualificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyQualificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyQualificationGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyQualificationGroupByOutputType[P]>
        }
      >
    >


  export type FacultyQualificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    QualificationID?: boolean
    FacultyID?: boolean
    Degree?: boolean
    Institution?: boolean
    YearOfCompletion?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facultyQualification"]>

  export type FacultyQualificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    QualificationID?: boolean
    FacultyID?: boolean
    Degree?: boolean
    Institution?: boolean
    YearOfCompletion?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facultyQualification"]>

  export type FacultyQualificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    QualificationID?: boolean
    FacultyID?: boolean
    Degree?: boolean
    Institution?: boolean
    YearOfCompletion?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facultyQualification"]>

  export type FacultyQualificationSelectScalar = {
    QualificationID?: boolean
    FacultyID?: boolean
    Degree?: boolean
    Institution?: boolean
    YearOfCompletion?: boolean
  }

  export type FacultyQualificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"QualificationID" | "FacultyID" | "Degree" | "Institution" | "YearOfCompletion", ExtArgs["result"]["facultyQualification"]>
  export type FacultyQualificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type FacultyQualificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type FacultyQualificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $FacultyQualificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacultyQualification"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      QualificationID: number
      FacultyID: number
      Degree: string
      Institution: string
      YearOfCompletion: Date
    }, ExtArgs["result"]["facultyQualification"]>
    composites: {}
  }

  type FacultyQualificationGetPayload<S extends boolean | null | undefined | FacultyQualificationDefaultArgs> = $Result.GetResult<Prisma.$FacultyQualificationPayload, S>

  type FacultyQualificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacultyQualificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacultyQualificationCountAggregateInputType | true
    }

  export interface FacultyQualificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacultyQualification'], meta: { name: 'FacultyQualification' } }
    /**
     * Find zero or one FacultyQualification that matches the filter.
     * @param {FacultyQualificationFindUniqueArgs} args - Arguments to find a FacultyQualification
     * @example
     * // Get one FacultyQualification
     * const facultyQualification = await prisma.facultyQualification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultyQualificationFindUniqueArgs>(args: SelectSubset<T, FacultyQualificationFindUniqueArgs<ExtArgs>>): Prisma__FacultyQualificationClient<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacultyQualification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacultyQualificationFindUniqueOrThrowArgs} args - Arguments to find a FacultyQualification
     * @example
     * // Get one FacultyQualification
     * const facultyQualification = await prisma.facultyQualification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultyQualificationFindUniqueOrThrowArgs>(args: SelectSubset<T, FacultyQualificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacultyQualificationClient<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacultyQualification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyQualificationFindFirstArgs} args - Arguments to find a FacultyQualification
     * @example
     * // Get one FacultyQualification
     * const facultyQualification = await prisma.facultyQualification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultyQualificationFindFirstArgs>(args?: SelectSubset<T, FacultyQualificationFindFirstArgs<ExtArgs>>): Prisma__FacultyQualificationClient<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacultyQualification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyQualificationFindFirstOrThrowArgs} args - Arguments to find a FacultyQualification
     * @example
     * // Get one FacultyQualification
     * const facultyQualification = await prisma.facultyQualification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultyQualificationFindFirstOrThrowArgs>(args?: SelectSubset<T, FacultyQualificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacultyQualificationClient<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacultyQualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyQualificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacultyQualifications
     * const facultyQualifications = await prisma.facultyQualification.findMany()
     * 
     * // Get first 10 FacultyQualifications
     * const facultyQualifications = await prisma.facultyQualification.findMany({ take: 10 })
     * 
     * // Only select the `QualificationID`
     * const facultyQualificationWithQualificationIDOnly = await prisma.facultyQualification.findMany({ select: { QualificationID: true } })
     * 
     */
    findMany<T extends FacultyQualificationFindManyArgs>(args?: SelectSubset<T, FacultyQualificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacultyQualification.
     * @param {FacultyQualificationCreateArgs} args - Arguments to create a FacultyQualification.
     * @example
     * // Create one FacultyQualification
     * const FacultyQualification = await prisma.facultyQualification.create({
     *   data: {
     *     // ... data to create a FacultyQualification
     *   }
     * })
     * 
     */
    create<T extends FacultyQualificationCreateArgs>(args: SelectSubset<T, FacultyQualificationCreateArgs<ExtArgs>>): Prisma__FacultyQualificationClient<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacultyQualifications.
     * @param {FacultyQualificationCreateManyArgs} args - Arguments to create many FacultyQualifications.
     * @example
     * // Create many FacultyQualifications
     * const facultyQualification = await prisma.facultyQualification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacultyQualificationCreateManyArgs>(args?: SelectSubset<T, FacultyQualificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacultyQualifications and returns the data saved in the database.
     * @param {FacultyQualificationCreateManyAndReturnArgs} args - Arguments to create many FacultyQualifications.
     * @example
     * // Create many FacultyQualifications
     * const facultyQualification = await prisma.facultyQualification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacultyQualifications and only return the `QualificationID`
     * const facultyQualificationWithQualificationIDOnly = await prisma.facultyQualification.createManyAndReturn({
     *   select: { QualificationID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacultyQualificationCreateManyAndReturnArgs>(args?: SelectSubset<T, FacultyQualificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacultyQualification.
     * @param {FacultyQualificationDeleteArgs} args - Arguments to delete one FacultyQualification.
     * @example
     * // Delete one FacultyQualification
     * const FacultyQualification = await prisma.facultyQualification.delete({
     *   where: {
     *     // ... filter to delete one FacultyQualification
     *   }
     * })
     * 
     */
    delete<T extends FacultyQualificationDeleteArgs>(args: SelectSubset<T, FacultyQualificationDeleteArgs<ExtArgs>>): Prisma__FacultyQualificationClient<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacultyQualification.
     * @param {FacultyQualificationUpdateArgs} args - Arguments to update one FacultyQualification.
     * @example
     * // Update one FacultyQualification
     * const facultyQualification = await prisma.facultyQualification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacultyQualificationUpdateArgs>(args: SelectSubset<T, FacultyQualificationUpdateArgs<ExtArgs>>): Prisma__FacultyQualificationClient<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacultyQualifications.
     * @param {FacultyQualificationDeleteManyArgs} args - Arguments to filter FacultyQualifications to delete.
     * @example
     * // Delete a few FacultyQualifications
     * const { count } = await prisma.facultyQualification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacultyQualificationDeleteManyArgs>(args?: SelectSubset<T, FacultyQualificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacultyQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyQualificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacultyQualifications
     * const facultyQualification = await prisma.facultyQualification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacultyQualificationUpdateManyArgs>(args: SelectSubset<T, FacultyQualificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacultyQualifications and returns the data updated in the database.
     * @param {FacultyQualificationUpdateManyAndReturnArgs} args - Arguments to update many FacultyQualifications.
     * @example
     * // Update many FacultyQualifications
     * const facultyQualification = await prisma.facultyQualification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacultyQualifications and only return the `QualificationID`
     * const facultyQualificationWithQualificationIDOnly = await prisma.facultyQualification.updateManyAndReturn({
     *   select: { QualificationID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacultyQualificationUpdateManyAndReturnArgs>(args: SelectSubset<T, FacultyQualificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacultyQualification.
     * @param {FacultyQualificationUpsertArgs} args - Arguments to update or create a FacultyQualification.
     * @example
     * // Update or create a FacultyQualification
     * const facultyQualification = await prisma.facultyQualification.upsert({
     *   create: {
     *     // ... data to create a FacultyQualification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacultyQualification we want to update
     *   }
     * })
     */
    upsert<T extends FacultyQualificationUpsertArgs>(args: SelectSubset<T, FacultyQualificationUpsertArgs<ExtArgs>>): Prisma__FacultyQualificationClient<$Result.GetResult<Prisma.$FacultyQualificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacultyQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyQualificationCountArgs} args - Arguments to filter FacultyQualifications to count.
     * @example
     * // Count the number of FacultyQualifications
     * const count = await prisma.facultyQualification.count({
     *   where: {
     *     // ... the filter for the FacultyQualifications we want to count
     *   }
     * })
    **/
    count<T extends FacultyQualificationCountArgs>(
      args?: Subset<T, FacultyQualificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyQualificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacultyQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyQualificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyQualificationAggregateArgs>(args: Subset<T, FacultyQualificationAggregateArgs>): Prisma.PrismaPromise<GetFacultyQualificationAggregateType<T>>

    /**
     * Group by FacultyQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyQualificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyQualificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyQualificationGroupByArgs['orderBy'] }
        : { orderBy?: FacultyQualificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyQualificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyQualificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacultyQualification model
   */
  readonly fields: FacultyQualificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacultyQualification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyQualificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacultyQualification model
   */
  interface FacultyQualificationFieldRefs {
    readonly QualificationID: FieldRef<"FacultyQualification", 'Int'>
    readonly FacultyID: FieldRef<"FacultyQualification", 'Int'>
    readonly Degree: FieldRef<"FacultyQualification", 'String'>
    readonly Institution: FieldRef<"FacultyQualification", 'String'>
    readonly YearOfCompletion: FieldRef<"FacultyQualification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacultyQualification findUnique
   */
  export type FacultyQualificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
    /**
     * Filter, which FacultyQualification to fetch.
     */
    where: FacultyQualificationWhereUniqueInput
  }

  /**
   * FacultyQualification findUniqueOrThrow
   */
  export type FacultyQualificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
    /**
     * Filter, which FacultyQualification to fetch.
     */
    where: FacultyQualificationWhereUniqueInput
  }

  /**
   * FacultyQualification findFirst
   */
  export type FacultyQualificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
    /**
     * Filter, which FacultyQualification to fetch.
     */
    where?: FacultyQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyQualifications to fetch.
     */
    orderBy?: FacultyQualificationOrderByWithRelationInput | FacultyQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacultyQualifications.
     */
    cursor?: FacultyQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacultyQualifications.
     */
    distinct?: FacultyQualificationScalarFieldEnum | FacultyQualificationScalarFieldEnum[]
  }

  /**
   * FacultyQualification findFirstOrThrow
   */
  export type FacultyQualificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
    /**
     * Filter, which FacultyQualification to fetch.
     */
    where?: FacultyQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyQualifications to fetch.
     */
    orderBy?: FacultyQualificationOrderByWithRelationInput | FacultyQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacultyQualifications.
     */
    cursor?: FacultyQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacultyQualifications.
     */
    distinct?: FacultyQualificationScalarFieldEnum | FacultyQualificationScalarFieldEnum[]
  }

  /**
   * FacultyQualification findMany
   */
  export type FacultyQualificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
    /**
     * Filter, which FacultyQualifications to fetch.
     */
    where?: FacultyQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyQualifications to fetch.
     */
    orderBy?: FacultyQualificationOrderByWithRelationInput | FacultyQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacultyQualifications.
     */
    cursor?: FacultyQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyQualifications.
     */
    skip?: number
    distinct?: FacultyQualificationScalarFieldEnum | FacultyQualificationScalarFieldEnum[]
  }

  /**
   * FacultyQualification create
   */
  export type FacultyQualificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
    /**
     * The data needed to create a FacultyQualification.
     */
    data: XOR<FacultyQualificationCreateInput, FacultyQualificationUncheckedCreateInput>
  }

  /**
   * FacultyQualification createMany
   */
  export type FacultyQualificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacultyQualifications.
     */
    data: FacultyQualificationCreateManyInput | FacultyQualificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacultyQualification createManyAndReturn
   */
  export type FacultyQualificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * The data used to create many FacultyQualifications.
     */
    data: FacultyQualificationCreateManyInput | FacultyQualificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacultyQualification update
   */
  export type FacultyQualificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
    /**
     * The data needed to update a FacultyQualification.
     */
    data: XOR<FacultyQualificationUpdateInput, FacultyQualificationUncheckedUpdateInput>
    /**
     * Choose, which FacultyQualification to update.
     */
    where: FacultyQualificationWhereUniqueInput
  }

  /**
   * FacultyQualification updateMany
   */
  export type FacultyQualificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacultyQualifications.
     */
    data: XOR<FacultyQualificationUpdateManyMutationInput, FacultyQualificationUncheckedUpdateManyInput>
    /**
     * Filter which FacultyQualifications to update
     */
    where?: FacultyQualificationWhereInput
    /**
     * Limit how many FacultyQualifications to update.
     */
    limit?: number
  }

  /**
   * FacultyQualification updateManyAndReturn
   */
  export type FacultyQualificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * The data used to update FacultyQualifications.
     */
    data: XOR<FacultyQualificationUpdateManyMutationInput, FacultyQualificationUncheckedUpdateManyInput>
    /**
     * Filter which FacultyQualifications to update
     */
    where?: FacultyQualificationWhereInput
    /**
     * Limit how many FacultyQualifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacultyQualification upsert
   */
  export type FacultyQualificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
    /**
     * The filter to search for the FacultyQualification to update in case it exists.
     */
    where: FacultyQualificationWhereUniqueInput
    /**
     * In case the FacultyQualification found by the `where` argument doesn't exist, create a new FacultyQualification with this data.
     */
    create: XOR<FacultyQualificationCreateInput, FacultyQualificationUncheckedCreateInput>
    /**
     * In case the FacultyQualification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyQualificationUpdateInput, FacultyQualificationUncheckedUpdateInput>
  }

  /**
   * FacultyQualification delete
   */
  export type FacultyQualificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
    /**
     * Filter which FacultyQualification to delete.
     */
    where: FacultyQualificationWhereUniqueInput
  }

  /**
   * FacultyQualification deleteMany
   */
  export type FacultyQualificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacultyQualifications to delete
     */
    where?: FacultyQualificationWhereInput
    /**
     * Limit how many FacultyQualifications to delete.
     */
    limit?: number
  }

  /**
   * FacultyQualification without action
   */
  export type FacultyQualificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyQualification
     */
    select?: FacultyQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyQualification
     */
    omit?: FacultyQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyQualificationInclude<ExtArgs> | null
  }


  /**
   * Model OutReachActivities
   */

  export type AggregateOutReachActivities = {
    _count: OutReachActivitiesCountAggregateOutputType | null
    _avg: OutReachActivitiesAvgAggregateOutputType | null
    _sum: OutReachActivitiesSumAggregateOutputType | null
    _min: OutReachActivitiesMinAggregateOutputType | null
    _max: OutReachActivitiesMaxAggregateOutputType | null
  }

  export type OutReachActivitiesAvgAggregateOutputType = {
    ActivityID: number | null
    FacultyID: number | null
  }

  export type OutReachActivitiesSumAggregateOutputType = {
    ActivityID: number | null
    FacultyID: number | null
  }

  export type OutReachActivitiesMinAggregateOutputType = {
    ActivityID: number | null
    FacultyID: number | null
    ActivityType: string | null
    ActivityTitle: string | null
    InstitutionName: string | null
    ActivityDate: Date | null
    Description: string | null
  }

  export type OutReachActivitiesMaxAggregateOutputType = {
    ActivityID: number | null
    FacultyID: number | null
    ActivityType: string | null
    ActivityTitle: string | null
    InstitutionName: string | null
    ActivityDate: Date | null
    Description: string | null
  }

  export type OutReachActivitiesCountAggregateOutputType = {
    ActivityID: number
    FacultyID: number
    ActivityType: number
    ActivityTitle: number
    InstitutionName: number
    ActivityDate: number
    Description: number
    _all: number
  }


  export type OutReachActivitiesAvgAggregateInputType = {
    ActivityID?: true
    FacultyID?: true
  }

  export type OutReachActivitiesSumAggregateInputType = {
    ActivityID?: true
    FacultyID?: true
  }

  export type OutReachActivitiesMinAggregateInputType = {
    ActivityID?: true
    FacultyID?: true
    ActivityType?: true
    ActivityTitle?: true
    InstitutionName?: true
    ActivityDate?: true
    Description?: true
  }

  export type OutReachActivitiesMaxAggregateInputType = {
    ActivityID?: true
    FacultyID?: true
    ActivityType?: true
    ActivityTitle?: true
    InstitutionName?: true
    ActivityDate?: true
    Description?: true
  }

  export type OutReachActivitiesCountAggregateInputType = {
    ActivityID?: true
    FacultyID?: true
    ActivityType?: true
    ActivityTitle?: true
    InstitutionName?: true
    ActivityDate?: true
    Description?: true
    _all?: true
  }

  export type OutReachActivitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutReachActivities to aggregate.
     */
    where?: OutReachActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutReachActivities to fetch.
     */
    orderBy?: OutReachActivitiesOrderByWithRelationInput | OutReachActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutReachActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutReachActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutReachActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutReachActivities
    **/
    _count?: true | OutReachActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutReachActivitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutReachActivitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutReachActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutReachActivitiesMaxAggregateInputType
  }

  export type GetOutReachActivitiesAggregateType<T extends OutReachActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateOutReachActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutReachActivities[P]>
      : GetScalarType<T[P], AggregateOutReachActivities[P]>
  }




  export type OutReachActivitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutReachActivitiesWhereInput
    orderBy?: OutReachActivitiesOrderByWithAggregationInput | OutReachActivitiesOrderByWithAggregationInput[]
    by: OutReachActivitiesScalarFieldEnum[] | OutReachActivitiesScalarFieldEnum
    having?: OutReachActivitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutReachActivitiesCountAggregateInputType | true
    _avg?: OutReachActivitiesAvgAggregateInputType
    _sum?: OutReachActivitiesSumAggregateInputType
    _min?: OutReachActivitiesMinAggregateInputType
    _max?: OutReachActivitiesMaxAggregateInputType
  }

  export type OutReachActivitiesGroupByOutputType = {
    ActivityID: number
    FacultyID: number
    ActivityType: string
    ActivityTitle: string
    InstitutionName: string | null
    ActivityDate: Date
    Description: string | null
    _count: OutReachActivitiesCountAggregateOutputType | null
    _avg: OutReachActivitiesAvgAggregateOutputType | null
    _sum: OutReachActivitiesSumAggregateOutputType | null
    _min: OutReachActivitiesMinAggregateOutputType | null
    _max: OutReachActivitiesMaxAggregateOutputType | null
  }

  type GetOutReachActivitiesGroupByPayload<T extends OutReachActivitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutReachActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutReachActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutReachActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], OutReachActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type OutReachActivitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ActivityID?: boolean
    FacultyID?: boolean
    ActivityType?: boolean
    ActivityTitle?: boolean
    InstitutionName?: boolean
    ActivityDate?: boolean
    Description?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outReachActivities"]>

  export type OutReachActivitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ActivityID?: boolean
    FacultyID?: boolean
    ActivityType?: boolean
    ActivityTitle?: boolean
    InstitutionName?: boolean
    ActivityDate?: boolean
    Description?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outReachActivities"]>

  export type OutReachActivitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ActivityID?: boolean
    FacultyID?: boolean
    ActivityType?: boolean
    ActivityTitle?: boolean
    InstitutionName?: boolean
    ActivityDate?: boolean
    Description?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outReachActivities"]>

  export type OutReachActivitiesSelectScalar = {
    ActivityID?: boolean
    FacultyID?: boolean
    ActivityType?: boolean
    ActivityTitle?: boolean
    InstitutionName?: boolean
    ActivityDate?: boolean
    Description?: boolean
  }

  export type OutReachActivitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ActivityID" | "FacultyID" | "ActivityType" | "ActivityTitle" | "InstitutionName" | "ActivityDate" | "Description", ExtArgs["result"]["outReachActivities"]>
  export type OutReachActivitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type OutReachActivitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type OutReachActivitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $OutReachActivitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutReachActivities"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ActivityID: number
      FacultyID: number
      ActivityType: string
      ActivityTitle: string
      InstitutionName: string | null
      ActivityDate: Date
      Description: string | null
    }, ExtArgs["result"]["outReachActivities"]>
    composites: {}
  }

  type OutReachActivitiesGetPayload<S extends boolean | null | undefined | OutReachActivitiesDefaultArgs> = $Result.GetResult<Prisma.$OutReachActivitiesPayload, S>

  type OutReachActivitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutReachActivitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutReachActivitiesCountAggregateInputType | true
    }

  export interface OutReachActivitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutReachActivities'], meta: { name: 'OutReachActivities' } }
    /**
     * Find zero or one OutReachActivities that matches the filter.
     * @param {OutReachActivitiesFindUniqueArgs} args - Arguments to find a OutReachActivities
     * @example
     * // Get one OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutReachActivitiesFindUniqueArgs>(args: SelectSubset<T, OutReachActivitiesFindUniqueArgs<ExtArgs>>): Prisma__OutReachActivitiesClient<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OutReachActivities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutReachActivitiesFindUniqueOrThrowArgs} args - Arguments to find a OutReachActivities
     * @example
     * // Get one OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutReachActivitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, OutReachActivitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutReachActivitiesClient<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutReachActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutReachActivitiesFindFirstArgs} args - Arguments to find a OutReachActivities
     * @example
     * // Get one OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutReachActivitiesFindFirstArgs>(args?: SelectSubset<T, OutReachActivitiesFindFirstArgs<ExtArgs>>): Prisma__OutReachActivitiesClient<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutReachActivities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutReachActivitiesFindFirstOrThrowArgs} args - Arguments to find a OutReachActivities
     * @example
     * // Get one OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutReachActivitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, OutReachActivitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutReachActivitiesClient<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OutReachActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutReachActivitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.findMany()
     * 
     * // Get first 10 OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.findMany({ take: 10 })
     * 
     * // Only select the `ActivityID`
     * const outReachActivitiesWithActivityIDOnly = await prisma.outReachActivities.findMany({ select: { ActivityID: true } })
     * 
     */
    findMany<T extends OutReachActivitiesFindManyArgs>(args?: SelectSubset<T, OutReachActivitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OutReachActivities.
     * @param {OutReachActivitiesCreateArgs} args - Arguments to create a OutReachActivities.
     * @example
     * // Create one OutReachActivities
     * const OutReachActivities = await prisma.outReachActivities.create({
     *   data: {
     *     // ... data to create a OutReachActivities
     *   }
     * })
     * 
     */
    create<T extends OutReachActivitiesCreateArgs>(args: SelectSubset<T, OutReachActivitiesCreateArgs<ExtArgs>>): Prisma__OutReachActivitiesClient<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OutReachActivities.
     * @param {OutReachActivitiesCreateManyArgs} args - Arguments to create many OutReachActivities.
     * @example
     * // Create many OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutReachActivitiesCreateManyArgs>(args?: SelectSubset<T, OutReachActivitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutReachActivities and returns the data saved in the database.
     * @param {OutReachActivitiesCreateManyAndReturnArgs} args - Arguments to create many OutReachActivities.
     * @example
     * // Create many OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutReachActivities and only return the `ActivityID`
     * const outReachActivitiesWithActivityIDOnly = await prisma.outReachActivities.createManyAndReturn({
     *   select: { ActivityID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutReachActivitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, OutReachActivitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OutReachActivities.
     * @param {OutReachActivitiesDeleteArgs} args - Arguments to delete one OutReachActivities.
     * @example
     * // Delete one OutReachActivities
     * const OutReachActivities = await prisma.outReachActivities.delete({
     *   where: {
     *     // ... filter to delete one OutReachActivities
     *   }
     * })
     * 
     */
    delete<T extends OutReachActivitiesDeleteArgs>(args: SelectSubset<T, OutReachActivitiesDeleteArgs<ExtArgs>>): Prisma__OutReachActivitiesClient<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OutReachActivities.
     * @param {OutReachActivitiesUpdateArgs} args - Arguments to update one OutReachActivities.
     * @example
     * // Update one OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutReachActivitiesUpdateArgs>(args: SelectSubset<T, OutReachActivitiesUpdateArgs<ExtArgs>>): Prisma__OutReachActivitiesClient<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OutReachActivities.
     * @param {OutReachActivitiesDeleteManyArgs} args - Arguments to filter OutReachActivities to delete.
     * @example
     * // Delete a few OutReachActivities
     * const { count } = await prisma.outReachActivities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutReachActivitiesDeleteManyArgs>(args?: SelectSubset<T, OutReachActivitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutReachActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutReachActivitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutReachActivitiesUpdateManyArgs>(args: SelectSubset<T, OutReachActivitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutReachActivities and returns the data updated in the database.
     * @param {OutReachActivitiesUpdateManyAndReturnArgs} args - Arguments to update many OutReachActivities.
     * @example
     * // Update many OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OutReachActivities and only return the `ActivityID`
     * const outReachActivitiesWithActivityIDOnly = await prisma.outReachActivities.updateManyAndReturn({
     *   select: { ActivityID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutReachActivitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, OutReachActivitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OutReachActivities.
     * @param {OutReachActivitiesUpsertArgs} args - Arguments to update or create a OutReachActivities.
     * @example
     * // Update or create a OutReachActivities
     * const outReachActivities = await prisma.outReachActivities.upsert({
     *   create: {
     *     // ... data to create a OutReachActivities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutReachActivities we want to update
     *   }
     * })
     */
    upsert<T extends OutReachActivitiesUpsertArgs>(args: SelectSubset<T, OutReachActivitiesUpsertArgs<ExtArgs>>): Prisma__OutReachActivitiesClient<$Result.GetResult<Prisma.$OutReachActivitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OutReachActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutReachActivitiesCountArgs} args - Arguments to filter OutReachActivities to count.
     * @example
     * // Count the number of OutReachActivities
     * const count = await prisma.outReachActivities.count({
     *   where: {
     *     // ... the filter for the OutReachActivities we want to count
     *   }
     * })
    **/
    count<T extends OutReachActivitiesCountArgs>(
      args?: Subset<T, OutReachActivitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutReachActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutReachActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutReachActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutReachActivitiesAggregateArgs>(args: Subset<T, OutReachActivitiesAggregateArgs>): Prisma.PrismaPromise<GetOutReachActivitiesAggregateType<T>>

    /**
     * Group by OutReachActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutReachActivitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutReachActivitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutReachActivitiesGroupByArgs['orderBy'] }
        : { orderBy?: OutReachActivitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutReachActivitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutReachActivitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutReachActivities model
   */
  readonly fields: OutReachActivitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutReachActivities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutReachActivitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutReachActivities model
   */
  interface OutReachActivitiesFieldRefs {
    readonly ActivityID: FieldRef<"OutReachActivities", 'Int'>
    readonly FacultyID: FieldRef<"OutReachActivities", 'Int'>
    readonly ActivityType: FieldRef<"OutReachActivities", 'String'>
    readonly ActivityTitle: FieldRef<"OutReachActivities", 'String'>
    readonly InstitutionName: FieldRef<"OutReachActivities", 'String'>
    readonly ActivityDate: FieldRef<"OutReachActivities", 'DateTime'>
    readonly Description: FieldRef<"OutReachActivities", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OutReachActivities findUnique
   */
  export type OutReachActivitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
    /**
     * Filter, which OutReachActivities to fetch.
     */
    where: OutReachActivitiesWhereUniqueInput
  }

  /**
   * OutReachActivities findUniqueOrThrow
   */
  export type OutReachActivitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
    /**
     * Filter, which OutReachActivities to fetch.
     */
    where: OutReachActivitiesWhereUniqueInput
  }

  /**
   * OutReachActivities findFirst
   */
  export type OutReachActivitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
    /**
     * Filter, which OutReachActivities to fetch.
     */
    where?: OutReachActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutReachActivities to fetch.
     */
    orderBy?: OutReachActivitiesOrderByWithRelationInput | OutReachActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutReachActivities.
     */
    cursor?: OutReachActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutReachActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutReachActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutReachActivities.
     */
    distinct?: OutReachActivitiesScalarFieldEnum | OutReachActivitiesScalarFieldEnum[]
  }

  /**
   * OutReachActivities findFirstOrThrow
   */
  export type OutReachActivitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
    /**
     * Filter, which OutReachActivities to fetch.
     */
    where?: OutReachActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutReachActivities to fetch.
     */
    orderBy?: OutReachActivitiesOrderByWithRelationInput | OutReachActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutReachActivities.
     */
    cursor?: OutReachActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutReachActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutReachActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutReachActivities.
     */
    distinct?: OutReachActivitiesScalarFieldEnum | OutReachActivitiesScalarFieldEnum[]
  }

  /**
   * OutReachActivities findMany
   */
  export type OutReachActivitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
    /**
     * Filter, which OutReachActivities to fetch.
     */
    where?: OutReachActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutReachActivities to fetch.
     */
    orderBy?: OutReachActivitiesOrderByWithRelationInput | OutReachActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutReachActivities.
     */
    cursor?: OutReachActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutReachActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutReachActivities.
     */
    skip?: number
    distinct?: OutReachActivitiesScalarFieldEnum | OutReachActivitiesScalarFieldEnum[]
  }

  /**
   * OutReachActivities create
   */
  export type OutReachActivitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a OutReachActivities.
     */
    data: XOR<OutReachActivitiesCreateInput, OutReachActivitiesUncheckedCreateInput>
  }

  /**
   * OutReachActivities createMany
   */
  export type OutReachActivitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutReachActivities.
     */
    data: OutReachActivitiesCreateManyInput | OutReachActivitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutReachActivities createManyAndReturn
   */
  export type OutReachActivitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * The data used to create many OutReachActivities.
     */
    data: OutReachActivitiesCreateManyInput | OutReachActivitiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutReachActivities update
   */
  export type OutReachActivitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a OutReachActivities.
     */
    data: XOR<OutReachActivitiesUpdateInput, OutReachActivitiesUncheckedUpdateInput>
    /**
     * Choose, which OutReachActivities to update.
     */
    where: OutReachActivitiesWhereUniqueInput
  }

  /**
   * OutReachActivities updateMany
   */
  export type OutReachActivitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutReachActivities.
     */
    data: XOR<OutReachActivitiesUpdateManyMutationInput, OutReachActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which OutReachActivities to update
     */
    where?: OutReachActivitiesWhereInput
    /**
     * Limit how many OutReachActivities to update.
     */
    limit?: number
  }

  /**
   * OutReachActivities updateManyAndReturn
   */
  export type OutReachActivitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * The data used to update OutReachActivities.
     */
    data: XOR<OutReachActivitiesUpdateManyMutationInput, OutReachActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which OutReachActivities to update
     */
    where?: OutReachActivitiesWhereInput
    /**
     * Limit how many OutReachActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutReachActivities upsert
   */
  export type OutReachActivitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the OutReachActivities to update in case it exists.
     */
    where: OutReachActivitiesWhereUniqueInput
    /**
     * In case the OutReachActivities found by the `where` argument doesn't exist, create a new OutReachActivities with this data.
     */
    create: XOR<OutReachActivitiesCreateInput, OutReachActivitiesUncheckedCreateInput>
    /**
     * In case the OutReachActivities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutReachActivitiesUpdateInput, OutReachActivitiesUncheckedUpdateInput>
  }

  /**
   * OutReachActivities delete
   */
  export type OutReachActivitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
    /**
     * Filter which OutReachActivities to delete.
     */
    where: OutReachActivitiesWhereUniqueInput
  }

  /**
   * OutReachActivities deleteMany
   */
  export type OutReachActivitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutReachActivities to delete
     */
    where?: OutReachActivitiesWhereInput
    /**
     * Limit how many OutReachActivities to delete.
     */
    limit?: number
  }

  /**
   * OutReachActivities without action
   */
  export type OutReachActivitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutReachActivities
     */
    select?: OutReachActivitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutReachActivities
     */
    omit?: OutReachActivitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutReachActivitiesInclude<ExtArgs> | null
  }


  /**
   * Model EventType
   */

  export type AggregateEventType = {
    _count: EventTypeCountAggregateOutputType | null
    _avg: EventTypeAvgAggregateOutputType | null
    _sum: EventTypeSumAggregateOutputType | null
    _min: EventTypeMinAggregateOutputType | null
    _max: EventTypeMaxAggregateOutputType | null
  }

  export type EventTypeAvgAggregateOutputType = {
    EventID: number | null
  }

  export type EventTypeSumAggregateOutputType = {
    EventID: number | null
  }

  export type EventTypeMinAggregateOutputType = {
    EventID: number | null
    EventType: $Enums.event_type | null
  }

  export type EventTypeMaxAggregateOutputType = {
    EventID: number | null
    EventType: $Enums.event_type | null
  }

  export type EventTypeCountAggregateOutputType = {
    EventID: number
    EventType: number
    _all: number
  }


  export type EventTypeAvgAggregateInputType = {
    EventID?: true
  }

  export type EventTypeSumAggregateInputType = {
    EventID?: true
  }

  export type EventTypeMinAggregateInputType = {
    EventID?: true
    EventType?: true
  }

  export type EventTypeMaxAggregateInputType = {
    EventID?: true
    EventType?: true
  }

  export type EventTypeCountAggregateInputType = {
    EventID?: true
    EventType?: true
    _all?: true
  }

  export type EventTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventType to aggregate.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventTypes
    **/
    _count?: true | EventTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventTypeMaxAggregateInputType
  }

  export type GetEventTypeAggregateType<T extends EventTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEventType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventType[P]>
      : GetScalarType<T[P], AggregateEventType[P]>
  }




  export type EventTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTypeWhereInput
    orderBy?: EventTypeOrderByWithAggregationInput | EventTypeOrderByWithAggregationInput[]
    by: EventTypeScalarFieldEnum[] | EventTypeScalarFieldEnum
    having?: EventTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventTypeCountAggregateInputType | true
    _avg?: EventTypeAvgAggregateInputType
    _sum?: EventTypeSumAggregateInputType
    _min?: EventTypeMinAggregateInputType
    _max?: EventTypeMaxAggregateInputType
  }

  export type EventTypeGroupByOutputType = {
    EventID: number
    EventType: $Enums.event_type
    _count: EventTypeCountAggregateOutputType | null
    _avg: EventTypeAvgAggregateOutputType | null
    _sum: EventTypeSumAggregateOutputType | null
    _min: EventTypeMinAggregateOutputType | null
    _max: EventTypeMaxAggregateOutputType | null
  }

  type GetEventTypeGroupByPayload<T extends EventTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EventTypeGroupByOutputType[P]>
        }
      >
    >


  export type EventTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EventID?: boolean
    EventType?: boolean
    EventsOrganised?: boolean | EventType$EventsOrganisedArgs<ExtArgs>
    _count?: boolean | EventTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventType"]>

  export type EventTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EventID?: boolean
    EventType?: boolean
  }, ExtArgs["result"]["eventType"]>

  export type EventTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EventID?: boolean
    EventType?: boolean
  }, ExtArgs["result"]["eventType"]>

  export type EventTypeSelectScalar = {
    EventID?: boolean
    EventType?: boolean
  }

  export type EventTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"EventID" | "EventType", ExtArgs["result"]["eventType"]>
  export type EventTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EventsOrganised?: boolean | EventType$EventsOrganisedArgs<ExtArgs>
    _count?: boolean | EventTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EventTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EventTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventType"
    objects: {
      EventsOrganised: Prisma.$EventsOrganisedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      EventID: number
      EventType: $Enums.event_type
    }, ExtArgs["result"]["eventType"]>
    composites: {}
  }

  type EventTypeGetPayload<S extends boolean | null | undefined | EventTypeDefaultArgs> = $Result.GetResult<Prisma.$EventTypePayload, S>

  type EventTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventTypeCountAggregateInputType | true
    }

  export interface EventTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventType'], meta: { name: 'EventType' } }
    /**
     * Find zero or one EventType that matches the filter.
     * @param {EventTypeFindUniqueArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventTypeFindUniqueArgs>(args: SelectSubset<T, EventTypeFindUniqueArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventTypeFindUniqueOrThrowArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EventTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindFirstArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventTypeFindFirstArgs>(args?: SelectSubset<T, EventTypeFindFirstArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindFirstOrThrowArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EventTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventTypes
     * const eventTypes = await prisma.eventType.findMany()
     * 
     * // Get first 10 EventTypes
     * const eventTypes = await prisma.eventType.findMany({ take: 10 })
     * 
     * // Only select the `EventID`
     * const eventTypeWithEventIDOnly = await prisma.eventType.findMany({ select: { EventID: true } })
     * 
     */
    findMany<T extends EventTypeFindManyArgs>(args?: SelectSubset<T, EventTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventType.
     * @param {EventTypeCreateArgs} args - Arguments to create a EventType.
     * @example
     * // Create one EventType
     * const EventType = await prisma.eventType.create({
     *   data: {
     *     // ... data to create a EventType
     *   }
     * })
     * 
     */
    create<T extends EventTypeCreateArgs>(args: SelectSubset<T, EventTypeCreateArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventTypes.
     * @param {EventTypeCreateManyArgs} args - Arguments to create many EventTypes.
     * @example
     * // Create many EventTypes
     * const eventType = await prisma.eventType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventTypeCreateManyArgs>(args?: SelectSubset<T, EventTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventTypes and returns the data saved in the database.
     * @param {EventTypeCreateManyAndReturnArgs} args - Arguments to create many EventTypes.
     * @example
     * // Create many EventTypes
     * const eventType = await prisma.eventType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventTypes and only return the `EventID`
     * const eventTypeWithEventIDOnly = await prisma.eventType.createManyAndReturn({
     *   select: { EventID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, EventTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventType.
     * @param {EventTypeDeleteArgs} args - Arguments to delete one EventType.
     * @example
     * // Delete one EventType
     * const EventType = await prisma.eventType.delete({
     *   where: {
     *     // ... filter to delete one EventType
     *   }
     * })
     * 
     */
    delete<T extends EventTypeDeleteArgs>(args: SelectSubset<T, EventTypeDeleteArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventType.
     * @param {EventTypeUpdateArgs} args - Arguments to update one EventType.
     * @example
     * // Update one EventType
     * const eventType = await prisma.eventType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventTypeUpdateArgs>(args: SelectSubset<T, EventTypeUpdateArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventTypes.
     * @param {EventTypeDeleteManyArgs} args - Arguments to filter EventTypes to delete.
     * @example
     * // Delete a few EventTypes
     * const { count } = await prisma.eventType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventTypeDeleteManyArgs>(args?: SelectSubset<T, EventTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventTypes
     * const eventType = await prisma.eventType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventTypeUpdateManyArgs>(args: SelectSubset<T, EventTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTypes and returns the data updated in the database.
     * @param {EventTypeUpdateManyAndReturnArgs} args - Arguments to update many EventTypes.
     * @example
     * // Update many EventTypes
     * const eventType = await prisma.eventType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventTypes and only return the `EventID`
     * const eventTypeWithEventIDOnly = await prisma.eventType.updateManyAndReturn({
     *   select: { EventID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, EventTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventType.
     * @param {EventTypeUpsertArgs} args - Arguments to update or create a EventType.
     * @example
     * // Update or create a EventType
     * const eventType = await prisma.eventType.upsert({
     *   create: {
     *     // ... data to create a EventType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventType we want to update
     *   }
     * })
     */
    upsert<T extends EventTypeUpsertArgs>(args: SelectSubset<T, EventTypeUpsertArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeCountArgs} args - Arguments to filter EventTypes to count.
     * @example
     * // Count the number of EventTypes
     * const count = await prisma.eventType.count({
     *   where: {
     *     // ... the filter for the EventTypes we want to count
     *   }
     * })
    **/
    count<T extends EventTypeCountArgs>(
      args?: Subset<T, EventTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventTypeAggregateArgs>(args: Subset<T, EventTypeAggregateArgs>): Prisma.PrismaPromise<GetEventTypeAggregateType<T>>

    /**
     * Group by EventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventTypeGroupByArgs['orderBy'] }
        : { orderBy?: EventTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventType model
   */
  readonly fields: EventTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EventsOrganised<T extends EventType$EventsOrganisedArgs<ExtArgs> = {}>(args?: Subset<T, EventType$EventsOrganisedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventType model
   */
  interface EventTypeFieldRefs {
    readonly EventID: FieldRef<"EventType", 'Int'>
    readonly EventType: FieldRef<"EventType", 'event_type'>
  }
    

  // Custom InputTypes
  /**
   * EventType findUnique
   */
  export type EventTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType findUniqueOrThrow
   */
  export type EventTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType findFirst
   */
  export type EventTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTypes.
     */
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType findFirstOrThrow
   */
  export type EventTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTypes.
     */
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType findMany
   */
  export type EventTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventTypes to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType create
   */
  export type EventTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EventType.
     */
    data: XOR<EventTypeCreateInput, EventTypeUncheckedCreateInput>
  }

  /**
   * EventType createMany
   */
  export type EventTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventTypes.
     */
    data: EventTypeCreateManyInput | EventTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventType createManyAndReturn
   */
  export type EventTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * The data used to create many EventTypes.
     */
    data: EventTypeCreateManyInput | EventTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventType update
   */
  export type EventTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EventType.
     */
    data: XOR<EventTypeUpdateInput, EventTypeUncheckedUpdateInput>
    /**
     * Choose, which EventType to update.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType updateMany
   */
  export type EventTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventTypes.
     */
    data: XOR<EventTypeUpdateManyMutationInput, EventTypeUncheckedUpdateManyInput>
    /**
     * Filter which EventTypes to update
     */
    where?: EventTypeWhereInput
    /**
     * Limit how many EventTypes to update.
     */
    limit?: number
  }

  /**
   * EventType updateManyAndReturn
   */
  export type EventTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * The data used to update EventTypes.
     */
    data: XOR<EventTypeUpdateManyMutationInput, EventTypeUncheckedUpdateManyInput>
    /**
     * Filter which EventTypes to update
     */
    where?: EventTypeWhereInput
    /**
     * Limit how many EventTypes to update.
     */
    limit?: number
  }

  /**
   * EventType upsert
   */
  export type EventTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EventType to update in case it exists.
     */
    where: EventTypeWhereUniqueInput
    /**
     * In case the EventType found by the `where` argument doesn't exist, create a new EventType with this data.
     */
    create: XOR<EventTypeCreateInput, EventTypeUncheckedCreateInput>
    /**
     * In case the EventType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventTypeUpdateInput, EventTypeUncheckedUpdateInput>
  }

  /**
   * EventType delete
   */
  export type EventTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter which EventType to delete.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType deleteMany
   */
  export type EventTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventTypes to delete
     */
    where?: EventTypeWhereInput
    /**
     * Limit how many EventTypes to delete.
     */
    limit?: number
  }

  /**
   * EventType.EventsOrganised
   */
  export type EventType$EventsOrganisedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    where?: EventsOrganisedWhereInput
    orderBy?: EventsOrganisedOrderByWithRelationInput | EventsOrganisedOrderByWithRelationInput[]
    cursor?: EventsOrganisedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsOrganisedScalarFieldEnum | EventsOrganisedScalarFieldEnum[]
  }

  /**
   * EventType without action
   */
  export type EventTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
  }


  /**
   * Model EventsOrganised
   */

  export type AggregateEventsOrganised = {
    _count: EventsOrganisedCountAggregateOutputType | null
    _avg: EventsOrganisedAvgAggregateOutputType | null
    _sum: EventsOrganisedSumAggregateOutputType | null
    _min: EventsOrganisedMinAggregateOutputType | null
    _max: EventsOrganisedMaxAggregateOutputType | null
  }

  export type EventsOrganisedAvgAggregateOutputType = {
    FacultyID: number | null
    Event_id: number | null
  }

  export type EventsOrganisedSumAggregateOutputType = {
    FacultyID: number | null
    Event_id: number | null
  }

  export type EventsOrganisedMinAggregateOutputType = {
    FacultyID: number | null
    Event_id: number | null
    Title: string | null
    Organizer: string | null
    Location: string | null
    StartDate: Date | null
    EndDate: Date | null
    Description: string | null
    Role: $Enums.role_type | null
    FundingAgency: string | null
  }

  export type EventsOrganisedMaxAggregateOutputType = {
    FacultyID: number | null
    Event_id: number | null
    Title: string | null
    Organizer: string | null
    Location: string | null
    StartDate: Date | null
    EndDate: Date | null
    Description: string | null
    Role: $Enums.role_type | null
    FundingAgency: string | null
  }

  export type EventsOrganisedCountAggregateOutputType = {
    FacultyID: number
    Event_id: number
    Title: number
    Organizer: number
    Location: number
    StartDate: number
    EndDate: number
    Description: number
    Role: number
    FundingAgency: number
    _all: number
  }


  export type EventsOrganisedAvgAggregateInputType = {
    FacultyID?: true
    Event_id?: true
  }

  export type EventsOrganisedSumAggregateInputType = {
    FacultyID?: true
    Event_id?: true
  }

  export type EventsOrganisedMinAggregateInputType = {
    FacultyID?: true
    Event_id?: true
    Title?: true
    Organizer?: true
    Location?: true
    StartDate?: true
    EndDate?: true
    Description?: true
    Role?: true
    FundingAgency?: true
  }

  export type EventsOrganisedMaxAggregateInputType = {
    FacultyID?: true
    Event_id?: true
    Title?: true
    Organizer?: true
    Location?: true
    StartDate?: true
    EndDate?: true
    Description?: true
    Role?: true
    FundingAgency?: true
  }

  export type EventsOrganisedCountAggregateInputType = {
    FacultyID?: true
    Event_id?: true
    Title?: true
    Organizer?: true
    Location?: true
    StartDate?: true
    EndDate?: true
    Description?: true
    Role?: true
    FundingAgency?: true
    _all?: true
  }

  export type EventsOrganisedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventsOrganised to aggregate.
     */
    where?: EventsOrganisedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventsOrganiseds to fetch.
     */
    orderBy?: EventsOrganisedOrderByWithRelationInput | EventsOrganisedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventsOrganisedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventsOrganiseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventsOrganiseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventsOrganiseds
    **/
    _count?: true | EventsOrganisedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventsOrganisedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventsOrganisedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsOrganisedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsOrganisedMaxAggregateInputType
  }

  export type GetEventsOrganisedAggregateType<T extends EventsOrganisedAggregateArgs> = {
        [P in keyof T & keyof AggregateEventsOrganised]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventsOrganised[P]>
      : GetScalarType<T[P], AggregateEventsOrganised[P]>
  }




  export type EventsOrganisedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsOrganisedWhereInput
    orderBy?: EventsOrganisedOrderByWithAggregationInput | EventsOrganisedOrderByWithAggregationInput[]
    by: EventsOrganisedScalarFieldEnum[] | EventsOrganisedScalarFieldEnum
    having?: EventsOrganisedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsOrganisedCountAggregateInputType | true
    _avg?: EventsOrganisedAvgAggregateInputType
    _sum?: EventsOrganisedSumAggregateInputType
    _min?: EventsOrganisedMinAggregateInputType
    _max?: EventsOrganisedMaxAggregateInputType
  }

  export type EventsOrganisedGroupByOutputType = {
    FacultyID: number
    Event_id: number
    Title: string
    Organizer: string | null
    Location: string | null
    StartDate: Date | null
    EndDate: Date | null
    Description: string | null
    Role: $Enums.role_type | null
    FundingAgency: string | null
    _count: EventsOrganisedCountAggregateOutputType | null
    _avg: EventsOrganisedAvgAggregateOutputType | null
    _sum: EventsOrganisedSumAggregateOutputType | null
    _min: EventsOrganisedMinAggregateOutputType | null
    _max: EventsOrganisedMaxAggregateOutputType | null
  }

  type GetEventsOrganisedGroupByPayload<T extends EventsOrganisedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventsOrganisedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsOrganisedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsOrganisedGroupByOutputType[P]>
            : GetScalarType<T[P], EventsOrganisedGroupByOutputType[P]>
        }
      >
    >


  export type EventsOrganisedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FacultyID?: boolean
    Event_id?: boolean
    Title?: boolean
    Organizer?: boolean
    Location?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Description?: boolean
    Role?: boolean
    FundingAgency?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Event?: boolean | EventTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventsOrganised"]>

  export type EventsOrganisedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FacultyID?: boolean
    Event_id?: boolean
    Title?: boolean
    Organizer?: boolean
    Location?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Description?: boolean
    Role?: boolean
    FundingAgency?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Event?: boolean | EventTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventsOrganised"]>

  export type EventsOrganisedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FacultyID?: boolean
    Event_id?: boolean
    Title?: boolean
    Organizer?: boolean
    Location?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Description?: boolean
    Role?: boolean
    FundingAgency?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Event?: boolean | EventTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventsOrganised"]>

  export type EventsOrganisedSelectScalar = {
    FacultyID?: boolean
    Event_id?: boolean
    Title?: boolean
    Organizer?: boolean
    Location?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Description?: boolean
    Role?: boolean
    FundingAgency?: boolean
  }

  export type EventsOrganisedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"FacultyID" | "Event_id" | "Title" | "Organizer" | "Location" | "StartDate" | "EndDate" | "Description" | "Role" | "FundingAgency", ExtArgs["result"]["eventsOrganised"]>
  export type EventsOrganisedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Event?: boolean | EventTypeDefaultArgs<ExtArgs>
  }
  export type EventsOrganisedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Event?: boolean | EventTypeDefaultArgs<ExtArgs>
  }
  export type EventsOrganisedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Event?: boolean | EventTypeDefaultArgs<ExtArgs>
  }

  export type $EventsOrganisedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventsOrganised"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>
      Event: Prisma.$EventTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      FacultyID: number
      Event_id: number
      Title: string
      Organizer: string | null
      Location: string | null
      StartDate: Date | null
      EndDate: Date | null
      Description: string | null
      Role: $Enums.role_type | null
      FundingAgency: string | null
    }, ExtArgs["result"]["eventsOrganised"]>
    composites: {}
  }

  type EventsOrganisedGetPayload<S extends boolean | null | undefined | EventsOrganisedDefaultArgs> = $Result.GetResult<Prisma.$EventsOrganisedPayload, S>

  type EventsOrganisedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventsOrganisedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventsOrganisedCountAggregateInputType | true
    }

  export interface EventsOrganisedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventsOrganised'], meta: { name: 'EventsOrganised' } }
    /**
     * Find zero or one EventsOrganised that matches the filter.
     * @param {EventsOrganisedFindUniqueArgs} args - Arguments to find a EventsOrganised
     * @example
     * // Get one EventsOrganised
     * const eventsOrganised = await prisma.eventsOrganised.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventsOrganisedFindUniqueArgs>(args: SelectSubset<T, EventsOrganisedFindUniqueArgs<ExtArgs>>): Prisma__EventsOrganisedClient<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventsOrganised that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventsOrganisedFindUniqueOrThrowArgs} args - Arguments to find a EventsOrganised
     * @example
     * // Get one EventsOrganised
     * const eventsOrganised = await prisma.eventsOrganised.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventsOrganisedFindUniqueOrThrowArgs>(args: SelectSubset<T, EventsOrganisedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventsOrganisedClient<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventsOrganised that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOrganisedFindFirstArgs} args - Arguments to find a EventsOrganised
     * @example
     * // Get one EventsOrganised
     * const eventsOrganised = await prisma.eventsOrganised.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventsOrganisedFindFirstArgs>(args?: SelectSubset<T, EventsOrganisedFindFirstArgs<ExtArgs>>): Prisma__EventsOrganisedClient<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventsOrganised that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOrganisedFindFirstOrThrowArgs} args - Arguments to find a EventsOrganised
     * @example
     * // Get one EventsOrganised
     * const eventsOrganised = await prisma.eventsOrganised.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventsOrganisedFindFirstOrThrowArgs>(args?: SelectSubset<T, EventsOrganisedFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventsOrganisedClient<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventsOrganiseds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOrganisedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventsOrganiseds
     * const eventsOrganiseds = await prisma.eventsOrganised.findMany()
     * 
     * // Get first 10 EventsOrganiseds
     * const eventsOrganiseds = await prisma.eventsOrganised.findMany({ take: 10 })
     * 
     * // Only select the `FacultyID`
     * const eventsOrganisedWithFacultyIDOnly = await prisma.eventsOrganised.findMany({ select: { FacultyID: true } })
     * 
     */
    findMany<T extends EventsOrganisedFindManyArgs>(args?: SelectSubset<T, EventsOrganisedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventsOrganised.
     * @param {EventsOrganisedCreateArgs} args - Arguments to create a EventsOrganised.
     * @example
     * // Create one EventsOrganised
     * const EventsOrganised = await prisma.eventsOrganised.create({
     *   data: {
     *     // ... data to create a EventsOrganised
     *   }
     * })
     * 
     */
    create<T extends EventsOrganisedCreateArgs>(args: SelectSubset<T, EventsOrganisedCreateArgs<ExtArgs>>): Prisma__EventsOrganisedClient<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventsOrganiseds.
     * @param {EventsOrganisedCreateManyArgs} args - Arguments to create many EventsOrganiseds.
     * @example
     * // Create many EventsOrganiseds
     * const eventsOrganised = await prisma.eventsOrganised.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventsOrganisedCreateManyArgs>(args?: SelectSubset<T, EventsOrganisedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventsOrganiseds and returns the data saved in the database.
     * @param {EventsOrganisedCreateManyAndReturnArgs} args - Arguments to create many EventsOrganiseds.
     * @example
     * // Create many EventsOrganiseds
     * const eventsOrganised = await prisma.eventsOrganised.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventsOrganiseds and only return the `FacultyID`
     * const eventsOrganisedWithFacultyIDOnly = await prisma.eventsOrganised.createManyAndReturn({
     *   select: { FacultyID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventsOrganisedCreateManyAndReturnArgs>(args?: SelectSubset<T, EventsOrganisedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventsOrganised.
     * @param {EventsOrganisedDeleteArgs} args - Arguments to delete one EventsOrganised.
     * @example
     * // Delete one EventsOrganised
     * const EventsOrganised = await prisma.eventsOrganised.delete({
     *   where: {
     *     // ... filter to delete one EventsOrganised
     *   }
     * })
     * 
     */
    delete<T extends EventsOrganisedDeleteArgs>(args: SelectSubset<T, EventsOrganisedDeleteArgs<ExtArgs>>): Prisma__EventsOrganisedClient<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventsOrganised.
     * @param {EventsOrganisedUpdateArgs} args - Arguments to update one EventsOrganised.
     * @example
     * // Update one EventsOrganised
     * const eventsOrganised = await prisma.eventsOrganised.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventsOrganisedUpdateArgs>(args: SelectSubset<T, EventsOrganisedUpdateArgs<ExtArgs>>): Prisma__EventsOrganisedClient<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventsOrganiseds.
     * @param {EventsOrganisedDeleteManyArgs} args - Arguments to filter EventsOrganiseds to delete.
     * @example
     * // Delete a few EventsOrganiseds
     * const { count } = await prisma.eventsOrganised.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventsOrganisedDeleteManyArgs>(args?: SelectSubset<T, EventsOrganisedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventsOrganiseds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOrganisedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventsOrganiseds
     * const eventsOrganised = await prisma.eventsOrganised.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventsOrganisedUpdateManyArgs>(args: SelectSubset<T, EventsOrganisedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventsOrganiseds and returns the data updated in the database.
     * @param {EventsOrganisedUpdateManyAndReturnArgs} args - Arguments to update many EventsOrganiseds.
     * @example
     * // Update many EventsOrganiseds
     * const eventsOrganised = await prisma.eventsOrganised.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventsOrganiseds and only return the `FacultyID`
     * const eventsOrganisedWithFacultyIDOnly = await prisma.eventsOrganised.updateManyAndReturn({
     *   select: { FacultyID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventsOrganisedUpdateManyAndReturnArgs>(args: SelectSubset<T, EventsOrganisedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventsOrganised.
     * @param {EventsOrganisedUpsertArgs} args - Arguments to update or create a EventsOrganised.
     * @example
     * // Update or create a EventsOrganised
     * const eventsOrganised = await prisma.eventsOrganised.upsert({
     *   create: {
     *     // ... data to create a EventsOrganised
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventsOrganised we want to update
     *   }
     * })
     */
    upsert<T extends EventsOrganisedUpsertArgs>(args: SelectSubset<T, EventsOrganisedUpsertArgs<ExtArgs>>): Prisma__EventsOrganisedClient<$Result.GetResult<Prisma.$EventsOrganisedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventsOrganiseds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOrganisedCountArgs} args - Arguments to filter EventsOrganiseds to count.
     * @example
     * // Count the number of EventsOrganiseds
     * const count = await prisma.eventsOrganised.count({
     *   where: {
     *     // ... the filter for the EventsOrganiseds we want to count
     *   }
     * })
    **/
    count<T extends EventsOrganisedCountArgs>(
      args?: Subset<T, EventsOrganisedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsOrganisedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventsOrganised.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOrganisedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsOrganisedAggregateArgs>(args: Subset<T, EventsOrganisedAggregateArgs>): Prisma.PrismaPromise<GetEventsOrganisedAggregateType<T>>

    /**
     * Group by EventsOrganised.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOrganisedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsOrganisedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsOrganisedGroupByArgs['orderBy'] }
        : { orderBy?: EventsOrganisedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsOrganisedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsOrganisedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventsOrganised model
   */
  readonly fields: EventsOrganisedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventsOrganised.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventsOrganisedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Event<T extends EventTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventTypeDefaultArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventsOrganised model
   */
  interface EventsOrganisedFieldRefs {
    readonly FacultyID: FieldRef<"EventsOrganised", 'Int'>
    readonly Event_id: FieldRef<"EventsOrganised", 'Int'>
    readonly Title: FieldRef<"EventsOrganised", 'String'>
    readonly Organizer: FieldRef<"EventsOrganised", 'String'>
    readonly Location: FieldRef<"EventsOrganised", 'String'>
    readonly StartDate: FieldRef<"EventsOrganised", 'DateTime'>
    readonly EndDate: FieldRef<"EventsOrganised", 'DateTime'>
    readonly Description: FieldRef<"EventsOrganised", 'String'>
    readonly Role: FieldRef<"EventsOrganised", 'role_type'>
    readonly FundingAgency: FieldRef<"EventsOrganised", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EventsOrganised findUnique
   */
  export type EventsOrganisedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    /**
     * Filter, which EventsOrganised to fetch.
     */
    where: EventsOrganisedWhereUniqueInput
  }

  /**
   * EventsOrganised findUniqueOrThrow
   */
  export type EventsOrganisedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    /**
     * Filter, which EventsOrganised to fetch.
     */
    where: EventsOrganisedWhereUniqueInput
  }

  /**
   * EventsOrganised findFirst
   */
  export type EventsOrganisedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    /**
     * Filter, which EventsOrganised to fetch.
     */
    where?: EventsOrganisedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventsOrganiseds to fetch.
     */
    orderBy?: EventsOrganisedOrderByWithRelationInput | EventsOrganisedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventsOrganiseds.
     */
    cursor?: EventsOrganisedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventsOrganiseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventsOrganiseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventsOrganiseds.
     */
    distinct?: EventsOrganisedScalarFieldEnum | EventsOrganisedScalarFieldEnum[]
  }

  /**
   * EventsOrganised findFirstOrThrow
   */
  export type EventsOrganisedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    /**
     * Filter, which EventsOrganised to fetch.
     */
    where?: EventsOrganisedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventsOrganiseds to fetch.
     */
    orderBy?: EventsOrganisedOrderByWithRelationInput | EventsOrganisedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventsOrganiseds.
     */
    cursor?: EventsOrganisedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventsOrganiseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventsOrganiseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventsOrganiseds.
     */
    distinct?: EventsOrganisedScalarFieldEnum | EventsOrganisedScalarFieldEnum[]
  }

  /**
   * EventsOrganised findMany
   */
  export type EventsOrganisedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    /**
     * Filter, which EventsOrganiseds to fetch.
     */
    where?: EventsOrganisedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventsOrganiseds to fetch.
     */
    orderBy?: EventsOrganisedOrderByWithRelationInput | EventsOrganisedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventsOrganiseds.
     */
    cursor?: EventsOrganisedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventsOrganiseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventsOrganiseds.
     */
    skip?: number
    distinct?: EventsOrganisedScalarFieldEnum | EventsOrganisedScalarFieldEnum[]
  }

  /**
   * EventsOrganised create
   */
  export type EventsOrganisedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    /**
     * The data needed to create a EventsOrganised.
     */
    data: XOR<EventsOrganisedCreateInput, EventsOrganisedUncheckedCreateInput>
  }

  /**
   * EventsOrganised createMany
   */
  export type EventsOrganisedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventsOrganiseds.
     */
    data: EventsOrganisedCreateManyInput | EventsOrganisedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventsOrganised createManyAndReturn
   */
  export type EventsOrganisedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * The data used to create many EventsOrganiseds.
     */
    data: EventsOrganisedCreateManyInput | EventsOrganisedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventsOrganised update
   */
  export type EventsOrganisedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    /**
     * The data needed to update a EventsOrganised.
     */
    data: XOR<EventsOrganisedUpdateInput, EventsOrganisedUncheckedUpdateInput>
    /**
     * Choose, which EventsOrganised to update.
     */
    where: EventsOrganisedWhereUniqueInput
  }

  /**
   * EventsOrganised updateMany
   */
  export type EventsOrganisedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventsOrganiseds.
     */
    data: XOR<EventsOrganisedUpdateManyMutationInput, EventsOrganisedUncheckedUpdateManyInput>
    /**
     * Filter which EventsOrganiseds to update
     */
    where?: EventsOrganisedWhereInput
    /**
     * Limit how many EventsOrganiseds to update.
     */
    limit?: number
  }

  /**
   * EventsOrganised updateManyAndReturn
   */
  export type EventsOrganisedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * The data used to update EventsOrganiseds.
     */
    data: XOR<EventsOrganisedUpdateManyMutationInput, EventsOrganisedUncheckedUpdateManyInput>
    /**
     * Filter which EventsOrganiseds to update
     */
    where?: EventsOrganisedWhereInput
    /**
     * Limit how many EventsOrganiseds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventsOrganised upsert
   */
  export type EventsOrganisedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    /**
     * The filter to search for the EventsOrganised to update in case it exists.
     */
    where: EventsOrganisedWhereUniqueInput
    /**
     * In case the EventsOrganised found by the `where` argument doesn't exist, create a new EventsOrganised with this data.
     */
    create: XOR<EventsOrganisedCreateInput, EventsOrganisedUncheckedCreateInput>
    /**
     * In case the EventsOrganised was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventsOrganisedUpdateInput, EventsOrganisedUncheckedUpdateInput>
  }

  /**
   * EventsOrganised delete
   */
  export type EventsOrganisedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
    /**
     * Filter which EventsOrganised to delete.
     */
    where: EventsOrganisedWhereUniqueInput
  }

  /**
   * EventsOrganised deleteMany
   */
  export type EventsOrganisedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventsOrganiseds to delete
     */
    where?: EventsOrganisedWhereInput
    /**
     * Limit how many EventsOrganiseds to delete.
     */
    limit?: number
  }

  /**
   * EventsOrganised without action
   */
  export type EventsOrganisedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsOrganised
     */
    select?: EventsOrganisedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventsOrganised
     */
    omit?: EventsOrganisedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsOrganisedInclude<ExtArgs> | null
  }


  /**
   * Model Awards
   */

  export type AggregateAwards = {
    _count: AwardsCountAggregateOutputType | null
    _avg: AwardsAvgAggregateOutputType | null
    _sum: AwardsSumAggregateOutputType | null
    _min: AwardsMinAggregateOutputType | null
    _max: AwardsMaxAggregateOutputType | null
  }

  export type AwardsAvgAggregateOutputType = {
    AwardID: number | null
    FacultyID: number | null
    YearAwarded: number | null
  }

  export type AwardsSumAggregateOutputType = {
    AwardID: number | null
    FacultyID: number | null
    YearAwarded: number | null
  }

  export type AwardsMinAggregateOutputType = {
    AwardID: number | null
    FacultyID: number | null
    AwardName: string | null
    AwardingBody: string | null
    Location: string | null
    YearAwarded: number | null
  }

  export type AwardsMaxAggregateOutputType = {
    AwardID: number | null
    FacultyID: number | null
    AwardName: string | null
    AwardingBody: string | null
    Location: string | null
    YearAwarded: number | null
  }

  export type AwardsCountAggregateOutputType = {
    AwardID: number
    FacultyID: number
    AwardName: number
    AwardingBody: number
    Location: number
    YearAwarded: number
    _all: number
  }


  export type AwardsAvgAggregateInputType = {
    AwardID?: true
    FacultyID?: true
    YearAwarded?: true
  }

  export type AwardsSumAggregateInputType = {
    AwardID?: true
    FacultyID?: true
    YearAwarded?: true
  }

  export type AwardsMinAggregateInputType = {
    AwardID?: true
    FacultyID?: true
    AwardName?: true
    AwardingBody?: true
    Location?: true
    YearAwarded?: true
  }

  export type AwardsMaxAggregateInputType = {
    AwardID?: true
    FacultyID?: true
    AwardName?: true
    AwardingBody?: true
    Location?: true
    YearAwarded?: true
  }

  export type AwardsCountAggregateInputType = {
    AwardID?: true
    FacultyID?: true
    AwardName?: true
    AwardingBody?: true
    Location?: true
    YearAwarded?: true
    _all?: true
  }

  export type AwardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Awards to aggregate.
     */
    where?: AwardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardsOrderByWithRelationInput | AwardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AwardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Awards
    **/
    _count?: true | AwardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AwardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AwardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AwardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AwardsMaxAggregateInputType
  }

  export type GetAwardsAggregateType<T extends AwardsAggregateArgs> = {
        [P in keyof T & keyof AggregateAwards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAwards[P]>
      : GetScalarType<T[P], AggregateAwards[P]>
  }




  export type AwardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardsWhereInput
    orderBy?: AwardsOrderByWithAggregationInput | AwardsOrderByWithAggregationInput[]
    by: AwardsScalarFieldEnum[] | AwardsScalarFieldEnum
    having?: AwardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AwardsCountAggregateInputType | true
    _avg?: AwardsAvgAggregateInputType
    _sum?: AwardsSumAggregateInputType
    _min?: AwardsMinAggregateInputType
    _max?: AwardsMaxAggregateInputType
  }

  export type AwardsGroupByOutputType = {
    AwardID: number
    FacultyID: number
    AwardName: string
    AwardingBody: string | null
    Location: string | null
    YearAwarded: number
    _count: AwardsCountAggregateOutputType | null
    _avg: AwardsAvgAggregateOutputType | null
    _sum: AwardsSumAggregateOutputType | null
    _min: AwardsMinAggregateOutputType | null
    _max: AwardsMaxAggregateOutputType | null
  }

  type GetAwardsGroupByPayload<T extends AwardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AwardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AwardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AwardsGroupByOutputType[P]>
            : GetScalarType<T[P], AwardsGroupByOutputType[P]>
        }
      >
    >


  export type AwardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AwardID?: boolean
    FacultyID?: boolean
    AwardName?: boolean
    AwardingBody?: boolean
    Location?: boolean
    YearAwarded?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awards"]>

  export type AwardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AwardID?: boolean
    FacultyID?: boolean
    AwardName?: boolean
    AwardingBody?: boolean
    Location?: boolean
    YearAwarded?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awards"]>

  export type AwardsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AwardID?: boolean
    FacultyID?: boolean
    AwardName?: boolean
    AwardingBody?: boolean
    Location?: boolean
    YearAwarded?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awards"]>

  export type AwardsSelectScalar = {
    AwardID?: boolean
    FacultyID?: boolean
    AwardName?: boolean
    AwardingBody?: boolean
    Location?: boolean
    YearAwarded?: boolean
  }

  export type AwardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"AwardID" | "FacultyID" | "AwardName" | "AwardingBody" | "Location" | "YearAwarded", ExtArgs["result"]["awards"]>
  export type AwardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type AwardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type AwardsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $AwardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Awards"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      AwardID: number
      FacultyID: number
      AwardName: string
      AwardingBody: string | null
      Location: string | null
      YearAwarded: number
    }, ExtArgs["result"]["awards"]>
    composites: {}
  }

  type AwardsGetPayload<S extends boolean | null | undefined | AwardsDefaultArgs> = $Result.GetResult<Prisma.$AwardsPayload, S>

  type AwardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AwardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AwardsCountAggregateInputType | true
    }

  export interface AwardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Awards'], meta: { name: 'Awards' } }
    /**
     * Find zero or one Awards that matches the filter.
     * @param {AwardsFindUniqueArgs} args - Arguments to find a Awards
     * @example
     * // Get one Awards
     * const awards = await prisma.awards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AwardsFindUniqueArgs>(args: SelectSubset<T, AwardsFindUniqueArgs<ExtArgs>>): Prisma__AwardsClient<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Awards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AwardsFindUniqueOrThrowArgs} args - Arguments to find a Awards
     * @example
     * // Get one Awards
     * const awards = await prisma.awards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AwardsFindUniqueOrThrowArgs>(args: SelectSubset<T, AwardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AwardsClient<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Awards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardsFindFirstArgs} args - Arguments to find a Awards
     * @example
     * // Get one Awards
     * const awards = await prisma.awards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AwardsFindFirstArgs>(args?: SelectSubset<T, AwardsFindFirstArgs<ExtArgs>>): Prisma__AwardsClient<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Awards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardsFindFirstOrThrowArgs} args - Arguments to find a Awards
     * @example
     * // Get one Awards
     * const awards = await prisma.awards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AwardsFindFirstOrThrowArgs>(args?: SelectSubset<T, AwardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AwardsClient<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Awards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Awards
     * const awards = await prisma.awards.findMany()
     * 
     * // Get first 10 Awards
     * const awards = await prisma.awards.findMany({ take: 10 })
     * 
     * // Only select the `AwardID`
     * const awardsWithAwardIDOnly = await prisma.awards.findMany({ select: { AwardID: true } })
     * 
     */
    findMany<T extends AwardsFindManyArgs>(args?: SelectSubset<T, AwardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Awards.
     * @param {AwardsCreateArgs} args - Arguments to create a Awards.
     * @example
     * // Create one Awards
     * const Awards = await prisma.awards.create({
     *   data: {
     *     // ... data to create a Awards
     *   }
     * })
     * 
     */
    create<T extends AwardsCreateArgs>(args: SelectSubset<T, AwardsCreateArgs<ExtArgs>>): Prisma__AwardsClient<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Awards.
     * @param {AwardsCreateManyArgs} args - Arguments to create many Awards.
     * @example
     * // Create many Awards
     * const awards = await prisma.awards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AwardsCreateManyArgs>(args?: SelectSubset<T, AwardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Awards and returns the data saved in the database.
     * @param {AwardsCreateManyAndReturnArgs} args - Arguments to create many Awards.
     * @example
     * // Create many Awards
     * const awards = await prisma.awards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Awards and only return the `AwardID`
     * const awardsWithAwardIDOnly = await prisma.awards.createManyAndReturn({
     *   select: { AwardID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AwardsCreateManyAndReturnArgs>(args?: SelectSubset<T, AwardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Awards.
     * @param {AwardsDeleteArgs} args - Arguments to delete one Awards.
     * @example
     * // Delete one Awards
     * const Awards = await prisma.awards.delete({
     *   where: {
     *     // ... filter to delete one Awards
     *   }
     * })
     * 
     */
    delete<T extends AwardsDeleteArgs>(args: SelectSubset<T, AwardsDeleteArgs<ExtArgs>>): Prisma__AwardsClient<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Awards.
     * @param {AwardsUpdateArgs} args - Arguments to update one Awards.
     * @example
     * // Update one Awards
     * const awards = await prisma.awards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AwardsUpdateArgs>(args: SelectSubset<T, AwardsUpdateArgs<ExtArgs>>): Prisma__AwardsClient<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Awards.
     * @param {AwardsDeleteManyArgs} args - Arguments to filter Awards to delete.
     * @example
     * // Delete a few Awards
     * const { count } = await prisma.awards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AwardsDeleteManyArgs>(args?: SelectSubset<T, AwardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Awards
     * const awards = await prisma.awards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AwardsUpdateManyArgs>(args: SelectSubset<T, AwardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Awards and returns the data updated in the database.
     * @param {AwardsUpdateManyAndReturnArgs} args - Arguments to update many Awards.
     * @example
     * // Update many Awards
     * const awards = await prisma.awards.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Awards and only return the `AwardID`
     * const awardsWithAwardIDOnly = await prisma.awards.updateManyAndReturn({
     *   select: { AwardID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AwardsUpdateManyAndReturnArgs>(args: SelectSubset<T, AwardsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Awards.
     * @param {AwardsUpsertArgs} args - Arguments to update or create a Awards.
     * @example
     * // Update or create a Awards
     * const awards = await prisma.awards.upsert({
     *   create: {
     *     // ... data to create a Awards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Awards we want to update
     *   }
     * })
     */
    upsert<T extends AwardsUpsertArgs>(args: SelectSubset<T, AwardsUpsertArgs<ExtArgs>>): Prisma__AwardsClient<$Result.GetResult<Prisma.$AwardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardsCountArgs} args - Arguments to filter Awards to count.
     * @example
     * // Count the number of Awards
     * const count = await prisma.awards.count({
     *   where: {
     *     // ... the filter for the Awards we want to count
     *   }
     * })
    **/
    count<T extends AwardsCountArgs>(
      args?: Subset<T, AwardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AwardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AwardsAggregateArgs>(args: Subset<T, AwardsAggregateArgs>): Prisma.PrismaPromise<GetAwardsAggregateType<T>>

    /**
     * Group by Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AwardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AwardsGroupByArgs['orderBy'] }
        : { orderBy?: AwardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AwardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAwardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Awards model
   */
  readonly fields: AwardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Awards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AwardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Awards model
   */
  interface AwardsFieldRefs {
    readonly AwardID: FieldRef<"Awards", 'Int'>
    readonly FacultyID: FieldRef<"Awards", 'Int'>
    readonly AwardName: FieldRef<"Awards", 'String'>
    readonly AwardingBody: FieldRef<"Awards", 'String'>
    readonly Location: FieldRef<"Awards", 'String'>
    readonly YearAwarded: FieldRef<"Awards", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Awards findUnique
   */
  export type AwardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
    /**
     * Filter, which Awards to fetch.
     */
    where: AwardsWhereUniqueInput
  }

  /**
   * Awards findUniqueOrThrow
   */
  export type AwardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
    /**
     * Filter, which Awards to fetch.
     */
    where: AwardsWhereUniqueInput
  }

  /**
   * Awards findFirst
   */
  export type AwardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
    /**
     * Filter, which Awards to fetch.
     */
    where?: AwardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardsOrderByWithRelationInput | AwardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Awards.
     */
    cursor?: AwardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Awards.
     */
    distinct?: AwardsScalarFieldEnum | AwardsScalarFieldEnum[]
  }

  /**
   * Awards findFirstOrThrow
   */
  export type AwardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
    /**
     * Filter, which Awards to fetch.
     */
    where?: AwardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardsOrderByWithRelationInput | AwardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Awards.
     */
    cursor?: AwardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Awards.
     */
    distinct?: AwardsScalarFieldEnum | AwardsScalarFieldEnum[]
  }

  /**
   * Awards findMany
   */
  export type AwardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
    /**
     * Filter, which Awards to fetch.
     */
    where?: AwardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardsOrderByWithRelationInput | AwardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Awards.
     */
    cursor?: AwardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    distinct?: AwardsScalarFieldEnum | AwardsScalarFieldEnum[]
  }

  /**
   * Awards create
   */
  export type AwardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
    /**
     * The data needed to create a Awards.
     */
    data: XOR<AwardsCreateInput, AwardsUncheckedCreateInput>
  }

  /**
   * Awards createMany
   */
  export type AwardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Awards.
     */
    data: AwardsCreateManyInput | AwardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Awards createManyAndReturn
   */
  export type AwardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * The data used to create many Awards.
     */
    data: AwardsCreateManyInput | AwardsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Awards update
   */
  export type AwardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
    /**
     * The data needed to update a Awards.
     */
    data: XOR<AwardsUpdateInput, AwardsUncheckedUpdateInput>
    /**
     * Choose, which Awards to update.
     */
    where: AwardsWhereUniqueInput
  }

  /**
   * Awards updateMany
   */
  export type AwardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Awards.
     */
    data: XOR<AwardsUpdateManyMutationInput, AwardsUncheckedUpdateManyInput>
    /**
     * Filter which Awards to update
     */
    where?: AwardsWhereInput
    /**
     * Limit how many Awards to update.
     */
    limit?: number
  }

  /**
   * Awards updateManyAndReturn
   */
  export type AwardsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * The data used to update Awards.
     */
    data: XOR<AwardsUpdateManyMutationInput, AwardsUncheckedUpdateManyInput>
    /**
     * Filter which Awards to update
     */
    where?: AwardsWhereInput
    /**
     * Limit how many Awards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Awards upsert
   */
  export type AwardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
    /**
     * The filter to search for the Awards to update in case it exists.
     */
    where: AwardsWhereUniqueInput
    /**
     * In case the Awards found by the `where` argument doesn't exist, create a new Awards with this data.
     */
    create: XOR<AwardsCreateInput, AwardsUncheckedCreateInput>
    /**
     * In case the Awards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AwardsUpdateInput, AwardsUncheckedUpdateInput>
  }

  /**
   * Awards delete
   */
  export type AwardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
    /**
     * Filter which Awards to delete.
     */
    where: AwardsWhereUniqueInput
  }

  /**
   * Awards deleteMany
   */
  export type AwardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Awards to delete
     */
    where?: AwardsWhereInput
    /**
     * Limit how many Awards to delete.
     */
    limit?: number
  }

  /**
   * Awards without action
   */
  export type AwardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Awards
     */
    select?: AwardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Awards
     */
    omit?: AwardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardsInclude<ExtArgs> | null
  }


  /**
   * Model TeachingExperience
   */

  export type AggregateTeachingExperience = {
    _count: TeachingExperienceCountAggregateOutputType | null
    _avg: TeachingExperienceAvgAggregateOutputType | null
    _sum: TeachingExperienceSumAggregateOutputType | null
    _min: TeachingExperienceMinAggregateOutputType | null
    _max: TeachingExperienceMaxAggregateOutputType | null
  }

  export type TeachingExperienceAvgAggregateOutputType = {
    ExperienceID: number | null
    FacultyID: number | null
  }

  export type TeachingExperienceSumAggregateOutputType = {
    ExperienceID: number | null
    FacultyID: number | null
  }

  export type TeachingExperienceMinAggregateOutputType = {
    ExperienceID: number | null
    FacultyID: number | null
    OrganizationName: string | null
    Designation: string | null
    StartDate: Date | null
    EndDate: string | null
    NatureOfWork: string | null
  }

  export type TeachingExperienceMaxAggregateOutputType = {
    ExperienceID: number | null
    FacultyID: number | null
    OrganizationName: string | null
    Designation: string | null
    StartDate: Date | null
    EndDate: string | null
    NatureOfWork: string | null
  }

  export type TeachingExperienceCountAggregateOutputType = {
    ExperienceID: number
    FacultyID: number
    OrganizationName: number
    Designation: number
    StartDate: number
    EndDate: number
    NatureOfWork: number
    _all: number
  }


  export type TeachingExperienceAvgAggregateInputType = {
    ExperienceID?: true
    FacultyID?: true
  }

  export type TeachingExperienceSumAggregateInputType = {
    ExperienceID?: true
    FacultyID?: true
  }

  export type TeachingExperienceMinAggregateInputType = {
    ExperienceID?: true
    FacultyID?: true
    OrganizationName?: true
    Designation?: true
    StartDate?: true
    EndDate?: true
    NatureOfWork?: true
  }

  export type TeachingExperienceMaxAggregateInputType = {
    ExperienceID?: true
    FacultyID?: true
    OrganizationName?: true
    Designation?: true
    StartDate?: true
    EndDate?: true
    NatureOfWork?: true
  }

  export type TeachingExperienceCountAggregateInputType = {
    ExperienceID?: true
    FacultyID?: true
    OrganizationName?: true
    Designation?: true
    StartDate?: true
    EndDate?: true
    NatureOfWork?: true
    _all?: true
  }

  export type TeachingExperienceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeachingExperience to aggregate.
     */
    where?: TeachingExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingExperiences to fetch.
     */
    orderBy?: TeachingExperienceOrderByWithRelationInput | TeachingExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeachingExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeachingExperiences
    **/
    _count?: true | TeachingExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeachingExperienceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeachingExperienceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachingExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachingExperienceMaxAggregateInputType
  }

  export type GetTeachingExperienceAggregateType<T extends TeachingExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachingExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachingExperience[P]>
      : GetScalarType<T[P], AggregateTeachingExperience[P]>
  }




  export type TeachingExperienceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingExperienceWhereInput
    orderBy?: TeachingExperienceOrderByWithAggregationInput | TeachingExperienceOrderByWithAggregationInput[]
    by: TeachingExperienceScalarFieldEnum[] | TeachingExperienceScalarFieldEnum
    having?: TeachingExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachingExperienceCountAggregateInputType | true
    _avg?: TeachingExperienceAvgAggregateInputType
    _sum?: TeachingExperienceSumAggregateInputType
    _min?: TeachingExperienceMinAggregateInputType
    _max?: TeachingExperienceMaxAggregateInputType
  }

  export type TeachingExperienceGroupByOutputType = {
    ExperienceID: number
    FacultyID: number
    OrganizationName: string
    Designation: string
    StartDate: Date
    EndDate: string | null
    NatureOfWork: string | null
    _count: TeachingExperienceCountAggregateOutputType | null
    _avg: TeachingExperienceAvgAggregateOutputType | null
    _sum: TeachingExperienceSumAggregateOutputType | null
    _min: TeachingExperienceMinAggregateOutputType | null
    _max: TeachingExperienceMaxAggregateOutputType | null
  }

  type GetTeachingExperienceGroupByPayload<T extends TeachingExperienceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeachingExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachingExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachingExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], TeachingExperienceGroupByOutputType[P]>
        }
      >
    >


  export type TeachingExperienceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ExperienceID?: boolean
    FacultyID?: boolean
    OrganizationName?: boolean
    Designation?: boolean
    StartDate?: boolean
    EndDate?: boolean
    NatureOfWork?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachingExperience"]>

  export type TeachingExperienceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ExperienceID?: boolean
    FacultyID?: boolean
    OrganizationName?: boolean
    Designation?: boolean
    StartDate?: boolean
    EndDate?: boolean
    NatureOfWork?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachingExperience"]>

  export type TeachingExperienceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ExperienceID?: boolean
    FacultyID?: boolean
    OrganizationName?: boolean
    Designation?: boolean
    StartDate?: boolean
    EndDate?: boolean
    NatureOfWork?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachingExperience"]>

  export type TeachingExperienceSelectScalar = {
    ExperienceID?: boolean
    FacultyID?: boolean
    OrganizationName?: boolean
    Designation?: boolean
    StartDate?: boolean
    EndDate?: boolean
    NatureOfWork?: boolean
  }

  export type TeachingExperienceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ExperienceID" | "FacultyID" | "OrganizationName" | "Designation" | "StartDate" | "EndDate" | "NatureOfWork", ExtArgs["result"]["teachingExperience"]>
  export type TeachingExperienceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type TeachingExperienceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type TeachingExperienceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $TeachingExperiencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeachingExperience"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ExperienceID: number
      FacultyID: number
      OrganizationName: string
      Designation: string
      StartDate: Date
      EndDate: string | null
      NatureOfWork: string | null
    }, ExtArgs["result"]["teachingExperience"]>
    composites: {}
  }

  type TeachingExperienceGetPayload<S extends boolean | null | undefined | TeachingExperienceDefaultArgs> = $Result.GetResult<Prisma.$TeachingExperiencePayload, S>

  type TeachingExperienceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeachingExperienceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeachingExperienceCountAggregateInputType | true
    }

  export interface TeachingExperienceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeachingExperience'], meta: { name: 'TeachingExperience' } }
    /**
     * Find zero or one TeachingExperience that matches the filter.
     * @param {TeachingExperienceFindUniqueArgs} args - Arguments to find a TeachingExperience
     * @example
     * // Get one TeachingExperience
     * const teachingExperience = await prisma.teachingExperience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeachingExperienceFindUniqueArgs>(args: SelectSubset<T, TeachingExperienceFindUniqueArgs<ExtArgs>>): Prisma__TeachingExperienceClient<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeachingExperience that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeachingExperienceFindUniqueOrThrowArgs} args - Arguments to find a TeachingExperience
     * @example
     * // Get one TeachingExperience
     * const teachingExperience = await prisma.teachingExperience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeachingExperienceFindUniqueOrThrowArgs>(args: SelectSubset<T, TeachingExperienceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeachingExperienceClient<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeachingExperience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingExperienceFindFirstArgs} args - Arguments to find a TeachingExperience
     * @example
     * // Get one TeachingExperience
     * const teachingExperience = await prisma.teachingExperience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeachingExperienceFindFirstArgs>(args?: SelectSubset<T, TeachingExperienceFindFirstArgs<ExtArgs>>): Prisma__TeachingExperienceClient<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeachingExperience that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingExperienceFindFirstOrThrowArgs} args - Arguments to find a TeachingExperience
     * @example
     * // Get one TeachingExperience
     * const teachingExperience = await prisma.teachingExperience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeachingExperienceFindFirstOrThrowArgs>(args?: SelectSubset<T, TeachingExperienceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeachingExperienceClient<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeachingExperiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingExperienceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeachingExperiences
     * const teachingExperiences = await prisma.teachingExperience.findMany()
     * 
     * // Get first 10 TeachingExperiences
     * const teachingExperiences = await prisma.teachingExperience.findMany({ take: 10 })
     * 
     * // Only select the `ExperienceID`
     * const teachingExperienceWithExperienceIDOnly = await prisma.teachingExperience.findMany({ select: { ExperienceID: true } })
     * 
     */
    findMany<T extends TeachingExperienceFindManyArgs>(args?: SelectSubset<T, TeachingExperienceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeachingExperience.
     * @param {TeachingExperienceCreateArgs} args - Arguments to create a TeachingExperience.
     * @example
     * // Create one TeachingExperience
     * const TeachingExperience = await prisma.teachingExperience.create({
     *   data: {
     *     // ... data to create a TeachingExperience
     *   }
     * })
     * 
     */
    create<T extends TeachingExperienceCreateArgs>(args: SelectSubset<T, TeachingExperienceCreateArgs<ExtArgs>>): Prisma__TeachingExperienceClient<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeachingExperiences.
     * @param {TeachingExperienceCreateManyArgs} args - Arguments to create many TeachingExperiences.
     * @example
     * // Create many TeachingExperiences
     * const teachingExperience = await prisma.teachingExperience.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeachingExperienceCreateManyArgs>(args?: SelectSubset<T, TeachingExperienceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeachingExperiences and returns the data saved in the database.
     * @param {TeachingExperienceCreateManyAndReturnArgs} args - Arguments to create many TeachingExperiences.
     * @example
     * // Create many TeachingExperiences
     * const teachingExperience = await prisma.teachingExperience.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeachingExperiences and only return the `ExperienceID`
     * const teachingExperienceWithExperienceIDOnly = await prisma.teachingExperience.createManyAndReturn({
     *   select: { ExperienceID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeachingExperienceCreateManyAndReturnArgs>(args?: SelectSubset<T, TeachingExperienceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeachingExperience.
     * @param {TeachingExperienceDeleteArgs} args - Arguments to delete one TeachingExperience.
     * @example
     * // Delete one TeachingExperience
     * const TeachingExperience = await prisma.teachingExperience.delete({
     *   where: {
     *     // ... filter to delete one TeachingExperience
     *   }
     * })
     * 
     */
    delete<T extends TeachingExperienceDeleteArgs>(args: SelectSubset<T, TeachingExperienceDeleteArgs<ExtArgs>>): Prisma__TeachingExperienceClient<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeachingExperience.
     * @param {TeachingExperienceUpdateArgs} args - Arguments to update one TeachingExperience.
     * @example
     * // Update one TeachingExperience
     * const teachingExperience = await prisma.teachingExperience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeachingExperienceUpdateArgs>(args: SelectSubset<T, TeachingExperienceUpdateArgs<ExtArgs>>): Prisma__TeachingExperienceClient<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeachingExperiences.
     * @param {TeachingExperienceDeleteManyArgs} args - Arguments to filter TeachingExperiences to delete.
     * @example
     * // Delete a few TeachingExperiences
     * const { count } = await prisma.teachingExperience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeachingExperienceDeleteManyArgs>(args?: SelectSubset<T, TeachingExperienceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeachingExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeachingExperiences
     * const teachingExperience = await prisma.teachingExperience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeachingExperienceUpdateManyArgs>(args: SelectSubset<T, TeachingExperienceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeachingExperiences and returns the data updated in the database.
     * @param {TeachingExperienceUpdateManyAndReturnArgs} args - Arguments to update many TeachingExperiences.
     * @example
     * // Update many TeachingExperiences
     * const teachingExperience = await prisma.teachingExperience.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeachingExperiences and only return the `ExperienceID`
     * const teachingExperienceWithExperienceIDOnly = await prisma.teachingExperience.updateManyAndReturn({
     *   select: { ExperienceID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeachingExperienceUpdateManyAndReturnArgs>(args: SelectSubset<T, TeachingExperienceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeachingExperience.
     * @param {TeachingExperienceUpsertArgs} args - Arguments to update or create a TeachingExperience.
     * @example
     * // Update or create a TeachingExperience
     * const teachingExperience = await prisma.teachingExperience.upsert({
     *   create: {
     *     // ... data to create a TeachingExperience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeachingExperience we want to update
     *   }
     * })
     */
    upsert<T extends TeachingExperienceUpsertArgs>(args: SelectSubset<T, TeachingExperienceUpsertArgs<ExtArgs>>): Prisma__TeachingExperienceClient<$Result.GetResult<Prisma.$TeachingExperiencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeachingExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingExperienceCountArgs} args - Arguments to filter TeachingExperiences to count.
     * @example
     * // Count the number of TeachingExperiences
     * const count = await prisma.teachingExperience.count({
     *   where: {
     *     // ... the filter for the TeachingExperiences we want to count
     *   }
     * })
    **/
    count<T extends TeachingExperienceCountArgs>(
      args?: Subset<T, TeachingExperienceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachingExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeachingExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachingExperienceAggregateArgs>(args: Subset<T, TeachingExperienceAggregateArgs>): Prisma.PrismaPromise<GetTeachingExperienceAggregateType<T>>

    /**
     * Group by TeachingExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeachingExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeachingExperienceGroupByArgs['orderBy'] }
        : { orderBy?: TeachingExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeachingExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachingExperienceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeachingExperience model
   */
  readonly fields: TeachingExperienceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeachingExperience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeachingExperienceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeachingExperience model
   */
  interface TeachingExperienceFieldRefs {
    readonly ExperienceID: FieldRef<"TeachingExperience", 'Int'>
    readonly FacultyID: FieldRef<"TeachingExperience", 'Int'>
    readonly OrganizationName: FieldRef<"TeachingExperience", 'String'>
    readonly Designation: FieldRef<"TeachingExperience", 'String'>
    readonly StartDate: FieldRef<"TeachingExperience", 'DateTime'>
    readonly EndDate: FieldRef<"TeachingExperience", 'String'>
    readonly NatureOfWork: FieldRef<"TeachingExperience", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeachingExperience findUnique
   */
  export type TeachingExperienceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
    /**
     * Filter, which TeachingExperience to fetch.
     */
    where: TeachingExperienceWhereUniqueInput
  }

  /**
   * TeachingExperience findUniqueOrThrow
   */
  export type TeachingExperienceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
    /**
     * Filter, which TeachingExperience to fetch.
     */
    where: TeachingExperienceWhereUniqueInput
  }

  /**
   * TeachingExperience findFirst
   */
  export type TeachingExperienceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
    /**
     * Filter, which TeachingExperience to fetch.
     */
    where?: TeachingExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingExperiences to fetch.
     */
    orderBy?: TeachingExperienceOrderByWithRelationInput | TeachingExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeachingExperiences.
     */
    cursor?: TeachingExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeachingExperiences.
     */
    distinct?: TeachingExperienceScalarFieldEnum | TeachingExperienceScalarFieldEnum[]
  }

  /**
   * TeachingExperience findFirstOrThrow
   */
  export type TeachingExperienceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
    /**
     * Filter, which TeachingExperience to fetch.
     */
    where?: TeachingExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingExperiences to fetch.
     */
    orderBy?: TeachingExperienceOrderByWithRelationInput | TeachingExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeachingExperiences.
     */
    cursor?: TeachingExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeachingExperiences.
     */
    distinct?: TeachingExperienceScalarFieldEnum | TeachingExperienceScalarFieldEnum[]
  }

  /**
   * TeachingExperience findMany
   */
  export type TeachingExperienceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
    /**
     * Filter, which TeachingExperiences to fetch.
     */
    where?: TeachingExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingExperiences to fetch.
     */
    orderBy?: TeachingExperienceOrderByWithRelationInput | TeachingExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeachingExperiences.
     */
    cursor?: TeachingExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingExperiences.
     */
    skip?: number
    distinct?: TeachingExperienceScalarFieldEnum | TeachingExperienceScalarFieldEnum[]
  }

  /**
   * TeachingExperience create
   */
  export type TeachingExperienceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
    /**
     * The data needed to create a TeachingExperience.
     */
    data: XOR<TeachingExperienceCreateInput, TeachingExperienceUncheckedCreateInput>
  }

  /**
   * TeachingExperience createMany
   */
  export type TeachingExperienceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeachingExperiences.
     */
    data: TeachingExperienceCreateManyInput | TeachingExperienceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeachingExperience createManyAndReturn
   */
  export type TeachingExperienceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * The data used to create many TeachingExperiences.
     */
    data: TeachingExperienceCreateManyInput | TeachingExperienceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeachingExperience update
   */
  export type TeachingExperienceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
    /**
     * The data needed to update a TeachingExperience.
     */
    data: XOR<TeachingExperienceUpdateInput, TeachingExperienceUncheckedUpdateInput>
    /**
     * Choose, which TeachingExperience to update.
     */
    where: TeachingExperienceWhereUniqueInput
  }

  /**
   * TeachingExperience updateMany
   */
  export type TeachingExperienceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeachingExperiences.
     */
    data: XOR<TeachingExperienceUpdateManyMutationInput, TeachingExperienceUncheckedUpdateManyInput>
    /**
     * Filter which TeachingExperiences to update
     */
    where?: TeachingExperienceWhereInput
    /**
     * Limit how many TeachingExperiences to update.
     */
    limit?: number
  }

  /**
   * TeachingExperience updateManyAndReturn
   */
  export type TeachingExperienceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * The data used to update TeachingExperiences.
     */
    data: XOR<TeachingExperienceUpdateManyMutationInput, TeachingExperienceUncheckedUpdateManyInput>
    /**
     * Filter which TeachingExperiences to update
     */
    where?: TeachingExperienceWhereInput
    /**
     * Limit how many TeachingExperiences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeachingExperience upsert
   */
  export type TeachingExperienceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
    /**
     * The filter to search for the TeachingExperience to update in case it exists.
     */
    where: TeachingExperienceWhereUniqueInput
    /**
     * In case the TeachingExperience found by the `where` argument doesn't exist, create a new TeachingExperience with this data.
     */
    create: XOR<TeachingExperienceCreateInput, TeachingExperienceUncheckedCreateInput>
    /**
     * In case the TeachingExperience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeachingExperienceUpdateInput, TeachingExperienceUncheckedUpdateInput>
  }

  /**
   * TeachingExperience delete
   */
  export type TeachingExperienceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
    /**
     * Filter which TeachingExperience to delete.
     */
    where: TeachingExperienceWhereUniqueInput
  }

  /**
   * TeachingExperience deleteMany
   */
  export type TeachingExperienceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeachingExperiences to delete
     */
    where?: TeachingExperienceWhereInput
    /**
     * Limit how many TeachingExperiences to delete.
     */
    limit?: number
  }

  /**
   * TeachingExperience without action
   */
  export type TeachingExperienceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingExperience
     */
    select?: TeachingExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingExperience
     */
    omit?: TeachingExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingExperienceInclude<ExtArgs> | null
  }


  /**
   * Model CitationMetrics
   */

  export type AggregateCitationMetrics = {
    _count: CitationMetricsCountAggregateOutputType | null
    _avg: CitationMetricsAvgAggregateOutputType | null
    _sum: CitationMetricsSumAggregateOutputType | null
    _min: CitationMetricsMinAggregateOutputType | null
    _max: CitationMetricsMaxAggregateOutputType | null
  }

  export type CitationMetricsAvgAggregateOutputType = {
    MetricsID: number | null
    FacultyID: number | null
    YearRecorded: number | null
    HIndex: number | null
    I10Index: number | null
    TotalCitations: number | null
    ImpactFactor: Decimal | null
  }

  export type CitationMetricsSumAggregateOutputType = {
    MetricsID: number | null
    FacultyID: number | null
    YearRecorded: number | null
    HIndex: number | null
    I10Index: number | null
    TotalCitations: number | null
    ImpactFactor: Decimal | null
  }

  export type CitationMetricsMinAggregateOutputType = {
    MetricsID: number | null
    FacultyID: number | null
    YearRecorded: number | null
    Source: string | null
    HIndex: number | null
    I10Index: number | null
    TotalCitations: number | null
    ImpactFactor: Decimal | null
  }

  export type CitationMetricsMaxAggregateOutputType = {
    MetricsID: number | null
    FacultyID: number | null
    YearRecorded: number | null
    Source: string | null
    HIndex: number | null
    I10Index: number | null
    TotalCitations: number | null
    ImpactFactor: Decimal | null
  }

  export type CitationMetricsCountAggregateOutputType = {
    MetricsID: number
    FacultyID: number
    YearRecorded: number
    Source: number
    HIndex: number
    I10Index: number
    TotalCitations: number
    ImpactFactor: number
    _all: number
  }


  export type CitationMetricsAvgAggregateInputType = {
    MetricsID?: true
    FacultyID?: true
    YearRecorded?: true
    HIndex?: true
    I10Index?: true
    TotalCitations?: true
    ImpactFactor?: true
  }

  export type CitationMetricsSumAggregateInputType = {
    MetricsID?: true
    FacultyID?: true
    YearRecorded?: true
    HIndex?: true
    I10Index?: true
    TotalCitations?: true
    ImpactFactor?: true
  }

  export type CitationMetricsMinAggregateInputType = {
    MetricsID?: true
    FacultyID?: true
    YearRecorded?: true
    Source?: true
    HIndex?: true
    I10Index?: true
    TotalCitations?: true
    ImpactFactor?: true
  }

  export type CitationMetricsMaxAggregateInputType = {
    MetricsID?: true
    FacultyID?: true
    YearRecorded?: true
    Source?: true
    HIndex?: true
    I10Index?: true
    TotalCitations?: true
    ImpactFactor?: true
  }

  export type CitationMetricsCountAggregateInputType = {
    MetricsID?: true
    FacultyID?: true
    YearRecorded?: true
    Source?: true
    HIndex?: true
    I10Index?: true
    TotalCitations?: true
    ImpactFactor?: true
    _all?: true
  }

  export type CitationMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CitationMetrics to aggregate.
     */
    where?: CitationMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitationMetrics to fetch.
     */
    orderBy?: CitationMetricsOrderByWithRelationInput | CitationMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CitationMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitationMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitationMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CitationMetrics
    **/
    _count?: true | CitationMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CitationMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitationMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitationMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitationMetricsMaxAggregateInputType
  }

  export type GetCitationMetricsAggregateType<T extends CitationMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateCitationMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCitationMetrics[P]>
      : GetScalarType<T[P], AggregateCitationMetrics[P]>
  }




  export type CitationMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitationMetricsWhereInput
    orderBy?: CitationMetricsOrderByWithAggregationInput | CitationMetricsOrderByWithAggregationInput[]
    by: CitationMetricsScalarFieldEnum[] | CitationMetricsScalarFieldEnum
    having?: CitationMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitationMetricsCountAggregateInputType | true
    _avg?: CitationMetricsAvgAggregateInputType
    _sum?: CitationMetricsSumAggregateInputType
    _min?: CitationMetricsMinAggregateInputType
    _max?: CitationMetricsMaxAggregateInputType
  }

  export type CitationMetricsGroupByOutputType = {
    MetricsID: number
    FacultyID: number
    YearRecorded: number
    Source: string
    HIndex: number | null
    I10Index: number | null
    TotalCitations: number | null
    ImpactFactor: Decimal | null
    _count: CitationMetricsCountAggregateOutputType | null
    _avg: CitationMetricsAvgAggregateOutputType | null
    _sum: CitationMetricsSumAggregateOutputType | null
    _min: CitationMetricsMinAggregateOutputType | null
    _max: CitationMetricsMaxAggregateOutputType | null
  }

  type GetCitationMetricsGroupByPayload<T extends CitationMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitationMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitationMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitationMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], CitationMetricsGroupByOutputType[P]>
        }
      >
    >


  export type CitationMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MetricsID?: boolean
    FacultyID?: boolean
    YearRecorded?: boolean
    Source?: boolean
    HIndex?: boolean
    I10Index?: boolean
    TotalCitations?: boolean
    ImpactFactor?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["citationMetrics"]>

  export type CitationMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MetricsID?: boolean
    FacultyID?: boolean
    YearRecorded?: boolean
    Source?: boolean
    HIndex?: boolean
    I10Index?: boolean
    TotalCitations?: boolean
    ImpactFactor?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["citationMetrics"]>

  export type CitationMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MetricsID?: boolean
    FacultyID?: boolean
    YearRecorded?: boolean
    Source?: boolean
    HIndex?: boolean
    I10Index?: boolean
    TotalCitations?: boolean
    ImpactFactor?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["citationMetrics"]>

  export type CitationMetricsSelectScalar = {
    MetricsID?: boolean
    FacultyID?: boolean
    YearRecorded?: boolean
    Source?: boolean
    HIndex?: boolean
    I10Index?: boolean
    TotalCitations?: boolean
    ImpactFactor?: boolean
  }

  export type CitationMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"MetricsID" | "FacultyID" | "YearRecorded" | "Source" | "HIndex" | "I10Index" | "TotalCitations" | "ImpactFactor", ExtArgs["result"]["citationMetrics"]>
  export type CitationMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type CitationMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type CitationMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $CitationMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CitationMetrics"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      MetricsID: number
      FacultyID: number
      YearRecorded: number
      Source: string
      HIndex: number | null
      I10Index: number | null
      TotalCitations: number | null
      ImpactFactor: Prisma.Decimal | null
    }, ExtArgs["result"]["citationMetrics"]>
    composites: {}
  }

  type CitationMetricsGetPayload<S extends boolean | null | undefined | CitationMetricsDefaultArgs> = $Result.GetResult<Prisma.$CitationMetricsPayload, S>

  type CitationMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CitationMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CitationMetricsCountAggregateInputType | true
    }

  export interface CitationMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CitationMetrics'], meta: { name: 'CitationMetrics' } }
    /**
     * Find zero or one CitationMetrics that matches the filter.
     * @param {CitationMetricsFindUniqueArgs} args - Arguments to find a CitationMetrics
     * @example
     * // Get one CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CitationMetricsFindUniqueArgs>(args: SelectSubset<T, CitationMetricsFindUniqueArgs<ExtArgs>>): Prisma__CitationMetricsClient<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CitationMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CitationMetricsFindUniqueOrThrowArgs} args - Arguments to find a CitationMetrics
     * @example
     * // Get one CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CitationMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, CitationMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CitationMetricsClient<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CitationMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationMetricsFindFirstArgs} args - Arguments to find a CitationMetrics
     * @example
     * // Get one CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CitationMetricsFindFirstArgs>(args?: SelectSubset<T, CitationMetricsFindFirstArgs<ExtArgs>>): Prisma__CitationMetricsClient<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CitationMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationMetricsFindFirstOrThrowArgs} args - Arguments to find a CitationMetrics
     * @example
     * // Get one CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CitationMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, CitationMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CitationMetricsClient<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CitationMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.findMany()
     * 
     * // Get first 10 CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.findMany({ take: 10 })
     * 
     * // Only select the `MetricsID`
     * const citationMetricsWithMetricsIDOnly = await prisma.citationMetrics.findMany({ select: { MetricsID: true } })
     * 
     */
    findMany<T extends CitationMetricsFindManyArgs>(args?: SelectSubset<T, CitationMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CitationMetrics.
     * @param {CitationMetricsCreateArgs} args - Arguments to create a CitationMetrics.
     * @example
     * // Create one CitationMetrics
     * const CitationMetrics = await prisma.citationMetrics.create({
     *   data: {
     *     // ... data to create a CitationMetrics
     *   }
     * })
     * 
     */
    create<T extends CitationMetricsCreateArgs>(args: SelectSubset<T, CitationMetricsCreateArgs<ExtArgs>>): Prisma__CitationMetricsClient<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CitationMetrics.
     * @param {CitationMetricsCreateManyArgs} args - Arguments to create many CitationMetrics.
     * @example
     * // Create many CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CitationMetricsCreateManyArgs>(args?: SelectSubset<T, CitationMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CitationMetrics and returns the data saved in the database.
     * @param {CitationMetricsCreateManyAndReturnArgs} args - Arguments to create many CitationMetrics.
     * @example
     * // Create many CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CitationMetrics and only return the `MetricsID`
     * const citationMetricsWithMetricsIDOnly = await prisma.citationMetrics.createManyAndReturn({
     *   select: { MetricsID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CitationMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, CitationMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CitationMetrics.
     * @param {CitationMetricsDeleteArgs} args - Arguments to delete one CitationMetrics.
     * @example
     * // Delete one CitationMetrics
     * const CitationMetrics = await prisma.citationMetrics.delete({
     *   where: {
     *     // ... filter to delete one CitationMetrics
     *   }
     * })
     * 
     */
    delete<T extends CitationMetricsDeleteArgs>(args: SelectSubset<T, CitationMetricsDeleteArgs<ExtArgs>>): Prisma__CitationMetricsClient<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CitationMetrics.
     * @param {CitationMetricsUpdateArgs} args - Arguments to update one CitationMetrics.
     * @example
     * // Update one CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CitationMetricsUpdateArgs>(args: SelectSubset<T, CitationMetricsUpdateArgs<ExtArgs>>): Prisma__CitationMetricsClient<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CitationMetrics.
     * @param {CitationMetricsDeleteManyArgs} args - Arguments to filter CitationMetrics to delete.
     * @example
     * // Delete a few CitationMetrics
     * const { count } = await prisma.citationMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CitationMetricsDeleteManyArgs>(args?: SelectSubset<T, CitationMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CitationMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CitationMetricsUpdateManyArgs>(args: SelectSubset<T, CitationMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CitationMetrics and returns the data updated in the database.
     * @param {CitationMetricsUpdateManyAndReturnArgs} args - Arguments to update many CitationMetrics.
     * @example
     * // Update many CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CitationMetrics and only return the `MetricsID`
     * const citationMetricsWithMetricsIDOnly = await prisma.citationMetrics.updateManyAndReturn({
     *   select: { MetricsID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CitationMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, CitationMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CitationMetrics.
     * @param {CitationMetricsUpsertArgs} args - Arguments to update or create a CitationMetrics.
     * @example
     * // Update or create a CitationMetrics
     * const citationMetrics = await prisma.citationMetrics.upsert({
     *   create: {
     *     // ... data to create a CitationMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CitationMetrics we want to update
     *   }
     * })
     */
    upsert<T extends CitationMetricsUpsertArgs>(args: SelectSubset<T, CitationMetricsUpsertArgs<ExtArgs>>): Prisma__CitationMetricsClient<$Result.GetResult<Prisma.$CitationMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CitationMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationMetricsCountArgs} args - Arguments to filter CitationMetrics to count.
     * @example
     * // Count the number of CitationMetrics
     * const count = await prisma.citationMetrics.count({
     *   where: {
     *     // ... the filter for the CitationMetrics we want to count
     *   }
     * })
    **/
    count<T extends CitationMetricsCountArgs>(
      args?: Subset<T, CitationMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitationMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CitationMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitationMetricsAggregateArgs>(args: Subset<T, CitationMetricsAggregateArgs>): Prisma.PrismaPromise<GetCitationMetricsAggregateType<T>>

    /**
     * Group by CitationMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CitationMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CitationMetricsGroupByArgs['orderBy'] }
        : { orderBy?: CitationMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CitationMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitationMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CitationMetrics model
   */
  readonly fields: CitationMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CitationMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CitationMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CitationMetrics model
   */
  interface CitationMetricsFieldRefs {
    readonly MetricsID: FieldRef<"CitationMetrics", 'Int'>
    readonly FacultyID: FieldRef<"CitationMetrics", 'Int'>
    readonly YearRecorded: FieldRef<"CitationMetrics", 'Int'>
    readonly Source: FieldRef<"CitationMetrics", 'String'>
    readonly HIndex: FieldRef<"CitationMetrics", 'Int'>
    readonly I10Index: FieldRef<"CitationMetrics", 'Int'>
    readonly TotalCitations: FieldRef<"CitationMetrics", 'Int'>
    readonly ImpactFactor: FieldRef<"CitationMetrics", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CitationMetrics findUnique
   */
  export type CitationMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CitationMetrics to fetch.
     */
    where: CitationMetricsWhereUniqueInput
  }

  /**
   * CitationMetrics findUniqueOrThrow
   */
  export type CitationMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CitationMetrics to fetch.
     */
    where: CitationMetricsWhereUniqueInput
  }

  /**
   * CitationMetrics findFirst
   */
  export type CitationMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CitationMetrics to fetch.
     */
    where?: CitationMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitationMetrics to fetch.
     */
    orderBy?: CitationMetricsOrderByWithRelationInput | CitationMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CitationMetrics.
     */
    cursor?: CitationMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitationMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitationMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CitationMetrics.
     */
    distinct?: CitationMetricsScalarFieldEnum | CitationMetricsScalarFieldEnum[]
  }

  /**
   * CitationMetrics findFirstOrThrow
   */
  export type CitationMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CitationMetrics to fetch.
     */
    where?: CitationMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitationMetrics to fetch.
     */
    orderBy?: CitationMetricsOrderByWithRelationInput | CitationMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CitationMetrics.
     */
    cursor?: CitationMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitationMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitationMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CitationMetrics.
     */
    distinct?: CitationMetricsScalarFieldEnum | CitationMetricsScalarFieldEnum[]
  }

  /**
   * CitationMetrics findMany
   */
  export type CitationMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CitationMetrics to fetch.
     */
    where?: CitationMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitationMetrics to fetch.
     */
    orderBy?: CitationMetricsOrderByWithRelationInput | CitationMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CitationMetrics.
     */
    cursor?: CitationMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitationMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitationMetrics.
     */
    skip?: number
    distinct?: CitationMetricsScalarFieldEnum | CitationMetricsScalarFieldEnum[]
  }

  /**
   * CitationMetrics create
   */
  export type CitationMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a CitationMetrics.
     */
    data: XOR<CitationMetricsCreateInput, CitationMetricsUncheckedCreateInput>
  }

  /**
   * CitationMetrics createMany
   */
  export type CitationMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CitationMetrics.
     */
    data: CitationMetricsCreateManyInput | CitationMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CitationMetrics createManyAndReturn
   */
  export type CitationMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many CitationMetrics.
     */
    data: CitationMetricsCreateManyInput | CitationMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CitationMetrics update
   */
  export type CitationMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a CitationMetrics.
     */
    data: XOR<CitationMetricsUpdateInput, CitationMetricsUncheckedUpdateInput>
    /**
     * Choose, which CitationMetrics to update.
     */
    where: CitationMetricsWhereUniqueInput
  }

  /**
   * CitationMetrics updateMany
   */
  export type CitationMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CitationMetrics.
     */
    data: XOR<CitationMetricsUpdateManyMutationInput, CitationMetricsUncheckedUpdateManyInput>
    /**
     * Filter which CitationMetrics to update
     */
    where?: CitationMetricsWhereInput
    /**
     * Limit how many CitationMetrics to update.
     */
    limit?: number
  }

  /**
   * CitationMetrics updateManyAndReturn
   */
  export type CitationMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * The data used to update CitationMetrics.
     */
    data: XOR<CitationMetricsUpdateManyMutationInput, CitationMetricsUncheckedUpdateManyInput>
    /**
     * Filter which CitationMetrics to update
     */
    where?: CitationMetricsWhereInput
    /**
     * Limit how many CitationMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CitationMetrics upsert
   */
  export type CitationMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the CitationMetrics to update in case it exists.
     */
    where: CitationMetricsWhereUniqueInput
    /**
     * In case the CitationMetrics found by the `where` argument doesn't exist, create a new CitationMetrics with this data.
     */
    create: XOR<CitationMetricsCreateInput, CitationMetricsUncheckedCreateInput>
    /**
     * In case the CitationMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CitationMetricsUpdateInput, CitationMetricsUncheckedUpdateInput>
  }

  /**
   * CitationMetrics delete
   */
  export type CitationMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
    /**
     * Filter which CitationMetrics to delete.
     */
    where: CitationMetricsWhereUniqueInput
  }

  /**
   * CitationMetrics deleteMany
   */
  export type CitationMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CitationMetrics to delete
     */
    where?: CitationMetricsWhereInput
    /**
     * Limit how many CitationMetrics to delete.
     */
    limit?: number
  }

  /**
   * CitationMetrics without action
   */
  export type CitationMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationMetrics
     */
    select?: CitationMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CitationMetrics
     */
    omit?: CitationMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationMetricsInclude<ExtArgs> | null
  }


  /**
   * Model TYPES
   */

  export type AggregateTYPES = {
    _count: TYPESCountAggregateOutputType | null
    _min: TYPESMinAggregateOutputType | null
    _max: TYPESMaxAggregateOutputType | null
  }

  export type TYPESMinAggregateOutputType = {
    TypeID: string | null
    Type: $Enums.publication_type | null
    Status: string | null
  }

  export type TYPESMaxAggregateOutputType = {
    TypeID: string | null
    Type: $Enums.publication_type | null
    Status: string | null
  }

  export type TYPESCountAggregateOutputType = {
    TypeID: number
    Type: number
    Status: number
    _all: number
  }


  export type TYPESMinAggregateInputType = {
    TypeID?: true
    Type?: true
    Status?: true
  }

  export type TYPESMaxAggregateInputType = {
    TypeID?: true
    Type?: true
    Status?: true
  }

  export type TYPESCountAggregateInputType = {
    TypeID?: true
    Type?: true
    Status?: true
    _all?: true
  }

  export type TYPESAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TYPES to aggregate.
     */
    where?: TYPESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TYPES to fetch.
     */
    orderBy?: TYPESOrderByWithRelationInput | TYPESOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TYPESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TYPES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TYPES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TYPES
    **/
    _count?: true | TYPESCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TYPESMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TYPESMaxAggregateInputType
  }

  export type GetTYPESAggregateType<T extends TYPESAggregateArgs> = {
        [P in keyof T & keyof AggregateTYPES]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTYPES[P]>
      : GetScalarType<T[P], AggregateTYPES[P]>
  }




  export type TYPESGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TYPESWhereInput
    orderBy?: TYPESOrderByWithAggregationInput | TYPESOrderByWithAggregationInput[]
    by: TYPESScalarFieldEnum[] | TYPESScalarFieldEnum
    having?: TYPESScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TYPESCountAggregateInputType | true
    _min?: TYPESMinAggregateInputType
    _max?: TYPESMaxAggregateInputType
  }

  export type TYPESGroupByOutputType = {
    TypeID: string
    Type: $Enums.publication_type
    Status: string | null
    _count: TYPESCountAggregateOutputType | null
    _min: TYPESMinAggregateOutputType | null
    _max: TYPESMaxAggregateOutputType | null
  }

  type GetTYPESGroupByPayload<T extends TYPESGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TYPESGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TYPESGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TYPESGroupByOutputType[P]>
            : GetScalarType<T[P], TYPESGroupByOutputType[P]>
        }
      >
    >


  export type TYPESSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TypeID?: boolean
    Type?: boolean
    Status?: boolean
    Publications?: boolean | TYPES$PublicationsArgs<ExtArgs>
    Patents?: boolean | TYPES$PatentsArgs<ExtArgs>
    ResearchProjects?: boolean | TYPES$ResearchProjectsArgs<ExtArgs>
    _count?: boolean | TYPESCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tYPES"]>

  export type TYPESSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TypeID?: boolean
    Type?: boolean
    Status?: boolean
  }, ExtArgs["result"]["tYPES"]>

  export type TYPESSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TypeID?: boolean
    Type?: boolean
    Status?: boolean
  }, ExtArgs["result"]["tYPES"]>

  export type TYPESSelectScalar = {
    TypeID?: boolean
    Type?: boolean
    Status?: boolean
  }

  export type TYPESOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"TypeID" | "Type" | "Status", ExtArgs["result"]["tYPES"]>
  export type TYPESInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publications?: boolean | TYPES$PublicationsArgs<ExtArgs>
    Patents?: boolean | TYPES$PatentsArgs<ExtArgs>
    ResearchProjects?: boolean | TYPES$ResearchProjectsArgs<ExtArgs>
    _count?: boolean | TYPESCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TYPESIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TYPESIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TYPESPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TYPES"
    objects: {
      Publications: Prisma.$PublicationsPayload<ExtArgs>[]
      Patents: Prisma.$PatentsPayload<ExtArgs>[]
      ResearchProjects: Prisma.$ResearchProjectsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      TypeID: string
      Type: $Enums.publication_type
      Status: string | null
    }, ExtArgs["result"]["tYPES"]>
    composites: {}
  }

  type TYPESGetPayload<S extends boolean | null | undefined | TYPESDefaultArgs> = $Result.GetResult<Prisma.$TYPESPayload, S>

  type TYPESCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TYPESFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TYPESCountAggregateInputType | true
    }

  export interface TYPESDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TYPES'], meta: { name: 'TYPES' } }
    /**
     * Find zero or one TYPES that matches the filter.
     * @param {TYPESFindUniqueArgs} args - Arguments to find a TYPES
     * @example
     * // Get one TYPES
     * const tYPES = await prisma.tYPES.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TYPESFindUniqueArgs>(args: SelectSubset<T, TYPESFindUniqueArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TYPES that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TYPESFindUniqueOrThrowArgs} args - Arguments to find a TYPES
     * @example
     * // Get one TYPES
     * const tYPES = await prisma.tYPES.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TYPESFindUniqueOrThrowArgs>(args: SelectSubset<T, TYPESFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TYPES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TYPESFindFirstArgs} args - Arguments to find a TYPES
     * @example
     * // Get one TYPES
     * const tYPES = await prisma.tYPES.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TYPESFindFirstArgs>(args?: SelectSubset<T, TYPESFindFirstArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TYPES that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TYPESFindFirstOrThrowArgs} args - Arguments to find a TYPES
     * @example
     * // Get one TYPES
     * const tYPES = await prisma.tYPES.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TYPESFindFirstOrThrowArgs>(args?: SelectSubset<T, TYPESFindFirstOrThrowArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TYPES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TYPESFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TYPES
     * const tYPES = await prisma.tYPES.findMany()
     * 
     * // Get first 10 TYPES
     * const tYPES = await prisma.tYPES.findMany({ take: 10 })
     * 
     * // Only select the `TypeID`
     * const tYPESWithTypeIDOnly = await prisma.tYPES.findMany({ select: { TypeID: true } })
     * 
     */
    findMany<T extends TYPESFindManyArgs>(args?: SelectSubset<T, TYPESFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TYPES.
     * @param {TYPESCreateArgs} args - Arguments to create a TYPES.
     * @example
     * // Create one TYPES
     * const TYPES = await prisma.tYPES.create({
     *   data: {
     *     // ... data to create a TYPES
     *   }
     * })
     * 
     */
    create<T extends TYPESCreateArgs>(args: SelectSubset<T, TYPESCreateArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TYPES.
     * @param {TYPESCreateManyArgs} args - Arguments to create many TYPES.
     * @example
     * // Create many TYPES
     * const tYPES = await prisma.tYPES.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TYPESCreateManyArgs>(args?: SelectSubset<T, TYPESCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TYPES and returns the data saved in the database.
     * @param {TYPESCreateManyAndReturnArgs} args - Arguments to create many TYPES.
     * @example
     * // Create many TYPES
     * const tYPES = await prisma.tYPES.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TYPES and only return the `TypeID`
     * const tYPESWithTypeIDOnly = await prisma.tYPES.createManyAndReturn({
     *   select: { TypeID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TYPESCreateManyAndReturnArgs>(args?: SelectSubset<T, TYPESCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TYPES.
     * @param {TYPESDeleteArgs} args - Arguments to delete one TYPES.
     * @example
     * // Delete one TYPES
     * const TYPES = await prisma.tYPES.delete({
     *   where: {
     *     // ... filter to delete one TYPES
     *   }
     * })
     * 
     */
    delete<T extends TYPESDeleteArgs>(args: SelectSubset<T, TYPESDeleteArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TYPES.
     * @param {TYPESUpdateArgs} args - Arguments to update one TYPES.
     * @example
     * // Update one TYPES
     * const tYPES = await prisma.tYPES.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TYPESUpdateArgs>(args: SelectSubset<T, TYPESUpdateArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TYPES.
     * @param {TYPESDeleteManyArgs} args - Arguments to filter TYPES to delete.
     * @example
     * // Delete a few TYPES
     * const { count } = await prisma.tYPES.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TYPESDeleteManyArgs>(args?: SelectSubset<T, TYPESDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TYPES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TYPESUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TYPES
     * const tYPES = await prisma.tYPES.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TYPESUpdateManyArgs>(args: SelectSubset<T, TYPESUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TYPES and returns the data updated in the database.
     * @param {TYPESUpdateManyAndReturnArgs} args - Arguments to update many TYPES.
     * @example
     * // Update many TYPES
     * const tYPES = await prisma.tYPES.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TYPES and only return the `TypeID`
     * const tYPESWithTypeIDOnly = await prisma.tYPES.updateManyAndReturn({
     *   select: { TypeID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TYPESUpdateManyAndReturnArgs>(args: SelectSubset<T, TYPESUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TYPES.
     * @param {TYPESUpsertArgs} args - Arguments to update or create a TYPES.
     * @example
     * // Update or create a TYPES
     * const tYPES = await prisma.tYPES.upsert({
     *   create: {
     *     // ... data to create a TYPES
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TYPES we want to update
     *   }
     * })
     */
    upsert<T extends TYPESUpsertArgs>(args: SelectSubset<T, TYPESUpsertArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TYPES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TYPESCountArgs} args - Arguments to filter TYPES to count.
     * @example
     * // Count the number of TYPES
     * const count = await prisma.tYPES.count({
     *   where: {
     *     // ... the filter for the TYPES we want to count
     *   }
     * })
    **/
    count<T extends TYPESCountArgs>(
      args?: Subset<T, TYPESCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TYPESCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TYPES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TYPESAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TYPESAggregateArgs>(args: Subset<T, TYPESAggregateArgs>): Prisma.PrismaPromise<GetTYPESAggregateType<T>>

    /**
     * Group by TYPES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TYPESGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TYPESGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TYPESGroupByArgs['orderBy'] }
        : { orderBy?: TYPESGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TYPESGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTYPESGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TYPES model
   */
  readonly fields: TYPESFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TYPES.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TYPESClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Publications<T extends TYPES$PublicationsArgs<ExtArgs> = {}>(args?: Subset<T, TYPES$PublicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Patents<T extends TYPES$PatentsArgs<ExtArgs> = {}>(args?: Subset<T, TYPES$PatentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ResearchProjects<T extends TYPES$ResearchProjectsArgs<ExtArgs> = {}>(args?: Subset<T, TYPES$ResearchProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TYPES model
   */
  interface TYPESFieldRefs {
    readonly TypeID: FieldRef<"TYPES", 'String'>
    readonly Type: FieldRef<"TYPES", 'publication_type'>
    readonly Status: FieldRef<"TYPES", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TYPES findUnique
   */
  export type TYPESFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TYPESInclude<ExtArgs> | null
    /**
     * Filter, which TYPES to fetch.
     */
    where: TYPESWhereUniqueInput
  }

  /**
   * TYPES findUniqueOrThrow
   */
  export type TYPESFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TYPESInclude<ExtArgs> | null
    /**
     * Filter, which TYPES to fetch.
     */
    where: TYPESWhereUniqueInput
  }

  /**
   * TYPES findFirst
   */
  export type TYPESFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TYPESInclude<ExtArgs> | null
    /**
     * Filter, which TYPES to fetch.
     */
    where?: TYPESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TYPES to fetch.
     */
    orderBy?: TYPESOrderByWithRelationInput | TYPESOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TYPES.
     */
    cursor?: TYPESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TYPES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TYPES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TYPES.
     */
    distinct?: TYPESScalarFieldEnum | TYPESScalarFieldEnum[]
  }

  /**
   * TYPES findFirstOrThrow
   */
  export type TYPESFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TYPESInclude<ExtArgs> | null
    /**
     * Filter, which TYPES to fetch.
     */
    where?: TYPESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TYPES to fetch.
     */
    orderBy?: TYPESOrderByWithRelationInput | TYPESOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TYPES.
     */
    cursor?: TYPESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TYPES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TYPES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TYPES.
     */
    distinct?: TYPESScalarFieldEnum | TYPESScalarFieldEnum[]
  }

  /**
   * TYPES findMany
   */
  export type TYPESFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TYPESInclude<ExtArgs> | null
    /**
     * Filter, which TYPES to fetch.
     */
    where?: TYPESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TYPES to fetch.
     */
    orderBy?: TYPESOrderByWithRelationInput | TYPESOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TYPES.
     */
    cursor?: TYPESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TYPES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TYPES.
     */
    skip?: number
    distinct?: TYPESScalarFieldEnum | TYPESScalarFieldEnum[]
  }

  /**
   * TYPES create
   */
  export type TYPESCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TYPESInclude<ExtArgs> | null
    /**
     * The data needed to create a TYPES.
     */
    data: XOR<TYPESCreateInput, TYPESUncheckedCreateInput>
  }

  /**
   * TYPES createMany
   */
  export type TYPESCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TYPES.
     */
    data: TYPESCreateManyInput | TYPESCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TYPES createManyAndReturn
   */
  export type TYPESCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * The data used to create many TYPES.
     */
    data: TYPESCreateManyInput | TYPESCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TYPES update
   */
  export type TYPESUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TYPESInclude<ExtArgs> | null
    /**
     * The data needed to update a TYPES.
     */
    data: XOR<TYPESUpdateInput, TYPESUncheckedUpdateInput>
    /**
     * Choose, which TYPES to update.
     */
    where: TYPESWhereUniqueInput
  }

  /**
   * TYPES updateMany
   */
  export type TYPESUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TYPES.
     */
    data: XOR<TYPESUpdateManyMutationInput, TYPESUncheckedUpdateManyInput>
    /**
     * Filter which TYPES to update
     */
    where?: TYPESWhereInput
    /**
     * Limit how many TYPES to update.
     */
    limit?: number
  }

  /**
   * TYPES updateManyAndReturn
   */
  export type TYPESUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * The data used to update TYPES.
     */
    data: XOR<TYPESUpdateManyMutationInput, TYPESUncheckedUpdateManyInput>
    /**
     * Filter which TYPES to update
     */
    where?: TYPESWhereInput
    /**
     * Limit how many TYPES to update.
     */
    limit?: number
  }

  /**
   * TYPES upsert
   */
  export type TYPESUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TYPESInclude<ExtArgs> | null
    /**
     * The filter to search for the TYPES to update in case it exists.
     */
    where: TYPESWhereUniqueInput
    /**
     * In case the TYPES found by the `where` argument doesn't exist, create a new TYPES with this data.
     */
    create: XOR<TYPESCreateInput, TYPESUncheckedCreateInput>
    /**
     * In case the TYPES was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TYPESUpdateInput, TYPESUncheckedUpdateInput>
  }

  /**
   * TYPES delete
   */
  export type TYPESDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TYPESInclude<ExtArgs> | null
    /**
     * Filter which TYPES to delete.
     */
    where: TYPESWhereUniqueInput
  }

  /**
   * TYPES deleteMany
   */
  export type TYPESDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TYPES to delete
     */
    where?: TYPESWhereInput
    /**
     * Limit how many TYPES to delete.
     */
    limit?: number
  }

  /**
   * TYPES.Publications
   */
  export type TYPES$PublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
    where?: PublicationsWhereInput
    orderBy?: PublicationsOrderByWithRelationInput | PublicationsOrderByWithRelationInput[]
    cursor?: PublicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationsScalarFieldEnum | PublicationsScalarFieldEnum[]
  }

  /**
   * TYPES.Patents
   */
  export type TYPES$PatentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    where?: PatentsWhereInput
    orderBy?: PatentsOrderByWithRelationInput | PatentsOrderByWithRelationInput[]
    cursor?: PatentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatentsScalarFieldEnum | PatentsScalarFieldEnum[]
  }

  /**
   * TYPES.ResearchProjects
   */
  export type TYPES$ResearchProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    where?: ResearchProjectsWhereInput
    orderBy?: ResearchProjectsOrderByWithRelationInput | ResearchProjectsOrderByWithRelationInput[]
    cursor?: ResearchProjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchProjectsScalarFieldEnum | ResearchProjectsScalarFieldEnum[]
  }

  /**
   * TYPES without action
   */
  export type TYPESDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TYPES
     */
    select?: TYPESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TYPES
     */
    omit?: TYPESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TYPESInclude<ExtArgs> | null
  }


  /**
   * Model Publications
   */

  export type AggregatePublications = {
    _count: PublicationsCountAggregateOutputType | null
    _avg: PublicationsAvgAggregateOutputType | null
    _sum: PublicationsSumAggregateOutputType | null
    _min: PublicationsMinAggregateOutputType | null
    _max: PublicationsMaxAggregateOutputType | null
  }

  export type PublicationsAvgAggregateOutputType = {
    PublicationID: number | null
  }

  export type PublicationsSumAggregateOutputType = {
    PublicationID: number | null
  }

  export type PublicationsMinAggregateOutputType = {
    PublicationID: number | null
    TypeID: string | null
    Authors: string | null
    Title: string | null
    PublicationYear: Date | null
    FundingAgency: string | null
  }

  export type PublicationsMaxAggregateOutputType = {
    PublicationID: number | null
    TypeID: string | null
    Authors: string | null
    Title: string | null
    PublicationYear: Date | null
    FundingAgency: string | null
  }

  export type PublicationsCountAggregateOutputType = {
    PublicationID: number
    TypeID: number
    Authors: number
    Title: number
    PublicationYear: number
    FundingAgency: number
    _all: number
  }


  export type PublicationsAvgAggregateInputType = {
    PublicationID?: true
  }

  export type PublicationsSumAggregateInputType = {
    PublicationID?: true
  }

  export type PublicationsMinAggregateInputType = {
    PublicationID?: true
    TypeID?: true
    Authors?: true
    Title?: true
    PublicationYear?: true
    FundingAgency?: true
  }

  export type PublicationsMaxAggregateInputType = {
    PublicationID?: true
    TypeID?: true
    Authors?: true
    Title?: true
    PublicationYear?: true
    FundingAgency?: true
  }

  export type PublicationsCountAggregateInputType = {
    PublicationID?: true
    TypeID?: true
    Authors?: true
    Title?: true
    PublicationYear?: true
    FundingAgency?: true
    _all?: true
  }

  export type PublicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publications to aggregate.
     */
    where?: PublicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationsOrderByWithRelationInput | PublicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Publications
    **/
    _count?: true | PublicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublicationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublicationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicationsMaxAggregateInputType
  }

  export type GetPublicationsAggregateType<T extends PublicationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePublications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublications[P]>
      : GetScalarType<T[P], AggregatePublications[P]>
  }




  export type PublicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationsWhereInput
    orderBy?: PublicationsOrderByWithAggregationInput | PublicationsOrderByWithAggregationInput[]
    by: PublicationsScalarFieldEnum[] | PublicationsScalarFieldEnum
    having?: PublicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicationsCountAggregateInputType | true
    _avg?: PublicationsAvgAggregateInputType
    _sum?: PublicationsSumAggregateInputType
    _min?: PublicationsMinAggregateInputType
    _max?: PublicationsMaxAggregateInputType
  }

  export type PublicationsGroupByOutputType = {
    PublicationID: number
    TypeID: string
    Authors: string
    Title: string
    PublicationYear: Date
    FundingAgency: string | null
    _count: PublicationsCountAggregateOutputType | null
    _avg: PublicationsAvgAggregateOutputType | null
    _sum: PublicationsSumAggregateOutputType | null
    _min: PublicationsMinAggregateOutputType | null
    _max: PublicationsMaxAggregateOutputType | null
  }

  type GetPublicationsGroupByPayload<T extends PublicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicationsGroupByOutputType[P]>
            : GetScalarType<T[P], PublicationsGroupByOutputType[P]>
        }
      >
    >


  export type PublicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    TypeID?: boolean
    Authors?: boolean
    Title?: boolean
    PublicationYear?: boolean
    FundingAgency?: boolean
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
    JournalPublicationDetails?: boolean | Publications$JournalPublicationDetailsArgs<ExtArgs>
    BookPublicationDetails?: boolean | Publications$BookPublicationDetailsArgs<ExtArgs>
    ConferencePaperDetails?: boolean | Publications$ConferencePaperDetailsArgs<ExtArgs>
    FacultyPublicationLink?: boolean | Publications$FacultyPublicationLinkArgs<ExtArgs>
    _count?: boolean | PublicationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publications"]>

  export type PublicationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    TypeID?: boolean
    Authors?: boolean
    Title?: boolean
    PublicationYear?: boolean
    FundingAgency?: boolean
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publications"]>

  export type PublicationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    TypeID?: boolean
    Authors?: boolean
    Title?: boolean
    PublicationYear?: boolean
    FundingAgency?: boolean
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publications"]>

  export type PublicationsSelectScalar = {
    PublicationID?: boolean
    TypeID?: boolean
    Authors?: boolean
    Title?: boolean
    PublicationYear?: boolean
    FundingAgency?: boolean
  }

  export type PublicationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"PublicationID" | "TypeID" | "Authors" | "Title" | "PublicationYear" | "FundingAgency", ExtArgs["result"]["publications"]>
  export type PublicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
    JournalPublicationDetails?: boolean | Publications$JournalPublicationDetailsArgs<ExtArgs>
    BookPublicationDetails?: boolean | Publications$BookPublicationDetailsArgs<ExtArgs>
    ConferencePaperDetails?: boolean | Publications$ConferencePaperDetailsArgs<ExtArgs>
    FacultyPublicationLink?: boolean | Publications$FacultyPublicationLinkArgs<ExtArgs>
    _count?: boolean | PublicationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PublicationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }
  export type PublicationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }

  export type $PublicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Publications"
    objects: {
      Type: Prisma.$TYPESPayload<ExtArgs>
      JournalPublicationDetails: Prisma.$JournalPublicationDetailsPayload<ExtArgs> | null
      BookPublicationDetails: Prisma.$BookPublicationDetailsPayload<ExtArgs> | null
      ConferencePaperDetails: Prisma.$ConferencePaperDetailsPayload<ExtArgs> | null
      FacultyPublicationLink: Prisma.$FacultyPublicationLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      PublicationID: number
      TypeID: string
      Authors: string
      Title: string
      PublicationYear: Date
      FundingAgency: string | null
    }, ExtArgs["result"]["publications"]>
    composites: {}
  }

  type PublicationsGetPayload<S extends boolean | null | undefined | PublicationsDefaultArgs> = $Result.GetResult<Prisma.$PublicationsPayload, S>

  type PublicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PublicationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PublicationsCountAggregateInputType | true
    }

  export interface PublicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Publications'], meta: { name: 'Publications' } }
    /**
     * Find zero or one Publications that matches the filter.
     * @param {PublicationsFindUniqueArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicationsFindUniqueArgs>(args: SelectSubset<T, PublicationsFindUniqueArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Publications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PublicationsFindUniqueOrThrowArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationsFindFirstArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicationsFindFirstArgs>(args?: SelectSubset<T, PublicationsFindFirstArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationsFindFirstOrThrowArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publications
     * const publications = await prisma.publications.findMany()
     * 
     * // Get first 10 Publications
     * const publications = await prisma.publications.findMany({ take: 10 })
     * 
     * // Only select the `PublicationID`
     * const publicationsWithPublicationIDOnly = await prisma.publications.findMany({ select: { PublicationID: true } })
     * 
     */
    findMany<T extends PublicationsFindManyArgs>(args?: SelectSubset<T, PublicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Publications.
     * @param {PublicationsCreateArgs} args - Arguments to create a Publications.
     * @example
     * // Create one Publications
     * const Publications = await prisma.publications.create({
     *   data: {
     *     // ... data to create a Publications
     *   }
     * })
     * 
     */
    create<T extends PublicationsCreateArgs>(args: SelectSubset<T, PublicationsCreateArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Publications.
     * @param {PublicationsCreateManyArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publications = await prisma.publications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicationsCreateManyArgs>(args?: SelectSubset<T, PublicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publications and returns the data saved in the database.
     * @param {PublicationsCreateManyAndReturnArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publications = await prisma.publications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publications and only return the `PublicationID`
     * const publicationsWithPublicationIDOnly = await prisma.publications.createManyAndReturn({
     *   select: { PublicationID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PublicationsCreateManyAndReturnArgs>(args?: SelectSubset<T, PublicationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Publications.
     * @param {PublicationsDeleteArgs} args - Arguments to delete one Publications.
     * @example
     * // Delete one Publications
     * const Publications = await prisma.publications.delete({
     *   where: {
     *     // ... filter to delete one Publications
     *   }
     * })
     * 
     */
    delete<T extends PublicationsDeleteArgs>(args: SelectSubset<T, PublicationsDeleteArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Publications.
     * @param {PublicationsUpdateArgs} args - Arguments to update one Publications.
     * @example
     * // Update one Publications
     * const publications = await prisma.publications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicationsUpdateArgs>(args: SelectSubset<T, PublicationsUpdateArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Publications.
     * @param {PublicationsDeleteManyArgs} args - Arguments to filter Publications to delete.
     * @example
     * // Delete a few Publications
     * const { count } = await prisma.publications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicationsDeleteManyArgs>(args?: SelectSubset<T, PublicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publications
     * const publications = await prisma.publications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicationsUpdateManyArgs>(args: SelectSubset<T, PublicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publications and returns the data updated in the database.
     * @param {PublicationsUpdateManyAndReturnArgs} args - Arguments to update many Publications.
     * @example
     * // Update many Publications
     * const publications = await prisma.publications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Publications and only return the `PublicationID`
     * const publicationsWithPublicationIDOnly = await prisma.publications.updateManyAndReturn({
     *   select: { PublicationID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PublicationsUpdateManyAndReturnArgs>(args: SelectSubset<T, PublicationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Publications.
     * @param {PublicationsUpsertArgs} args - Arguments to update or create a Publications.
     * @example
     * // Update or create a Publications
     * const publications = await prisma.publications.upsert({
     *   create: {
     *     // ... data to create a Publications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publications we want to update
     *   }
     * })
     */
    upsert<T extends PublicationsUpsertArgs>(args: SelectSubset<T, PublicationsUpsertArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationsCountArgs} args - Arguments to filter Publications to count.
     * @example
     * // Count the number of Publications
     * const count = await prisma.publications.count({
     *   where: {
     *     // ... the filter for the Publications we want to count
     *   }
     * })
    **/
    count<T extends PublicationsCountArgs>(
      args?: Subset<T, PublicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicationsAggregateArgs>(args: Subset<T, PublicationsAggregateArgs>): Prisma.PrismaPromise<GetPublicationsAggregateType<T>>

    /**
     * Group by Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicationsGroupByArgs['orderBy'] }
        : { orderBy?: PublicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Publications model
   */
  readonly fields: PublicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Publications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Type<T extends TYPESDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TYPESDefaultArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    JournalPublicationDetails<T extends Publications$JournalPublicationDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Publications$JournalPublicationDetailsArgs<ExtArgs>>): Prisma__JournalPublicationDetailsClient<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    BookPublicationDetails<T extends Publications$BookPublicationDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Publications$BookPublicationDetailsArgs<ExtArgs>>): Prisma__BookPublicationDetailsClient<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ConferencePaperDetails<T extends Publications$ConferencePaperDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Publications$ConferencePaperDetailsArgs<ExtArgs>>): Prisma__ConferencePaperDetailsClient<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    FacultyPublicationLink<T extends Publications$FacultyPublicationLinkArgs<ExtArgs> = {}>(args?: Subset<T, Publications$FacultyPublicationLinkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Publications model
   */
  interface PublicationsFieldRefs {
    readonly PublicationID: FieldRef<"Publications", 'Int'>
    readonly TypeID: FieldRef<"Publications", 'String'>
    readonly Authors: FieldRef<"Publications", 'String'>
    readonly Title: FieldRef<"Publications", 'String'>
    readonly PublicationYear: FieldRef<"Publications", 'DateTime'>
    readonly FundingAgency: FieldRef<"Publications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Publications findUnique
   */
  export type PublicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
    /**
     * Filter, which Publications to fetch.
     */
    where: PublicationsWhereUniqueInput
  }

  /**
   * Publications findUniqueOrThrow
   */
  export type PublicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
    /**
     * Filter, which Publications to fetch.
     */
    where: PublicationsWhereUniqueInput
  }

  /**
   * Publications findFirst
   */
  export type PublicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
    /**
     * Filter, which Publications to fetch.
     */
    where?: PublicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationsOrderByWithRelationInput | PublicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationsScalarFieldEnum | PublicationsScalarFieldEnum[]
  }

  /**
   * Publications findFirstOrThrow
   */
  export type PublicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
    /**
     * Filter, which Publications to fetch.
     */
    where?: PublicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationsOrderByWithRelationInput | PublicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationsScalarFieldEnum | PublicationsScalarFieldEnum[]
  }

  /**
   * Publications findMany
   */
  export type PublicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
    /**
     * Filter, which Publications to fetch.
     */
    where?: PublicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationsOrderByWithRelationInput | PublicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Publications.
     */
    cursor?: PublicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    distinct?: PublicationsScalarFieldEnum | PublicationsScalarFieldEnum[]
  }

  /**
   * Publications create
   */
  export type PublicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Publications.
     */
    data: XOR<PublicationsCreateInput, PublicationsUncheckedCreateInput>
  }

  /**
   * Publications createMany
   */
  export type PublicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Publications.
     */
    data: PublicationsCreateManyInput | PublicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Publications createManyAndReturn
   */
  export type PublicationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * The data used to create many Publications.
     */
    data: PublicationsCreateManyInput | PublicationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Publications update
   */
  export type PublicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Publications.
     */
    data: XOR<PublicationsUpdateInput, PublicationsUncheckedUpdateInput>
    /**
     * Choose, which Publications to update.
     */
    where: PublicationsWhereUniqueInput
  }

  /**
   * Publications updateMany
   */
  export type PublicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Publications.
     */
    data: XOR<PublicationsUpdateManyMutationInput, PublicationsUncheckedUpdateManyInput>
    /**
     * Filter which Publications to update
     */
    where?: PublicationsWhereInput
    /**
     * Limit how many Publications to update.
     */
    limit?: number
  }

  /**
   * Publications updateManyAndReturn
   */
  export type PublicationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * The data used to update Publications.
     */
    data: XOR<PublicationsUpdateManyMutationInput, PublicationsUncheckedUpdateManyInput>
    /**
     * Filter which Publications to update
     */
    where?: PublicationsWhereInput
    /**
     * Limit how many Publications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Publications upsert
   */
  export type PublicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Publications to update in case it exists.
     */
    where: PublicationsWhereUniqueInput
    /**
     * In case the Publications found by the `where` argument doesn't exist, create a new Publications with this data.
     */
    create: XOR<PublicationsCreateInput, PublicationsUncheckedCreateInput>
    /**
     * In case the Publications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicationsUpdateInput, PublicationsUncheckedUpdateInput>
  }

  /**
   * Publications delete
   */
  export type PublicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
    /**
     * Filter which Publications to delete.
     */
    where: PublicationsWhereUniqueInput
  }

  /**
   * Publications deleteMany
   */
  export type PublicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publications to delete
     */
    where?: PublicationsWhereInput
    /**
     * Limit how many Publications to delete.
     */
    limit?: number
  }

  /**
   * Publications.JournalPublicationDetails
   */
  export type Publications$JournalPublicationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
    where?: JournalPublicationDetailsWhereInput
  }

  /**
   * Publications.BookPublicationDetails
   */
  export type Publications$BookPublicationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
    where?: BookPublicationDetailsWhereInput
  }

  /**
   * Publications.ConferencePaperDetails
   */
  export type Publications$ConferencePaperDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
    where?: ConferencePaperDetailsWhereInput
  }

  /**
   * Publications.FacultyPublicationLink
   */
  export type Publications$FacultyPublicationLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    where?: FacultyPublicationLinkWhereInput
    orderBy?: FacultyPublicationLinkOrderByWithRelationInput | FacultyPublicationLinkOrderByWithRelationInput[]
    cursor?: FacultyPublicationLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyPublicationLinkScalarFieldEnum | FacultyPublicationLinkScalarFieldEnum[]
  }

  /**
   * Publications without action
   */
  export type PublicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publications
     */
    select?: PublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publications
     */
    omit?: PublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationsInclude<ExtArgs> | null
  }


  /**
   * Model JournalPublicationDetails
   */

  export type AggregateJournalPublicationDetails = {
    _count: JournalPublicationDetailsCountAggregateOutputType | null
    _avg: JournalPublicationDetailsAvgAggregateOutputType | null
    _sum: JournalPublicationDetailsSumAggregateOutputType | null
    _min: JournalPublicationDetailsMinAggregateOutputType | null
    _max: JournalPublicationDetailsMaxAggregateOutputType | null
  }

  export type JournalPublicationDetailsAvgAggregateOutputType = {
    PublicationID: number | null
    ISSN_Number: number | null
  }

  export type JournalPublicationDetailsSumAggregateOutputType = {
    PublicationID: number | null
    ISSN_Number: number | null
  }

  export type JournalPublicationDetailsMinAggregateOutputType = {
    PublicationID: number | null
    Name: string | null
    VolumeNumber: string | null
    IssueNumber: string | null
    ISSN_Number: number | null
  }

  export type JournalPublicationDetailsMaxAggregateOutputType = {
    PublicationID: number | null
    Name: string | null
    VolumeNumber: string | null
    IssueNumber: string | null
    ISSN_Number: number | null
  }

  export type JournalPublicationDetailsCountAggregateOutputType = {
    PublicationID: number
    Name: number
    VolumeNumber: number
    IssueNumber: number
    ISSN_Number: number
    _all: number
  }


  export type JournalPublicationDetailsAvgAggregateInputType = {
    PublicationID?: true
    ISSN_Number?: true
  }

  export type JournalPublicationDetailsSumAggregateInputType = {
    PublicationID?: true
    ISSN_Number?: true
  }

  export type JournalPublicationDetailsMinAggregateInputType = {
    PublicationID?: true
    Name?: true
    VolumeNumber?: true
    IssueNumber?: true
    ISSN_Number?: true
  }

  export type JournalPublicationDetailsMaxAggregateInputType = {
    PublicationID?: true
    Name?: true
    VolumeNumber?: true
    IssueNumber?: true
    ISSN_Number?: true
  }

  export type JournalPublicationDetailsCountAggregateInputType = {
    PublicationID?: true
    Name?: true
    VolumeNumber?: true
    IssueNumber?: true
    ISSN_Number?: true
    _all?: true
  }

  export type JournalPublicationDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalPublicationDetails to aggregate.
     */
    where?: JournalPublicationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalPublicationDetails to fetch.
     */
    orderBy?: JournalPublicationDetailsOrderByWithRelationInput | JournalPublicationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalPublicationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalPublicationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalPublicationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalPublicationDetails
    **/
    _count?: true | JournalPublicationDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalPublicationDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalPublicationDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalPublicationDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalPublicationDetailsMaxAggregateInputType
  }

  export type GetJournalPublicationDetailsAggregateType<T extends JournalPublicationDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalPublicationDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalPublicationDetails[P]>
      : GetScalarType<T[P], AggregateJournalPublicationDetails[P]>
  }




  export type JournalPublicationDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalPublicationDetailsWhereInput
    orderBy?: JournalPublicationDetailsOrderByWithAggregationInput | JournalPublicationDetailsOrderByWithAggregationInput[]
    by: JournalPublicationDetailsScalarFieldEnum[] | JournalPublicationDetailsScalarFieldEnum
    having?: JournalPublicationDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalPublicationDetailsCountAggregateInputType | true
    _avg?: JournalPublicationDetailsAvgAggregateInputType
    _sum?: JournalPublicationDetailsSumAggregateInputType
    _min?: JournalPublicationDetailsMinAggregateInputType
    _max?: JournalPublicationDetailsMaxAggregateInputType
  }

  export type JournalPublicationDetailsGroupByOutputType = {
    PublicationID: number
    Name: string | null
    VolumeNumber: string | null
    IssueNumber: string | null
    ISSN_Number: number | null
    _count: JournalPublicationDetailsCountAggregateOutputType | null
    _avg: JournalPublicationDetailsAvgAggregateOutputType | null
    _sum: JournalPublicationDetailsSumAggregateOutputType | null
    _min: JournalPublicationDetailsMinAggregateOutputType | null
    _max: JournalPublicationDetailsMaxAggregateOutputType | null
  }

  type GetJournalPublicationDetailsGroupByPayload<T extends JournalPublicationDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalPublicationDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalPublicationDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalPublicationDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], JournalPublicationDetailsGroupByOutputType[P]>
        }
      >
    >


  export type JournalPublicationDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    Name?: boolean
    VolumeNumber?: boolean
    IssueNumber?: boolean
    ISSN_Number?: boolean
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalPublicationDetails"]>

  export type JournalPublicationDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    Name?: boolean
    VolumeNumber?: boolean
    IssueNumber?: boolean
    ISSN_Number?: boolean
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalPublicationDetails"]>

  export type JournalPublicationDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    Name?: boolean
    VolumeNumber?: boolean
    IssueNumber?: boolean
    ISSN_Number?: boolean
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalPublicationDetails"]>

  export type JournalPublicationDetailsSelectScalar = {
    PublicationID?: boolean
    Name?: boolean
    VolumeNumber?: boolean
    IssueNumber?: boolean
    ISSN_Number?: boolean
  }

  export type JournalPublicationDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"PublicationID" | "Name" | "VolumeNumber" | "IssueNumber" | "ISSN_Number", ExtArgs["result"]["journalPublicationDetails"]>
  export type JournalPublicationDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }
  export type JournalPublicationDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }
  export type JournalPublicationDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }

  export type $JournalPublicationDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalPublicationDetails"
    objects: {
      Publication: Prisma.$PublicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      PublicationID: number
      Name: string | null
      VolumeNumber: string | null
      IssueNumber: string | null
      ISSN_Number: number | null
    }, ExtArgs["result"]["journalPublicationDetails"]>
    composites: {}
  }

  type JournalPublicationDetailsGetPayload<S extends boolean | null | undefined | JournalPublicationDetailsDefaultArgs> = $Result.GetResult<Prisma.$JournalPublicationDetailsPayload, S>

  type JournalPublicationDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalPublicationDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalPublicationDetailsCountAggregateInputType | true
    }

  export interface JournalPublicationDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalPublicationDetails'], meta: { name: 'JournalPublicationDetails' } }
    /**
     * Find zero or one JournalPublicationDetails that matches the filter.
     * @param {JournalPublicationDetailsFindUniqueArgs} args - Arguments to find a JournalPublicationDetails
     * @example
     * // Get one JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalPublicationDetailsFindUniqueArgs>(args: SelectSubset<T, JournalPublicationDetailsFindUniqueArgs<ExtArgs>>): Prisma__JournalPublicationDetailsClient<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalPublicationDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalPublicationDetailsFindUniqueOrThrowArgs} args - Arguments to find a JournalPublicationDetails
     * @example
     * // Get one JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalPublicationDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalPublicationDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalPublicationDetailsClient<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalPublicationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalPublicationDetailsFindFirstArgs} args - Arguments to find a JournalPublicationDetails
     * @example
     * // Get one JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalPublicationDetailsFindFirstArgs>(args?: SelectSubset<T, JournalPublicationDetailsFindFirstArgs<ExtArgs>>): Prisma__JournalPublicationDetailsClient<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalPublicationDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalPublicationDetailsFindFirstOrThrowArgs} args - Arguments to find a JournalPublicationDetails
     * @example
     * // Get one JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalPublicationDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalPublicationDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalPublicationDetailsClient<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalPublicationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalPublicationDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.findMany()
     * 
     * // Get first 10 JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.findMany({ take: 10 })
     * 
     * // Only select the `PublicationID`
     * const journalPublicationDetailsWithPublicationIDOnly = await prisma.journalPublicationDetails.findMany({ select: { PublicationID: true } })
     * 
     */
    findMany<T extends JournalPublicationDetailsFindManyArgs>(args?: SelectSubset<T, JournalPublicationDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalPublicationDetails.
     * @param {JournalPublicationDetailsCreateArgs} args - Arguments to create a JournalPublicationDetails.
     * @example
     * // Create one JournalPublicationDetails
     * const JournalPublicationDetails = await prisma.journalPublicationDetails.create({
     *   data: {
     *     // ... data to create a JournalPublicationDetails
     *   }
     * })
     * 
     */
    create<T extends JournalPublicationDetailsCreateArgs>(args: SelectSubset<T, JournalPublicationDetailsCreateArgs<ExtArgs>>): Prisma__JournalPublicationDetailsClient<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalPublicationDetails.
     * @param {JournalPublicationDetailsCreateManyArgs} args - Arguments to create many JournalPublicationDetails.
     * @example
     * // Create many JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalPublicationDetailsCreateManyArgs>(args?: SelectSubset<T, JournalPublicationDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalPublicationDetails and returns the data saved in the database.
     * @param {JournalPublicationDetailsCreateManyAndReturnArgs} args - Arguments to create many JournalPublicationDetails.
     * @example
     * // Create many JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalPublicationDetails and only return the `PublicationID`
     * const journalPublicationDetailsWithPublicationIDOnly = await prisma.journalPublicationDetails.createManyAndReturn({
     *   select: { PublicationID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalPublicationDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalPublicationDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalPublicationDetails.
     * @param {JournalPublicationDetailsDeleteArgs} args - Arguments to delete one JournalPublicationDetails.
     * @example
     * // Delete one JournalPublicationDetails
     * const JournalPublicationDetails = await prisma.journalPublicationDetails.delete({
     *   where: {
     *     // ... filter to delete one JournalPublicationDetails
     *   }
     * })
     * 
     */
    delete<T extends JournalPublicationDetailsDeleteArgs>(args: SelectSubset<T, JournalPublicationDetailsDeleteArgs<ExtArgs>>): Prisma__JournalPublicationDetailsClient<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalPublicationDetails.
     * @param {JournalPublicationDetailsUpdateArgs} args - Arguments to update one JournalPublicationDetails.
     * @example
     * // Update one JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalPublicationDetailsUpdateArgs>(args: SelectSubset<T, JournalPublicationDetailsUpdateArgs<ExtArgs>>): Prisma__JournalPublicationDetailsClient<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalPublicationDetails.
     * @param {JournalPublicationDetailsDeleteManyArgs} args - Arguments to filter JournalPublicationDetails to delete.
     * @example
     * // Delete a few JournalPublicationDetails
     * const { count } = await prisma.journalPublicationDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalPublicationDetailsDeleteManyArgs>(args?: SelectSubset<T, JournalPublicationDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalPublicationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalPublicationDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalPublicationDetailsUpdateManyArgs>(args: SelectSubset<T, JournalPublicationDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalPublicationDetails and returns the data updated in the database.
     * @param {JournalPublicationDetailsUpdateManyAndReturnArgs} args - Arguments to update many JournalPublicationDetails.
     * @example
     * // Update many JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalPublicationDetails and only return the `PublicationID`
     * const journalPublicationDetailsWithPublicationIDOnly = await prisma.journalPublicationDetails.updateManyAndReturn({
     *   select: { PublicationID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalPublicationDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalPublicationDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalPublicationDetails.
     * @param {JournalPublicationDetailsUpsertArgs} args - Arguments to update or create a JournalPublicationDetails.
     * @example
     * // Update or create a JournalPublicationDetails
     * const journalPublicationDetails = await prisma.journalPublicationDetails.upsert({
     *   create: {
     *     // ... data to create a JournalPublicationDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalPublicationDetails we want to update
     *   }
     * })
     */
    upsert<T extends JournalPublicationDetailsUpsertArgs>(args: SelectSubset<T, JournalPublicationDetailsUpsertArgs<ExtArgs>>): Prisma__JournalPublicationDetailsClient<$Result.GetResult<Prisma.$JournalPublicationDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalPublicationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalPublicationDetailsCountArgs} args - Arguments to filter JournalPublicationDetails to count.
     * @example
     * // Count the number of JournalPublicationDetails
     * const count = await prisma.journalPublicationDetails.count({
     *   where: {
     *     // ... the filter for the JournalPublicationDetails we want to count
     *   }
     * })
    **/
    count<T extends JournalPublicationDetailsCountArgs>(
      args?: Subset<T, JournalPublicationDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalPublicationDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalPublicationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalPublicationDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalPublicationDetailsAggregateArgs>(args: Subset<T, JournalPublicationDetailsAggregateArgs>): Prisma.PrismaPromise<GetJournalPublicationDetailsAggregateType<T>>

    /**
     * Group by JournalPublicationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalPublicationDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalPublicationDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalPublicationDetailsGroupByArgs['orderBy'] }
        : { orderBy?: JournalPublicationDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalPublicationDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalPublicationDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalPublicationDetails model
   */
  readonly fields: JournalPublicationDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalPublicationDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalPublicationDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Publication<T extends PublicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicationsDefaultArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalPublicationDetails model
   */
  interface JournalPublicationDetailsFieldRefs {
    readonly PublicationID: FieldRef<"JournalPublicationDetails", 'Int'>
    readonly Name: FieldRef<"JournalPublicationDetails", 'String'>
    readonly VolumeNumber: FieldRef<"JournalPublicationDetails", 'String'>
    readonly IssueNumber: FieldRef<"JournalPublicationDetails", 'String'>
    readonly ISSN_Number: FieldRef<"JournalPublicationDetails", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * JournalPublicationDetails findUnique
   */
  export type JournalPublicationDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which JournalPublicationDetails to fetch.
     */
    where: JournalPublicationDetailsWhereUniqueInput
  }

  /**
   * JournalPublicationDetails findUniqueOrThrow
   */
  export type JournalPublicationDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which JournalPublicationDetails to fetch.
     */
    where: JournalPublicationDetailsWhereUniqueInput
  }

  /**
   * JournalPublicationDetails findFirst
   */
  export type JournalPublicationDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which JournalPublicationDetails to fetch.
     */
    where?: JournalPublicationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalPublicationDetails to fetch.
     */
    orderBy?: JournalPublicationDetailsOrderByWithRelationInput | JournalPublicationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalPublicationDetails.
     */
    cursor?: JournalPublicationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalPublicationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalPublicationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalPublicationDetails.
     */
    distinct?: JournalPublicationDetailsScalarFieldEnum | JournalPublicationDetailsScalarFieldEnum[]
  }

  /**
   * JournalPublicationDetails findFirstOrThrow
   */
  export type JournalPublicationDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which JournalPublicationDetails to fetch.
     */
    where?: JournalPublicationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalPublicationDetails to fetch.
     */
    orderBy?: JournalPublicationDetailsOrderByWithRelationInput | JournalPublicationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalPublicationDetails.
     */
    cursor?: JournalPublicationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalPublicationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalPublicationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalPublicationDetails.
     */
    distinct?: JournalPublicationDetailsScalarFieldEnum | JournalPublicationDetailsScalarFieldEnum[]
  }

  /**
   * JournalPublicationDetails findMany
   */
  export type JournalPublicationDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which JournalPublicationDetails to fetch.
     */
    where?: JournalPublicationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalPublicationDetails to fetch.
     */
    orderBy?: JournalPublicationDetailsOrderByWithRelationInput | JournalPublicationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalPublicationDetails.
     */
    cursor?: JournalPublicationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalPublicationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalPublicationDetails.
     */
    skip?: number
    distinct?: JournalPublicationDetailsScalarFieldEnum | JournalPublicationDetailsScalarFieldEnum[]
  }

  /**
   * JournalPublicationDetails create
   */
  export type JournalPublicationDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalPublicationDetails.
     */
    data: XOR<JournalPublicationDetailsCreateInput, JournalPublicationDetailsUncheckedCreateInput>
  }

  /**
   * JournalPublicationDetails createMany
   */
  export type JournalPublicationDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalPublicationDetails.
     */
    data: JournalPublicationDetailsCreateManyInput | JournalPublicationDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalPublicationDetails createManyAndReturn
   */
  export type JournalPublicationDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many JournalPublicationDetails.
     */
    data: JournalPublicationDetailsCreateManyInput | JournalPublicationDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalPublicationDetails update
   */
  export type JournalPublicationDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalPublicationDetails.
     */
    data: XOR<JournalPublicationDetailsUpdateInput, JournalPublicationDetailsUncheckedUpdateInput>
    /**
     * Choose, which JournalPublicationDetails to update.
     */
    where: JournalPublicationDetailsWhereUniqueInput
  }

  /**
   * JournalPublicationDetails updateMany
   */
  export type JournalPublicationDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalPublicationDetails.
     */
    data: XOR<JournalPublicationDetailsUpdateManyMutationInput, JournalPublicationDetailsUncheckedUpdateManyInput>
    /**
     * Filter which JournalPublicationDetails to update
     */
    where?: JournalPublicationDetailsWhereInput
    /**
     * Limit how many JournalPublicationDetails to update.
     */
    limit?: number
  }

  /**
   * JournalPublicationDetails updateManyAndReturn
   */
  export type JournalPublicationDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * The data used to update JournalPublicationDetails.
     */
    data: XOR<JournalPublicationDetailsUpdateManyMutationInput, JournalPublicationDetailsUncheckedUpdateManyInput>
    /**
     * Filter which JournalPublicationDetails to update
     */
    where?: JournalPublicationDetailsWhereInput
    /**
     * Limit how many JournalPublicationDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalPublicationDetails upsert
   */
  export type JournalPublicationDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalPublicationDetails to update in case it exists.
     */
    where: JournalPublicationDetailsWhereUniqueInput
    /**
     * In case the JournalPublicationDetails found by the `where` argument doesn't exist, create a new JournalPublicationDetails with this data.
     */
    create: XOR<JournalPublicationDetailsCreateInput, JournalPublicationDetailsUncheckedCreateInput>
    /**
     * In case the JournalPublicationDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalPublicationDetailsUpdateInput, JournalPublicationDetailsUncheckedUpdateInput>
  }

  /**
   * JournalPublicationDetails delete
   */
  export type JournalPublicationDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter which JournalPublicationDetails to delete.
     */
    where: JournalPublicationDetailsWhereUniqueInput
  }

  /**
   * JournalPublicationDetails deleteMany
   */
  export type JournalPublicationDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalPublicationDetails to delete
     */
    where?: JournalPublicationDetailsWhereInput
    /**
     * Limit how many JournalPublicationDetails to delete.
     */
    limit?: number
  }

  /**
   * JournalPublicationDetails without action
   */
  export type JournalPublicationDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalPublicationDetails
     */
    select?: JournalPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalPublicationDetails
     */
    omit?: JournalPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalPublicationDetailsInclude<ExtArgs> | null
  }


  /**
   * Model BookPublicationDetails
   */

  export type AggregateBookPublicationDetails = {
    _count: BookPublicationDetailsCountAggregateOutputType | null
    _avg: BookPublicationDetailsAvgAggregateOutputType | null
    _sum: BookPublicationDetailsSumAggregateOutputType | null
    _min: BookPublicationDetailsMinAggregateOutputType | null
    _max: BookPublicationDetailsMaxAggregateOutputType | null
  }

  export type BookPublicationDetailsAvgAggregateOutputType = {
    PublicationID: number | null
  }

  export type BookPublicationDetailsSumAggregateOutputType = {
    PublicationID: number | null
  }

  export type BookPublicationDetailsMinAggregateOutputType = {
    PublicationID: number | null
    Publisher: string | null
    Edition: string | null
    VolumeNumber: string | null
    ISBN_Number: string | null
  }

  export type BookPublicationDetailsMaxAggregateOutputType = {
    PublicationID: number | null
    Publisher: string | null
    Edition: string | null
    VolumeNumber: string | null
    ISBN_Number: string | null
  }

  export type BookPublicationDetailsCountAggregateOutputType = {
    PublicationID: number
    Publisher: number
    Edition: number
    VolumeNumber: number
    ISBN_Number: number
    _all: number
  }


  export type BookPublicationDetailsAvgAggregateInputType = {
    PublicationID?: true
  }

  export type BookPublicationDetailsSumAggregateInputType = {
    PublicationID?: true
  }

  export type BookPublicationDetailsMinAggregateInputType = {
    PublicationID?: true
    Publisher?: true
    Edition?: true
    VolumeNumber?: true
    ISBN_Number?: true
  }

  export type BookPublicationDetailsMaxAggregateInputType = {
    PublicationID?: true
    Publisher?: true
    Edition?: true
    VolumeNumber?: true
    ISBN_Number?: true
  }

  export type BookPublicationDetailsCountAggregateInputType = {
    PublicationID?: true
    Publisher?: true
    Edition?: true
    VolumeNumber?: true
    ISBN_Number?: true
    _all?: true
  }

  export type BookPublicationDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookPublicationDetails to aggregate.
     */
    where?: BookPublicationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookPublicationDetails to fetch.
     */
    orderBy?: BookPublicationDetailsOrderByWithRelationInput | BookPublicationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookPublicationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookPublicationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookPublicationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookPublicationDetails
    **/
    _count?: true | BookPublicationDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookPublicationDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookPublicationDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookPublicationDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookPublicationDetailsMaxAggregateInputType
  }

  export type GetBookPublicationDetailsAggregateType<T extends BookPublicationDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateBookPublicationDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookPublicationDetails[P]>
      : GetScalarType<T[P], AggregateBookPublicationDetails[P]>
  }




  export type BookPublicationDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookPublicationDetailsWhereInput
    orderBy?: BookPublicationDetailsOrderByWithAggregationInput | BookPublicationDetailsOrderByWithAggregationInput[]
    by: BookPublicationDetailsScalarFieldEnum[] | BookPublicationDetailsScalarFieldEnum
    having?: BookPublicationDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookPublicationDetailsCountAggregateInputType | true
    _avg?: BookPublicationDetailsAvgAggregateInputType
    _sum?: BookPublicationDetailsSumAggregateInputType
    _min?: BookPublicationDetailsMinAggregateInputType
    _max?: BookPublicationDetailsMaxAggregateInputType
  }

  export type BookPublicationDetailsGroupByOutputType = {
    PublicationID: number
    Publisher: string | null
    Edition: string | null
    VolumeNumber: string | null
    ISBN_Number: string | null
    _count: BookPublicationDetailsCountAggregateOutputType | null
    _avg: BookPublicationDetailsAvgAggregateOutputType | null
    _sum: BookPublicationDetailsSumAggregateOutputType | null
    _min: BookPublicationDetailsMinAggregateOutputType | null
    _max: BookPublicationDetailsMaxAggregateOutputType | null
  }

  type GetBookPublicationDetailsGroupByPayload<T extends BookPublicationDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookPublicationDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookPublicationDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookPublicationDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], BookPublicationDetailsGroupByOutputType[P]>
        }
      >
    >


  export type BookPublicationDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    Publisher?: boolean
    Edition?: boolean
    VolumeNumber?: boolean
    ISBN_Number?: boolean
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookPublicationDetails"]>

  export type BookPublicationDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    Publisher?: boolean
    Edition?: boolean
    VolumeNumber?: boolean
    ISBN_Number?: boolean
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookPublicationDetails"]>

  export type BookPublicationDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    Publisher?: boolean
    Edition?: boolean
    VolumeNumber?: boolean
    ISBN_Number?: boolean
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookPublicationDetails"]>

  export type BookPublicationDetailsSelectScalar = {
    PublicationID?: boolean
    Publisher?: boolean
    Edition?: boolean
    VolumeNumber?: boolean
    ISBN_Number?: boolean
  }

  export type BookPublicationDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"PublicationID" | "Publisher" | "Edition" | "VolumeNumber" | "ISBN_Number", ExtArgs["result"]["bookPublicationDetails"]>
  export type BookPublicationDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }
  export type BookPublicationDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }
  export type BookPublicationDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }

  export type $BookPublicationDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookPublicationDetails"
    objects: {
      Publication: Prisma.$PublicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      PublicationID: number
      Publisher: string | null
      Edition: string | null
      VolumeNumber: string | null
      ISBN_Number: string | null
    }, ExtArgs["result"]["bookPublicationDetails"]>
    composites: {}
  }

  type BookPublicationDetailsGetPayload<S extends boolean | null | undefined | BookPublicationDetailsDefaultArgs> = $Result.GetResult<Prisma.$BookPublicationDetailsPayload, S>

  type BookPublicationDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookPublicationDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookPublicationDetailsCountAggregateInputType | true
    }

  export interface BookPublicationDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookPublicationDetails'], meta: { name: 'BookPublicationDetails' } }
    /**
     * Find zero or one BookPublicationDetails that matches the filter.
     * @param {BookPublicationDetailsFindUniqueArgs} args - Arguments to find a BookPublicationDetails
     * @example
     * // Get one BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookPublicationDetailsFindUniqueArgs>(args: SelectSubset<T, BookPublicationDetailsFindUniqueArgs<ExtArgs>>): Prisma__BookPublicationDetailsClient<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookPublicationDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookPublicationDetailsFindUniqueOrThrowArgs} args - Arguments to find a BookPublicationDetails
     * @example
     * // Get one BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookPublicationDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, BookPublicationDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookPublicationDetailsClient<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookPublicationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPublicationDetailsFindFirstArgs} args - Arguments to find a BookPublicationDetails
     * @example
     * // Get one BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookPublicationDetailsFindFirstArgs>(args?: SelectSubset<T, BookPublicationDetailsFindFirstArgs<ExtArgs>>): Prisma__BookPublicationDetailsClient<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookPublicationDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPublicationDetailsFindFirstOrThrowArgs} args - Arguments to find a BookPublicationDetails
     * @example
     * // Get one BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookPublicationDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, BookPublicationDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookPublicationDetailsClient<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookPublicationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPublicationDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.findMany()
     * 
     * // Get first 10 BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.findMany({ take: 10 })
     * 
     * // Only select the `PublicationID`
     * const bookPublicationDetailsWithPublicationIDOnly = await prisma.bookPublicationDetails.findMany({ select: { PublicationID: true } })
     * 
     */
    findMany<T extends BookPublicationDetailsFindManyArgs>(args?: SelectSubset<T, BookPublicationDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookPublicationDetails.
     * @param {BookPublicationDetailsCreateArgs} args - Arguments to create a BookPublicationDetails.
     * @example
     * // Create one BookPublicationDetails
     * const BookPublicationDetails = await prisma.bookPublicationDetails.create({
     *   data: {
     *     // ... data to create a BookPublicationDetails
     *   }
     * })
     * 
     */
    create<T extends BookPublicationDetailsCreateArgs>(args: SelectSubset<T, BookPublicationDetailsCreateArgs<ExtArgs>>): Prisma__BookPublicationDetailsClient<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookPublicationDetails.
     * @param {BookPublicationDetailsCreateManyArgs} args - Arguments to create many BookPublicationDetails.
     * @example
     * // Create many BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookPublicationDetailsCreateManyArgs>(args?: SelectSubset<T, BookPublicationDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookPublicationDetails and returns the data saved in the database.
     * @param {BookPublicationDetailsCreateManyAndReturnArgs} args - Arguments to create many BookPublicationDetails.
     * @example
     * // Create many BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookPublicationDetails and only return the `PublicationID`
     * const bookPublicationDetailsWithPublicationIDOnly = await prisma.bookPublicationDetails.createManyAndReturn({
     *   select: { PublicationID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookPublicationDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, BookPublicationDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookPublicationDetails.
     * @param {BookPublicationDetailsDeleteArgs} args - Arguments to delete one BookPublicationDetails.
     * @example
     * // Delete one BookPublicationDetails
     * const BookPublicationDetails = await prisma.bookPublicationDetails.delete({
     *   where: {
     *     // ... filter to delete one BookPublicationDetails
     *   }
     * })
     * 
     */
    delete<T extends BookPublicationDetailsDeleteArgs>(args: SelectSubset<T, BookPublicationDetailsDeleteArgs<ExtArgs>>): Prisma__BookPublicationDetailsClient<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookPublicationDetails.
     * @param {BookPublicationDetailsUpdateArgs} args - Arguments to update one BookPublicationDetails.
     * @example
     * // Update one BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookPublicationDetailsUpdateArgs>(args: SelectSubset<T, BookPublicationDetailsUpdateArgs<ExtArgs>>): Prisma__BookPublicationDetailsClient<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookPublicationDetails.
     * @param {BookPublicationDetailsDeleteManyArgs} args - Arguments to filter BookPublicationDetails to delete.
     * @example
     * // Delete a few BookPublicationDetails
     * const { count } = await prisma.bookPublicationDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookPublicationDetailsDeleteManyArgs>(args?: SelectSubset<T, BookPublicationDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookPublicationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPublicationDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookPublicationDetailsUpdateManyArgs>(args: SelectSubset<T, BookPublicationDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookPublicationDetails and returns the data updated in the database.
     * @param {BookPublicationDetailsUpdateManyAndReturnArgs} args - Arguments to update many BookPublicationDetails.
     * @example
     * // Update many BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookPublicationDetails and only return the `PublicationID`
     * const bookPublicationDetailsWithPublicationIDOnly = await prisma.bookPublicationDetails.updateManyAndReturn({
     *   select: { PublicationID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookPublicationDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, BookPublicationDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookPublicationDetails.
     * @param {BookPublicationDetailsUpsertArgs} args - Arguments to update or create a BookPublicationDetails.
     * @example
     * // Update or create a BookPublicationDetails
     * const bookPublicationDetails = await prisma.bookPublicationDetails.upsert({
     *   create: {
     *     // ... data to create a BookPublicationDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookPublicationDetails we want to update
     *   }
     * })
     */
    upsert<T extends BookPublicationDetailsUpsertArgs>(args: SelectSubset<T, BookPublicationDetailsUpsertArgs<ExtArgs>>): Prisma__BookPublicationDetailsClient<$Result.GetResult<Prisma.$BookPublicationDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookPublicationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPublicationDetailsCountArgs} args - Arguments to filter BookPublicationDetails to count.
     * @example
     * // Count the number of BookPublicationDetails
     * const count = await prisma.bookPublicationDetails.count({
     *   where: {
     *     // ... the filter for the BookPublicationDetails we want to count
     *   }
     * })
    **/
    count<T extends BookPublicationDetailsCountArgs>(
      args?: Subset<T, BookPublicationDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookPublicationDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookPublicationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPublicationDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookPublicationDetailsAggregateArgs>(args: Subset<T, BookPublicationDetailsAggregateArgs>): Prisma.PrismaPromise<GetBookPublicationDetailsAggregateType<T>>

    /**
     * Group by BookPublicationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPublicationDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookPublicationDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookPublicationDetailsGroupByArgs['orderBy'] }
        : { orderBy?: BookPublicationDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookPublicationDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookPublicationDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookPublicationDetails model
   */
  readonly fields: BookPublicationDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookPublicationDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookPublicationDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Publication<T extends PublicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicationsDefaultArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookPublicationDetails model
   */
  interface BookPublicationDetailsFieldRefs {
    readonly PublicationID: FieldRef<"BookPublicationDetails", 'Int'>
    readonly Publisher: FieldRef<"BookPublicationDetails", 'String'>
    readonly Edition: FieldRef<"BookPublicationDetails", 'String'>
    readonly VolumeNumber: FieldRef<"BookPublicationDetails", 'String'>
    readonly ISBN_Number: FieldRef<"BookPublicationDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookPublicationDetails findUnique
   */
  export type BookPublicationDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BookPublicationDetails to fetch.
     */
    where: BookPublicationDetailsWhereUniqueInput
  }

  /**
   * BookPublicationDetails findUniqueOrThrow
   */
  export type BookPublicationDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BookPublicationDetails to fetch.
     */
    where: BookPublicationDetailsWhereUniqueInput
  }

  /**
   * BookPublicationDetails findFirst
   */
  export type BookPublicationDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BookPublicationDetails to fetch.
     */
    where?: BookPublicationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookPublicationDetails to fetch.
     */
    orderBy?: BookPublicationDetailsOrderByWithRelationInput | BookPublicationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookPublicationDetails.
     */
    cursor?: BookPublicationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookPublicationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookPublicationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookPublicationDetails.
     */
    distinct?: BookPublicationDetailsScalarFieldEnum | BookPublicationDetailsScalarFieldEnum[]
  }

  /**
   * BookPublicationDetails findFirstOrThrow
   */
  export type BookPublicationDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BookPublicationDetails to fetch.
     */
    where?: BookPublicationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookPublicationDetails to fetch.
     */
    orderBy?: BookPublicationDetailsOrderByWithRelationInput | BookPublicationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookPublicationDetails.
     */
    cursor?: BookPublicationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookPublicationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookPublicationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookPublicationDetails.
     */
    distinct?: BookPublicationDetailsScalarFieldEnum | BookPublicationDetailsScalarFieldEnum[]
  }

  /**
   * BookPublicationDetails findMany
   */
  export type BookPublicationDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BookPublicationDetails to fetch.
     */
    where?: BookPublicationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookPublicationDetails to fetch.
     */
    orderBy?: BookPublicationDetailsOrderByWithRelationInput | BookPublicationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookPublicationDetails.
     */
    cursor?: BookPublicationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookPublicationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookPublicationDetails.
     */
    skip?: number
    distinct?: BookPublicationDetailsScalarFieldEnum | BookPublicationDetailsScalarFieldEnum[]
  }

  /**
   * BookPublicationDetails create
   */
  export type BookPublicationDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a BookPublicationDetails.
     */
    data: XOR<BookPublicationDetailsCreateInput, BookPublicationDetailsUncheckedCreateInput>
  }

  /**
   * BookPublicationDetails createMany
   */
  export type BookPublicationDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookPublicationDetails.
     */
    data: BookPublicationDetailsCreateManyInput | BookPublicationDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookPublicationDetails createManyAndReturn
   */
  export type BookPublicationDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many BookPublicationDetails.
     */
    data: BookPublicationDetailsCreateManyInput | BookPublicationDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookPublicationDetails update
   */
  export type BookPublicationDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a BookPublicationDetails.
     */
    data: XOR<BookPublicationDetailsUpdateInput, BookPublicationDetailsUncheckedUpdateInput>
    /**
     * Choose, which BookPublicationDetails to update.
     */
    where: BookPublicationDetailsWhereUniqueInput
  }

  /**
   * BookPublicationDetails updateMany
   */
  export type BookPublicationDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookPublicationDetails.
     */
    data: XOR<BookPublicationDetailsUpdateManyMutationInput, BookPublicationDetailsUncheckedUpdateManyInput>
    /**
     * Filter which BookPublicationDetails to update
     */
    where?: BookPublicationDetailsWhereInput
    /**
     * Limit how many BookPublicationDetails to update.
     */
    limit?: number
  }

  /**
   * BookPublicationDetails updateManyAndReturn
   */
  export type BookPublicationDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * The data used to update BookPublicationDetails.
     */
    data: XOR<BookPublicationDetailsUpdateManyMutationInput, BookPublicationDetailsUncheckedUpdateManyInput>
    /**
     * Filter which BookPublicationDetails to update
     */
    where?: BookPublicationDetailsWhereInput
    /**
     * Limit how many BookPublicationDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookPublicationDetails upsert
   */
  export type BookPublicationDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the BookPublicationDetails to update in case it exists.
     */
    where: BookPublicationDetailsWhereUniqueInput
    /**
     * In case the BookPublicationDetails found by the `where` argument doesn't exist, create a new BookPublicationDetails with this data.
     */
    create: XOR<BookPublicationDetailsCreateInput, BookPublicationDetailsUncheckedCreateInput>
    /**
     * In case the BookPublicationDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookPublicationDetailsUpdateInput, BookPublicationDetailsUncheckedUpdateInput>
  }

  /**
   * BookPublicationDetails delete
   */
  export type BookPublicationDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
    /**
     * Filter which BookPublicationDetails to delete.
     */
    where: BookPublicationDetailsWhereUniqueInput
  }

  /**
   * BookPublicationDetails deleteMany
   */
  export type BookPublicationDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookPublicationDetails to delete
     */
    where?: BookPublicationDetailsWhereInput
    /**
     * Limit how many BookPublicationDetails to delete.
     */
    limit?: number
  }

  /**
   * BookPublicationDetails without action
   */
  export type BookPublicationDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPublicationDetails
     */
    select?: BookPublicationDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPublicationDetails
     */
    omit?: BookPublicationDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPublicationDetailsInclude<ExtArgs> | null
  }


  /**
   * Model ConferencePaperDetails
   */

  export type AggregateConferencePaperDetails = {
    _count: ConferencePaperDetailsCountAggregateOutputType | null
    _avg: ConferencePaperDetailsAvgAggregateOutputType | null
    _sum: ConferencePaperDetailsSumAggregateOutputType | null
    _min: ConferencePaperDetailsMinAggregateOutputType | null
    _max: ConferencePaperDetailsMaxAggregateOutputType | null
  }

  export type ConferencePaperDetailsAvgAggregateOutputType = {
    PublicationID: number | null
  }

  export type ConferencePaperDetailsSumAggregateOutputType = {
    PublicationID: number | null
  }

  export type ConferencePaperDetailsMinAggregateOutputType = {
    PublicationID: number | null
    Publisher: string | null
    Location: string | null
    PageNumbers: string | null
  }

  export type ConferencePaperDetailsMaxAggregateOutputType = {
    PublicationID: number | null
    Publisher: string | null
    Location: string | null
    PageNumbers: string | null
  }

  export type ConferencePaperDetailsCountAggregateOutputType = {
    PublicationID: number
    Publisher: number
    Location: number
    PageNumbers: number
    _all: number
  }


  export type ConferencePaperDetailsAvgAggregateInputType = {
    PublicationID?: true
  }

  export type ConferencePaperDetailsSumAggregateInputType = {
    PublicationID?: true
  }

  export type ConferencePaperDetailsMinAggregateInputType = {
    PublicationID?: true
    Publisher?: true
    Location?: true
    PageNumbers?: true
  }

  export type ConferencePaperDetailsMaxAggregateInputType = {
    PublicationID?: true
    Publisher?: true
    Location?: true
    PageNumbers?: true
  }

  export type ConferencePaperDetailsCountAggregateInputType = {
    PublicationID?: true
    Publisher?: true
    Location?: true
    PageNumbers?: true
    _all?: true
  }

  export type ConferencePaperDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferencePaperDetails to aggregate.
     */
    where?: ConferencePaperDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferencePaperDetails to fetch.
     */
    orderBy?: ConferencePaperDetailsOrderByWithRelationInput | ConferencePaperDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferencePaperDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferencePaperDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferencePaperDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferencePaperDetails
    **/
    _count?: true | ConferencePaperDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferencePaperDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferencePaperDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferencePaperDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferencePaperDetailsMaxAggregateInputType
  }

  export type GetConferencePaperDetailsAggregateType<T extends ConferencePaperDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferencePaperDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferencePaperDetails[P]>
      : GetScalarType<T[P], AggregateConferencePaperDetails[P]>
  }




  export type ConferencePaperDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferencePaperDetailsWhereInput
    orderBy?: ConferencePaperDetailsOrderByWithAggregationInput | ConferencePaperDetailsOrderByWithAggregationInput[]
    by: ConferencePaperDetailsScalarFieldEnum[] | ConferencePaperDetailsScalarFieldEnum
    having?: ConferencePaperDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferencePaperDetailsCountAggregateInputType | true
    _avg?: ConferencePaperDetailsAvgAggregateInputType
    _sum?: ConferencePaperDetailsSumAggregateInputType
    _min?: ConferencePaperDetailsMinAggregateInputType
    _max?: ConferencePaperDetailsMaxAggregateInputType
  }

  export type ConferencePaperDetailsGroupByOutputType = {
    PublicationID: number
    Publisher: string | null
    Location: string | null
    PageNumbers: string | null
    _count: ConferencePaperDetailsCountAggregateOutputType | null
    _avg: ConferencePaperDetailsAvgAggregateOutputType | null
    _sum: ConferencePaperDetailsSumAggregateOutputType | null
    _min: ConferencePaperDetailsMinAggregateOutputType | null
    _max: ConferencePaperDetailsMaxAggregateOutputType | null
  }

  type GetConferencePaperDetailsGroupByPayload<T extends ConferencePaperDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferencePaperDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferencePaperDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferencePaperDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferencePaperDetailsGroupByOutputType[P]>
        }
      >
    >


  export type ConferencePaperDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    Publisher?: boolean
    Location?: boolean
    PageNumbers?: boolean
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferencePaperDetails"]>

  export type ConferencePaperDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    Publisher?: boolean
    Location?: boolean
    PageNumbers?: boolean
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferencePaperDetails"]>

  export type ConferencePaperDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    Publisher?: boolean
    Location?: boolean
    PageNumbers?: boolean
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferencePaperDetails"]>

  export type ConferencePaperDetailsSelectScalar = {
    PublicationID?: boolean
    Publisher?: boolean
    Location?: boolean
    PageNumbers?: boolean
  }

  export type ConferencePaperDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"PublicationID" | "Publisher" | "Location" | "PageNumbers", ExtArgs["result"]["conferencePaperDetails"]>
  export type ConferencePaperDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }
  export type ConferencePaperDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }
  export type ConferencePaperDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }

  export type $ConferencePaperDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferencePaperDetails"
    objects: {
      Publication: Prisma.$PublicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      PublicationID: number
      Publisher: string | null
      Location: string | null
      PageNumbers: string | null
    }, ExtArgs["result"]["conferencePaperDetails"]>
    composites: {}
  }

  type ConferencePaperDetailsGetPayload<S extends boolean | null | undefined | ConferencePaperDetailsDefaultArgs> = $Result.GetResult<Prisma.$ConferencePaperDetailsPayload, S>

  type ConferencePaperDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferencePaperDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferencePaperDetailsCountAggregateInputType | true
    }

  export interface ConferencePaperDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferencePaperDetails'], meta: { name: 'ConferencePaperDetails' } }
    /**
     * Find zero or one ConferencePaperDetails that matches the filter.
     * @param {ConferencePaperDetailsFindUniqueArgs} args - Arguments to find a ConferencePaperDetails
     * @example
     * // Get one ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferencePaperDetailsFindUniqueArgs>(args: SelectSubset<T, ConferencePaperDetailsFindUniqueArgs<ExtArgs>>): Prisma__ConferencePaperDetailsClient<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferencePaperDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferencePaperDetailsFindUniqueOrThrowArgs} args - Arguments to find a ConferencePaperDetails
     * @example
     * // Get one ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferencePaperDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferencePaperDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferencePaperDetailsClient<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferencePaperDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencePaperDetailsFindFirstArgs} args - Arguments to find a ConferencePaperDetails
     * @example
     * // Get one ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferencePaperDetailsFindFirstArgs>(args?: SelectSubset<T, ConferencePaperDetailsFindFirstArgs<ExtArgs>>): Prisma__ConferencePaperDetailsClient<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferencePaperDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencePaperDetailsFindFirstOrThrowArgs} args - Arguments to find a ConferencePaperDetails
     * @example
     * // Get one ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferencePaperDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferencePaperDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferencePaperDetailsClient<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferencePaperDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencePaperDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.findMany()
     * 
     * // Get first 10 ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.findMany({ take: 10 })
     * 
     * // Only select the `PublicationID`
     * const conferencePaperDetailsWithPublicationIDOnly = await prisma.conferencePaperDetails.findMany({ select: { PublicationID: true } })
     * 
     */
    findMany<T extends ConferencePaperDetailsFindManyArgs>(args?: SelectSubset<T, ConferencePaperDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferencePaperDetails.
     * @param {ConferencePaperDetailsCreateArgs} args - Arguments to create a ConferencePaperDetails.
     * @example
     * // Create one ConferencePaperDetails
     * const ConferencePaperDetails = await prisma.conferencePaperDetails.create({
     *   data: {
     *     // ... data to create a ConferencePaperDetails
     *   }
     * })
     * 
     */
    create<T extends ConferencePaperDetailsCreateArgs>(args: SelectSubset<T, ConferencePaperDetailsCreateArgs<ExtArgs>>): Prisma__ConferencePaperDetailsClient<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferencePaperDetails.
     * @param {ConferencePaperDetailsCreateManyArgs} args - Arguments to create many ConferencePaperDetails.
     * @example
     * // Create many ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferencePaperDetailsCreateManyArgs>(args?: SelectSubset<T, ConferencePaperDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferencePaperDetails and returns the data saved in the database.
     * @param {ConferencePaperDetailsCreateManyAndReturnArgs} args - Arguments to create many ConferencePaperDetails.
     * @example
     * // Create many ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferencePaperDetails and only return the `PublicationID`
     * const conferencePaperDetailsWithPublicationIDOnly = await prisma.conferencePaperDetails.createManyAndReturn({
     *   select: { PublicationID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferencePaperDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferencePaperDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferencePaperDetails.
     * @param {ConferencePaperDetailsDeleteArgs} args - Arguments to delete one ConferencePaperDetails.
     * @example
     * // Delete one ConferencePaperDetails
     * const ConferencePaperDetails = await prisma.conferencePaperDetails.delete({
     *   where: {
     *     // ... filter to delete one ConferencePaperDetails
     *   }
     * })
     * 
     */
    delete<T extends ConferencePaperDetailsDeleteArgs>(args: SelectSubset<T, ConferencePaperDetailsDeleteArgs<ExtArgs>>): Prisma__ConferencePaperDetailsClient<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferencePaperDetails.
     * @param {ConferencePaperDetailsUpdateArgs} args - Arguments to update one ConferencePaperDetails.
     * @example
     * // Update one ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferencePaperDetailsUpdateArgs>(args: SelectSubset<T, ConferencePaperDetailsUpdateArgs<ExtArgs>>): Prisma__ConferencePaperDetailsClient<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferencePaperDetails.
     * @param {ConferencePaperDetailsDeleteManyArgs} args - Arguments to filter ConferencePaperDetails to delete.
     * @example
     * // Delete a few ConferencePaperDetails
     * const { count } = await prisma.conferencePaperDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferencePaperDetailsDeleteManyArgs>(args?: SelectSubset<T, ConferencePaperDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferencePaperDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencePaperDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferencePaperDetailsUpdateManyArgs>(args: SelectSubset<T, ConferencePaperDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferencePaperDetails and returns the data updated in the database.
     * @param {ConferencePaperDetailsUpdateManyAndReturnArgs} args - Arguments to update many ConferencePaperDetails.
     * @example
     * // Update many ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferencePaperDetails and only return the `PublicationID`
     * const conferencePaperDetailsWithPublicationIDOnly = await prisma.conferencePaperDetails.updateManyAndReturn({
     *   select: { PublicationID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferencePaperDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferencePaperDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferencePaperDetails.
     * @param {ConferencePaperDetailsUpsertArgs} args - Arguments to update or create a ConferencePaperDetails.
     * @example
     * // Update or create a ConferencePaperDetails
     * const conferencePaperDetails = await prisma.conferencePaperDetails.upsert({
     *   create: {
     *     // ... data to create a ConferencePaperDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferencePaperDetails we want to update
     *   }
     * })
     */
    upsert<T extends ConferencePaperDetailsUpsertArgs>(args: SelectSubset<T, ConferencePaperDetailsUpsertArgs<ExtArgs>>): Prisma__ConferencePaperDetailsClient<$Result.GetResult<Prisma.$ConferencePaperDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferencePaperDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencePaperDetailsCountArgs} args - Arguments to filter ConferencePaperDetails to count.
     * @example
     * // Count the number of ConferencePaperDetails
     * const count = await prisma.conferencePaperDetails.count({
     *   where: {
     *     // ... the filter for the ConferencePaperDetails we want to count
     *   }
     * })
    **/
    count<T extends ConferencePaperDetailsCountArgs>(
      args?: Subset<T, ConferencePaperDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferencePaperDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferencePaperDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencePaperDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferencePaperDetailsAggregateArgs>(args: Subset<T, ConferencePaperDetailsAggregateArgs>): Prisma.PrismaPromise<GetConferencePaperDetailsAggregateType<T>>

    /**
     * Group by ConferencePaperDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencePaperDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferencePaperDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferencePaperDetailsGroupByArgs['orderBy'] }
        : { orderBy?: ConferencePaperDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferencePaperDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferencePaperDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferencePaperDetails model
   */
  readonly fields: ConferencePaperDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferencePaperDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferencePaperDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Publication<T extends PublicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicationsDefaultArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferencePaperDetails model
   */
  interface ConferencePaperDetailsFieldRefs {
    readonly PublicationID: FieldRef<"ConferencePaperDetails", 'Int'>
    readonly Publisher: FieldRef<"ConferencePaperDetails", 'String'>
    readonly Location: FieldRef<"ConferencePaperDetails", 'String'>
    readonly PageNumbers: FieldRef<"ConferencePaperDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConferencePaperDetails findUnique
   */
  export type ConferencePaperDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ConferencePaperDetails to fetch.
     */
    where: ConferencePaperDetailsWhereUniqueInput
  }

  /**
   * ConferencePaperDetails findUniqueOrThrow
   */
  export type ConferencePaperDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ConferencePaperDetails to fetch.
     */
    where: ConferencePaperDetailsWhereUniqueInput
  }

  /**
   * ConferencePaperDetails findFirst
   */
  export type ConferencePaperDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ConferencePaperDetails to fetch.
     */
    where?: ConferencePaperDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferencePaperDetails to fetch.
     */
    orderBy?: ConferencePaperDetailsOrderByWithRelationInput | ConferencePaperDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferencePaperDetails.
     */
    cursor?: ConferencePaperDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferencePaperDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferencePaperDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferencePaperDetails.
     */
    distinct?: ConferencePaperDetailsScalarFieldEnum | ConferencePaperDetailsScalarFieldEnum[]
  }

  /**
   * ConferencePaperDetails findFirstOrThrow
   */
  export type ConferencePaperDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ConferencePaperDetails to fetch.
     */
    where?: ConferencePaperDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferencePaperDetails to fetch.
     */
    orderBy?: ConferencePaperDetailsOrderByWithRelationInput | ConferencePaperDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferencePaperDetails.
     */
    cursor?: ConferencePaperDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferencePaperDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferencePaperDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferencePaperDetails.
     */
    distinct?: ConferencePaperDetailsScalarFieldEnum | ConferencePaperDetailsScalarFieldEnum[]
  }

  /**
   * ConferencePaperDetails findMany
   */
  export type ConferencePaperDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ConferencePaperDetails to fetch.
     */
    where?: ConferencePaperDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferencePaperDetails to fetch.
     */
    orderBy?: ConferencePaperDetailsOrderByWithRelationInput | ConferencePaperDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferencePaperDetails.
     */
    cursor?: ConferencePaperDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferencePaperDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferencePaperDetails.
     */
    skip?: number
    distinct?: ConferencePaperDetailsScalarFieldEnum | ConferencePaperDetailsScalarFieldEnum[]
  }

  /**
   * ConferencePaperDetails create
   */
  export type ConferencePaperDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferencePaperDetails.
     */
    data: XOR<ConferencePaperDetailsCreateInput, ConferencePaperDetailsUncheckedCreateInput>
  }

  /**
   * ConferencePaperDetails createMany
   */
  export type ConferencePaperDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferencePaperDetails.
     */
    data: ConferencePaperDetailsCreateManyInput | ConferencePaperDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferencePaperDetails createManyAndReturn
   */
  export type ConferencePaperDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferencePaperDetails.
     */
    data: ConferencePaperDetailsCreateManyInput | ConferencePaperDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferencePaperDetails update
   */
  export type ConferencePaperDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferencePaperDetails.
     */
    data: XOR<ConferencePaperDetailsUpdateInput, ConferencePaperDetailsUncheckedUpdateInput>
    /**
     * Choose, which ConferencePaperDetails to update.
     */
    where: ConferencePaperDetailsWhereUniqueInput
  }

  /**
   * ConferencePaperDetails updateMany
   */
  export type ConferencePaperDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferencePaperDetails.
     */
    data: XOR<ConferencePaperDetailsUpdateManyMutationInput, ConferencePaperDetailsUncheckedUpdateManyInput>
    /**
     * Filter which ConferencePaperDetails to update
     */
    where?: ConferencePaperDetailsWhereInput
    /**
     * Limit how many ConferencePaperDetails to update.
     */
    limit?: number
  }

  /**
   * ConferencePaperDetails updateManyAndReturn
   */
  export type ConferencePaperDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * The data used to update ConferencePaperDetails.
     */
    data: XOR<ConferencePaperDetailsUpdateManyMutationInput, ConferencePaperDetailsUncheckedUpdateManyInput>
    /**
     * Filter which ConferencePaperDetails to update
     */
    where?: ConferencePaperDetailsWhereInput
    /**
     * Limit how many ConferencePaperDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferencePaperDetails upsert
   */
  export type ConferencePaperDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferencePaperDetails to update in case it exists.
     */
    where: ConferencePaperDetailsWhereUniqueInput
    /**
     * In case the ConferencePaperDetails found by the `where` argument doesn't exist, create a new ConferencePaperDetails with this data.
     */
    create: XOR<ConferencePaperDetailsCreateInput, ConferencePaperDetailsUncheckedCreateInput>
    /**
     * In case the ConferencePaperDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferencePaperDetailsUpdateInput, ConferencePaperDetailsUncheckedUpdateInput>
  }

  /**
   * ConferencePaperDetails delete
   */
  export type ConferencePaperDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
    /**
     * Filter which ConferencePaperDetails to delete.
     */
    where: ConferencePaperDetailsWhereUniqueInput
  }

  /**
   * ConferencePaperDetails deleteMany
   */
  export type ConferencePaperDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferencePaperDetails to delete
     */
    where?: ConferencePaperDetailsWhereInput
    /**
     * Limit how many ConferencePaperDetails to delete.
     */
    limit?: number
  }

  /**
   * ConferencePaperDetails without action
   */
  export type ConferencePaperDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencePaperDetails
     */
    select?: ConferencePaperDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferencePaperDetails
     */
    omit?: ConferencePaperDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencePaperDetailsInclude<ExtArgs> | null
  }


  /**
   * Model FacultyPublicationLink
   */

  export type AggregateFacultyPublicationLink = {
    _count: FacultyPublicationLinkCountAggregateOutputType | null
    _avg: FacultyPublicationLinkAvgAggregateOutputType | null
    _sum: FacultyPublicationLinkSumAggregateOutputType | null
    _min: FacultyPublicationLinkMinAggregateOutputType | null
    _max: FacultyPublicationLinkMaxAggregateOutputType | null
  }

  export type FacultyPublicationLinkAvgAggregateOutputType = {
    PublicationID: number | null
    FacultyID: number | null
  }

  export type FacultyPublicationLinkSumAggregateOutputType = {
    PublicationID: number | null
    FacultyID: number | null
  }

  export type FacultyPublicationLinkMinAggregateOutputType = {
    PublicationID: number | null
    FacultyID: number | null
    TypeOfIndexing: string | null
  }

  export type FacultyPublicationLinkMaxAggregateOutputType = {
    PublicationID: number | null
    FacultyID: number | null
    TypeOfIndexing: string | null
  }

  export type FacultyPublicationLinkCountAggregateOutputType = {
    PublicationID: number
    FacultyID: number
    TypeOfIndexing: number
    _all: number
  }


  export type FacultyPublicationLinkAvgAggregateInputType = {
    PublicationID?: true
    FacultyID?: true
  }

  export type FacultyPublicationLinkSumAggregateInputType = {
    PublicationID?: true
    FacultyID?: true
  }

  export type FacultyPublicationLinkMinAggregateInputType = {
    PublicationID?: true
    FacultyID?: true
    TypeOfIndexing?: true
  }

  export type FacultyPublicationLinkMaxAggregateInputType = {
    PublicationID?: true
    FacultyID?: true
    TypeOfIndexing?: true
  }

  export type FacultyPublicationLinkCountAggregateInputType = {
    PublicationID?: true
    FacultyID?: true
    TypeOfIndexing?: true
    _all?: true
  }

  export type FacultyPublicationLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacultyPublicationLink to aggregate.
     */
    where?: FacultyPublicationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyPublicationLinks to fetch.
     */
    orderBy?: FacultyPublicationLinkOrderByWithRelationInput | FacultyPublicationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultyPublicationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyPublicationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyPublicationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacultyPublicationLinks
    **/
    _count?: true | FacultyPublicationLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacultyPublicationLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacultyPublicationLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyPublicationLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyPublicationLinkMaxAggregateInputType
  }

  export type GetFacultyPublicationLinkAggregateType<T extends FacultyPublicationLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateFacultyPublicationLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacultyPublicationLink[P]>
      : GetScalarType<T[P], AggregateFacultyPublicationLink[P]>
  }




  export type FacultyPublicationLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyPublicationLinkWhereInput
    orderBy?: FacultyPublicationLinkOrderByWithAggregationInput | FacultyPublicationLinkOrderByWithAggregationInput[]
    by: FacultyPublicationLinkScalarFieldEnum[] | FacultyPublicationLinkScalarFieldEnum
    having?: FacultyPublicationLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyPublicationLinkCountAggregateInputType | true
    _avg?: FacultyPublicationLinkAvgAggregateInputType
    _sum?: FacultyPublicationLinkSumAggregateInputType
    _min?: FacultyPublicationLinkMinAggregateInputType
    _max?: FacultyPublicationLinkMaxAggregateInputType
  }

  export type FacultyPublicationLinkGroupByOutputType = {
    PublicationID: number
    FacultyID: number
    TypeOfIndexing: string | null
    _count: FacultyPublicationLinkCountAggregateOutputType | null
    _avg: FacultyPublicationLinkAvgAggregateOutputType | null
    _sum: FacultyPublicationLinkSumAggregateOutputType | null
    _min: FacultyPublicationLinkMinAggregateOutputType | null
    _max: FacultyPublicationLinkMaxAggregateOutputType | null
  }

  type GetFacultyPublicationLinkGroupByPayload<T extends FacultyPublicationLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyPublicationLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyPublicationLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyPublicationLinkGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyPublicationLinkGroupByOutputType[P]>
        }
      >
    >


  export type FacultyPublicationLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    FacultyID?: boolean
    TypeOfIndexing?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facultyPublicationLink"]>

  export type FacultyPublicationLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    FacultyID?: boolean
    TypeOfIndexing?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facultyPublicationLink"]>

  export type FacultyPublicationLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PublicationID?: boolean
    FacultyID?: boolean
    TypeOfIndexing?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facultyPublicationLink"]>

  export type FacultyPublicationLinkSelectScalar = {
    PublicationID?: boolean
    FacultyID?: boolean
    TypeOfIndexing?: boolean
  }

  export type FacultyPublicationLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"PublicationID" | "FacultyID" | "TypeOfIndexing", ExtArgs["result"]["facultyPublicationLink"]>
  export type FacultyPublicationLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }
  export type FacultyPublicationLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }
  export type FacultyPublicationLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Publication?: boolean | PublicationsDefaultArgs<ExtArgs>
  }

  export type $FacultyPublicationLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacultyPublicationLink"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>
      Publication: Prisma.$PublicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      PublicationID: number
      FacultyID: number
      TypeOfIndexing: string | null
    }, ExtArgs["result"]["facultyPublicationLink"]>
    composites: {}
  }

  type FacultyPublicationLinkGetPayload<S extends boolean | null | undefined | FacultyPublicationLinkDefaultArgs> = $Result.GetResult<Prisma.$FacultyPublicationLinkPayload, S>

  type FacultyPublicationLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacultyPublicationLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacultyPublicationLinkCountAggregateInputType | true
    }

  export interface FacultyPublicationLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacultyPublicationLink'], meta: { name: 'FacultyPublicationLink' } }
    /**
     * Find zero or one FacultyPublicationLink that matches the filter.
     * @param {FacultyPublicationLinkFindUniqueArgs} args - Arguments to find a FacultyPublicationLink
     * @example
     * // Get one FacultyPublicationLink
     * const facultyPublicationLink = await prisma.facultyPublicationLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultyPublicationLinkFindUniqueArgs>(args: SelectSubset<T, FacultyPublicationLinkFindUniqueArgs<ExtArgs>>): Prisma__FacultyPublicationLinkClient<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacultyPublicationLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacultyPublicationLinkFindUniqueOrThrowArgs} args - Arguments to find a FacultyPublicationLink
     * @example
     * // Get one FacultyPublicationLink
     * const facultyPublicationLink = await prisma.facultyPublicationLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultyPublicationLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, FacultyPublicationLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacultyPublicationLinkClient<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacultyPublicationLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyPublicationLinkFindFirstArgs} args - Arguments to find a FacultyPublicationLink
     * @example
     * // Get one FacultyPublicationLink
     * const facultyPublicationLink = await prisma.facultyPublicationLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultyPublicationLinkFindFirstArgs>(args?: SelectSubset<T, FacultyPublicationLinkFindFirstArgs<ExtArgs>>): Prisma__FacultyPublicationLinkClient<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacultyPublicationLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyPublicationLinkFindFirstOrThrowArgs} args - Arguments to find a FacultyPublicationLink
     * @example
     * // Get one FacultyPublicationLink
     * const facultyPublicationLink = await prisma.facultyPublicationLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultyPublicationLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, FacultyPublicationLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacultyPublicationLinkClient<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacultyPublicationLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyPublicationLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacultyPublicationLinks
     * const facultyPublicationLinks = await prisma.facultyPublicationLink.findMany()
     * 
     * // Get first 10 FacultyPublicationLinks
     * const facultyPublicationLinks = await prisma.facultyPublicationLink.findMany({ take: 10 })
     * 
     * // Only select the `PublicationID`
     * const facultyPublicationLinkWithPublicationIDOnly = await prisma.facultyPublicationLink.findMany({ select: { PublicationID: true } })
     * 
     */
    findMany<T extends FacultyPublicationLinkFindManyArgs>(args?: SelectSubset<T, FacultyPublicationLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacultyPublicationLink.
     * @param {FacultyPublicationLinkCreateArgs} args - Arguments to create a FacultyPublicationLink.
     * @example
     * // Create one FacultyPublicationLink
     * const FacultyPublicationLink = await prisma.facultyPublicationLink.create({
     *   data: {
     *     // ... data to create a FacultyPublicationLink
     *   }
     * })
     * 
     */
    create<T extends FacultyPublicationLinkCreateArgs>(args: SelectSubset<T, FacultyPublicationLinkCreateArgs<ExtArgs>>): Prisma__FacultyPublicationLinkClient<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacultyPublicationLinks.
     * @param {FacultyPublicationLinkCreateManyArgs} args - Arguments to create many FacultyPublicationLinks.
     * @example
     * // Create many FacultyPublicationLinks
     * const facultyPublicationLink = await prisma.facultyPublicationLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacultyPublicationLinkCreateManyArgs>(args?: SelectSubset<T, FacultyPublicationLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacultyPublicationLinks and returns the data saved in the database.
     * @param {FacultyPublicationLinkCreateManyAndReturnArgs} args - Arguments to create many FacultyPublicationLinks.
     * @example
     * // Create many FacultyPublicationLinks
     * const facultyPublicationLink = await prisma.facultyPublicationLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacultyPublicationLinks and only return the `PublicationID`
     * const facultyPublicationLinkWithPublicationIDOnly = await prisma.facultyPublicationLink.createManyAndReturn({
     *   select: { PublicationID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacultyPublicationLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, FacultyPublicationLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacultyPublicationLink.
     * @param {FacultyPublicationLinkDeleteArgs} args - Arguments to delete one FacultyPublicationLink.
     * @example
     * // Delete one FacultyPublicationLink
     * const FacultyPublicationLink = await prisma.facultyPublicationLink.delete({
     *   where: {
     *     // ... filter to delete one FacultyPublicationLink
     *   }
     * })
     * 
     */
    delete<T extends FacultyPublicationLinkDeleteArgs>(args: SelectSubset<T, FacultyPublicationLinkDeleteArgs<ExtArgs>>): Prisma__FacultyPublicationLinkClient<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacultyPublicationLink.
     * @param {FacultyPublicationLinkUpdateArgs} args - Arguments to update one FacultyPublicationLink.
     * @example
     * // Update one FacultyPublicationLink
     * const facultyPublicationLink = await prisma.facultyPublicationLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacultyPublicationLinkUpdateArgs>(args: SelectSubset<T, FacultyPublicationLinkUpdateArgs<ExtArgs>>): Prisma__FacultyPublicationLinkClient<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacultyPublicationLinks.
     * @param {FacultyPublicationLinkDeleteManyArgs} args - Arguments to filter FacultyPublicationLinks to delete.
     * @example
     * // Delete a few FacultyPublicationLinks
     * const { count } = await prisma.facultyPublicationLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacultyPublicationLinkDeleteManyArgs>(args?: SelectSubset<T, FacultyPublicationLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacultyPublicationLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyPublicationLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacultyPublicationLinks
     * const facultyPublicationLink = await prisma.facultyPublicationLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacultyPublicationLinkUpdateManyArgs>(args: SelectSubset<T, FacultyPublicationLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacultyPublicationLinks and returns the data updated in the database.
     * @param {FacultyPublicationLinkUpdateManyAndReturnArgs} args - Arguments to update many FacultyPublicationLinks.
     * @example
     * // Update many FacultyPublicationLinks
     * const facultyPublicationLink = await prisma.facultyPublicationLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacultyPublicationLinks and only return the `PublicationID`
     * const facultyPublicationLinkWithPublicationIDOnly = await prisma.facultyPublicationLink.updateManyAndReturn({
     *   select: { PublicationID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacultyPublicationLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, FacultyPublicationLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacultyPublicationLink.
     * @param {FacultyPublicationLinkUpsertArgs} args - Arguments to update or create a FacultyPublicationLink.
     * @example
     * // Update or create a FacultyPublicationLink
     * const facultyPublicationLink = await prisma.facultyPublicationLink.upsert({
     *   create: {
     *     // ... data to create a FacultyPublicationLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacultyPublicationLink we want to update
     *   }
     * })
     */
    upsert<T extends FacultyPublicationLinkUpsertArgs>(args: SelectSubset<T, FacultyPublicationLinkUpsertArgs<ExtArgs>>): Prisma__FacultyPublicationLinkClient<$Result.GetResult<Prisma.$FacultyPublicationLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacultyPublicationLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyPublicationLinkCountArgs} args - Arguments to filter FacultyPublicationLinks to count.
     * @example
     * // Count the number of FacultyPublicationLinks
     * const count = await prisma.facultyPublicationLink.count({
     *   where: {
     *     // ... the filter for the FacultyPublicationLinks we want to count
     *   }
     * })
    **/
    count<T extends FacultyPublicationLinkCountArgs>(
      args?: Subset<T, FacultyPublicationLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyPublicationLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacultyPublicationLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyPublicationLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyPublicationLinkAggregateArgs>(args: Subset<T, FacultyPublicationLinkAggregateArgs>): Prisma.PrismaPromise<GetFacultyPublicationLinkAggregateType<T>>

    /**
     * Group by FacultyPublicationLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyPublicationLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyPublicationLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyPublicationLinkGroupByArgs['orderBy'] }
        : { orderBy?: FacultyPublicationLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyPublicationLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyPublicationLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacultyPublicationLink model
   */
  readonly fields: FacultyPublicationLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacultyPublicationLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyPublicationLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Publication<T extends PublicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicationsDefaultArgs<ExtArgs>>): Prisma__PublicationsClient<$Result.GetResult<Prisma.$PublicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacultyPublicationLink model
   */
  interface FacultyPublicationLinkFieldRefs {
    readonly PublicationID: FieldRef<"FacultyPublicationLink", 'Int'>
    readonly FacultyID: FieldRef<"FacultyPublicationLink", 'Int'>
    readonly TypeOfIndexing: FieldRef<"FacultyPublicationLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FacultyPublicationLink findUnique
   */
  export type FacultyPublicationLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    /**
     * Filter, which FacultyPublicationLink to fetch.
     */
    where: FacultyPublicationLinkWhereUniqueInput
  }

  /**
   * FacultyPublicationLink findUniqueOrThrow
   */
  export type FacultyPublicationLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    /**
     * Filter, which FacultyPublicationLink to fetch.
     */
    where: FacultyPublicationLinkWhereUniqueInput
  }

  /**
   * FacultyPublicationLink findFirst
   */
  export type FacultyPublicationLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    /**
     * Filter, which FacultyPublicationLink to fetch.
     */
    where?: FacultyPublicationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyPublicationLinks to fetch.
     */
    orderBy?: FacultyPublicationLinkOrderByWithRelationInput | FacultyPublicationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacultyPublicationLinks.
     */
    cursor?: FacultyPublicationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyPublicationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyPublicationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacultyPublicationLinks.
     */
    distinct?: FacultyPublicationLinkScalarFieldEnum | FacultyPublicationLinkScalarFieldEnum[]
  }

  /**
   * FacultyPublicationLink findFirstOrThrow
   */
  export type FacultyPublicationLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    /**
     * Filter, which FacultyPublicationLink to fetch.
     */
    where?: FacultyPublicationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyPublicationLinks to fetch.
     */
    orderBy?: FacultyPublicationLinkOrderByWithRelationInput | FacultyPublicationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacultyPublicationLinks.
     */
    cursor?: FacultyPublicationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyPublicationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyPublicationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacultyPublicationLinks.
     */
    distinct?: FacultyPublicationLinkScalarFieldEnum | FacultyPublicationLinkScalarFieldEnum[]
  }

  /**
   * FacultyPublicationLink findMany
   */
  export type FacultyPublicationLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    /**
     * Filter, which FacultyPublicationLinks to fetch.
     */
    where?: FacultyPublicationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyPublicationLinks to fetch.
     */
    orderBy?: FacultyPublicationLinkOrderByWithRelationInput | FacultyPublicationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacultyPublicationLinks.
     */
    cursor?: FacultyPublicationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyPublicationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyPublicationLinks.
     */
    skip?: number
    distinct?: FacultyPublicationLinkScalarFieldEnum | FacultyPublicationLinkScalarFieldEnum[]
  }

  /**
   * FacultyPublicationLink create
   */
  export type FacultyPublicationLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a FacultyPublicationLink.
     */
    data: XOR<FacultyPublicationLinkCreateInput, FacultyPublicationLinkUncheckedCreateInput>
  }

  /**
   * FacultyPublicationLink createMany
   */
  export type FacultyPublicationLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacultyPublicationLinks.
     */
    data: FacultyPublicationLinkCreateManyInput | FacultyPublicationLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacultyPublicationLink createManyAndReturn
   */
  export type FacultyPublicationLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * The data used to create many FacultyPublicationLinks.
     */
    data: FacultyPublicationLinkCreateManyInput | FacultyPublicationLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacultyPublicationLink update
   */
  export type FacultyPublicationLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a FacultyPublicationLink.
     */
    data: XOR<FacultyPublicationLinkUpdateInput, FacultyPublicationLinkUncheckedUpdateInput>
    /**
     * Choose, which FacultyPublicationLink to update.
     */
    where: FacultyPublicationLinkWhereUniqueInput
  }

  /**
   * FacultyPublicationLink updateMany
   */
  export type FacultyPublicationLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacultyPublicationLinks.
     */
    data: XOR<FacultyPublicationLinkUpdateManyMutationInput, FacultyPublicationLinkUncheckedUpdateManyInput>
    /**
     * Filter which FacultyPublicationLinks to update
     */
    where?: FacultyPublicationLinkWhereInput
    /**
     * Limit how many FacultyPublicationLinks to update.
     */
    limit?: number
  }

  /**
   * FacultyPublicationLink updateManyAndReturn
   */
  export type FacultyPublicationLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * The data used to update FacultyPublicationLinks.
     */
    data: XOR<FacultyPublicationLinkUpdateManyMutationInput, FacultyPublicationLinkUncheckedUpdateManyInput>
    /**
     * Filter which FacultyPublicationLinks to update
     */
    where?: FacultyPublicationLinkWhereInput
    /**
     * Limit how many FacultyPublicationLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacultyPublicationLink upsert
   */
  export type FacultyPublicationLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the FacultyPublicationLink to update in case it exists.
     */
    where: FacultyPublicationLinkWhereUniqueInput
    /**
     * In case the FacultyPublicationLink found by the `where` argument doesn't exist, create a new FacultyPublicationLink with this data.
     */
    create: XOR<FacultyPublicationLinkCreateInput, FacultyPublicationLinkUncheckedCreateInput>
    /**
     * In case the FacultyPublicationLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyPublicationLinkUpdateInput, FacultyPublicationLinkUncheckedUpdateInput>
  }

  /**
   * FacultyPublicationLink delete
   */
  export type FacultyPublicationLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
    /**
     * Filter which FacultyPublicationLink to delete.
     */
    where: FacultyPublicationLinkWhereUniqueInput
  }

  /**
   * FacultyPublicationLink deleteMany
   */
  export type FacultyPublicationLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacultyPublicationLinks to delete
     */
    where?: FacultyPublicationLinkWhereInput
    /**
     * Limit how many FacultyPublicationLinks to delete.
     */
    limit?: number
  }

  /**
   * FacultyPublicationLink without action
   */
  export type FacultyPublicationLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyPublicationLink
     */
    select?: FacultyPublicationLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyPublicationLink
     */
    omit?: FacultyPublicationLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyPublicationLinkInclude<ExtArgs> | null
  }


  /**
   * Model Patents
   */

  export type AggregatePatents = {
    _count: PatentsCountAggregateOutputType | null
    _avg: PatentsAvgAggregateOutputType | null
    _sum: PatentsSumAggregateOutputType | null
    _min: PatentsMinAggregateOutputType | null
    _max: PatentsMaxAggregateOutputType | null
  }

  export type PatentsAvgAggregateOutputType = {
    FacultyID: number | null
  }

  export type PatentsSumAggregateOutputType = {
    FacultyID: number | null
  }

  export type PatentsMinAggregateOutputType = {
    TypeID: string | null
    FacultyID: number | null
    Title: string | null
    FilingDate: Date | null
    PublicationDate: Date | null
    PatentNumber: string | null
    Authority: string | null
    CollaborationInstitute: string | null
  }

  export type PatentsMaxAggregateOutputType = {
    TypeID: string | null
    FacultyID: number | null
    Title: string | null
    FilingDate: Date | null
    PublicationDate: Date | null
    PatentNumber: string | null
    Authority: string | null
    CollaborationInstitute: string | null
  }

  export type PatentsCountAggregateOutputType = {
    TypeID: number
    FacultyID: number
    Title: number
    FilingDate: number
    PublicationDate: number
    PatentNumber: number
    Authority: number
    CollaborationInstitute: number
    _all: number
  }


  export type PatentsAvgAggregateInputType = {
    FacultyID?: true
  }

  export type PatentsSumAggregateInputType = {
    FacultyID?: true
  }

  export type PatentsMinAggregateInputType = {
    TypeID?: true
    FacultyID?: true
    Title?: true
    FilingDate?: true
    PublicationDate?: true
    PatentNumber?: true
    Authority?: true
    CollaborationInstitute?: true
  }

  export type PatentsMaxAggregateInputType = {
    TypeID?: true
    FacultyID?: true
    Title?: true
    FilingDate?: true
    PublicationDate?: true
    PatentNumber?: true
    Authority?: true
    CollaborationInstitute?: true
  }

  export type PatentsCountAggregateInputType = {
    TypeID?: true
    FacultyID?: true
    Title?: true
    FilingDate?: true
    PublicationDate?: true
    PatentNumber?: true
    Authority?: true
    CollaborationInstitute?: true
    _all?: true
  }

  export type PatentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patents to aggregate.
     */
    where?: PatentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patents to fetch.
     */
    orderBy?: PatentsOrderByWithRelationInput | PatentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patents
    **/
    _count?: true | PatentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatentsMaxAggregateInputType
  }

  export type GetPatentsAggregateType<T extends PatentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatents[P]>
      : GetScalarType<T[P], AggregatePatents[P]>
  }




  export type PatentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatentsWhereInput
    orderBy?: PatentsOrderByWithAggregationInput | PatentsOrderByWithAggregationInput[]
    by: PatentsScalarFieldEnum[] | PatentsScalarFieldEnum
    having?: PatentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatentsCountAggregateInputType | true
    _avg?: PatentsAvgAggregateInputType
    _sum?: PatentsSumAggregateInputType
    _min?: PatentsMinAggregateInputType
    _max?: PatentsMaxAggregateInputType
  }

  export type PatentsGroupByOutputType = {
    TypeID: string
    FacultyID: number
    Title: string
    FilingDate: Date
    PublicationDate: Date | null
    PatentNumber: string
    Authority: string | null
    CollaborationInstitute: string | null
    _count: PatentsCountAggregateOutputType | null
    _avg: PatentsAvgAggregateOutputType | null
    _sum: PatentsSumAggregateOutputType | null
    _min: PatentsMinAggregateOutputType | null
    _max: PatentsMaxAggregateOutputType | null
  }

  type GetPatentsGroupByPayload<T extends PatentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatentsGroupByOutputType[P]>
            : GetScalarType<T[P], PatentsGroupByOutputType[P]>
        }
      >
    >


  export type PatentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TypeID?: boolean
    FacultyID?: boolean
    Title?: boolean
    FilingDate?: boolean
    PublicationDate?: boolean
    PatentNumber?: boolean
    Authority?: boolean
    CollaborationInstitute?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patents"]>

  export type PatentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TypeID?: boolean
    FacultyID?: boolean
    Title?: boolean
    FilingDate?: boolean
    PublicationDate?: boolean
    PatentNumber?: boolean
    Authority?: boolean
    CollaborationInstitute?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patents"]>

  export type PatentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TypeID?: boolean
    FacultyID?: boolean
    Title?: boolean
    FilingDate?: boolean
    PublicationDate?: boolean
    PatentNumber?: boolean
    Authority?: boolean
    CollaborationInstitute?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patents"]>

  export type PatentsSelectScalar = {
    TypeID?: boolean
    FacultyID?: boolean
    Title?: boolean
    FilingDate?: boolean
    PublicationDate?: boolean
    PatentNumber?: boolean
    Authority?: boolean
    CollaborationInstitute?: boolean
  }

  export type PatentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"TypeID" | "FacultyID" | "Title" | "FilingDate" | "PublicationDate" | "PatentNumber" | "Authority" | "CollaborationInstitute", ExtArgs["result"]["patents"]>
  export type PatentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }
  export type PatentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }
  export type PatentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }

  export type $PatentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patents"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>
      Type: Prisma.$TYPESPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      TypeID: string
      FacultyID: number
      Title: string
      FilingDate: Date
      PublicationDate: Date | null
      PatentNumber: string
      Authority: string | null
      CollaborationInstitute: string | null
    }, ExtArgs["result"]["patents"]>
    composites: {}
  }

  type PatentsGetPayload<S extends boolean | null | undefined | PatentsDefaultArgs> = $Result.GetResult<Prisma.$PatentsPayload, S>

  type PatentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatentsCountAggregateInputType | true
    }

  export interface PatentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patents'], meta: { name: 'Patents' } }
    /**
     * Find zero or one Patents that matches the filter.
     * @param {PatentsFindUniqueArgs} args - Arguments to find a Patents
     * @example
     * // Get one Patents
     * const patents = await prisma.patents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatentsFindUniqueArgs>(args: SelectSubset<T, PatentsFindUniqueArgs<ExtArgs>>): Prisma__PatentsClient<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatentsFindUniqueOrThrowArgs} args - Arguments to find a Patents
     * @example
     * // Get one Patents
     * const patents = await prisma.patents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatentsFindUniqueOrThrowArgs>(args: SelectSubset<T, PatentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatentsClient<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsFindFirstArgs} args - Arguments to find a Patents
     * @example
     * // Get one Patents
     * const patents = await prisma.patents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatentsFindFirstArgs>(args?: SelectSubset<T, PatentsFindFirstArgs<ExtArgs>>): Prisma__PatentsClient<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsFindFirstOrThrowArgs} args - Arguments to find a Patents
     * @example
     * // Get one Patents
     * const patents = await prisma.patents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatentsFindFirstOrThrowArgs>(args?: SelectSubset<T, PatentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatentsClient<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patents
     * const patents = await prisma.patents.findMany()
     * 
     * // Get first 10 Patents
     * const patents = await prisma.patents.findMany({ take: 10 })
     * 
     * // Only select the `TypeID`
     * const patentsWithTypeIDOnly = await prisma.patents.findMany({ select: { TypeID: true } })
     * 
     */
    findMany<T extends PatentsFindManyArgs>(args?: SelectSubset<T, PatentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patents.
     * @param {PatentsCreateArgs} args - Arguments to create a Patents.
     * @example
     * // Create one Patents
     * const Patents = await prisma.patents.create({
     *   data: {
     *     // ... data to create a Patents
     *   }
     * })
     * 
     */
    create<T extends PatentsCreateArgs>(args: SelectSubset<T, PatentsCreateArgs<ExtArgs>>): Prisma__PatentsClient<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patents.
     * @param {PatentsCreateManyArgs} args - Arguments to create many Patents.
     * @example
     * // Create many Patents
     * const patents = await prisma.patents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatentsCreateManyArgs>(args?: SelectSubset<T, PatentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patents and returns the data saved in the database.
     * @param {PatentsCreateManyAndReturnArgs} args - Arguments to create many Patents.
     * @example
     * // Create many Patents
     * const patents = await prisma.patents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patents and only return the `TypeID`
     * const patentsWithTypeIDOnly = await prisma.patents.createManyAndReturn({
     *   select: { TypeID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatentsCreateManyAndReturnArgs>(args?: SelectSubset<T, PatentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patents.
     * @param {PatentsDeleteArgs} args - Arguments to delete one Patents.
     * @example
     * // Delete one Patents
     * const Patents = await prisma.patents.delete({
     *   where: {
     *     // ... filter to delete one Patents
     *   }
     * })
     * 
     */
    delete<T extends PatentsDeleteArgs>(args: SelectSubset<T, PatentsDeleteArgs<ExtArgs>>): Prisma__PatentsClient<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patents.
     * @param {PatentsUpdateArgs} args - Arguments to update one Patents.
     * @example
     * // Update one Patents
     * const patents = await prisma.patents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatentsUpdateArgs>(args: SelectSubset<T, PatentsUpdateArgs<ExtArgs>>): Prisma__PatentsClient<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patents.
     * @param {PatentsDeleteManyArgs} args - Arguments to filter Patents to delete.
     * @example
     * // Delete a few Patents
     * const { count } = await prisma.patents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatentsDeleteManyArgs>(args?: SelectSubset<T, PatentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patents
     * const patents = await prisma.patents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatentsUpdateManyArgs>(args: SelectSubset<T, PatentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patents and returns the data updated in the database.
     * @param {PatentsUpdateManyAndReturnArgs} args - Arguments to update many Patents.
     * @example
     * // Update many Patents
     * const patents = await prisma.patents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patents and only return the `TypeID`
     * const patentsWithTypeIDOnly = await prisma.patents.updateManyAndReturn({
     *   select: { TypeID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatentsUpdateManyAndReturnArgs>(args: SelectSubset<T, PatentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patents.
     * @param {PatentsUpsertArgs} args - Arguments to update or create a Patents.
     * @example
     * // Update or create a Patents
     * const patents = await prisma.patents.upsert({
     *   create: {
     *     // ... data to create a Patents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patents we want to update
     *   }
     * })
     */
    upsert<T extends PatentsUpsertArgs>(args: SelectSubset<T, PatentsUpsertArgs<ExtArgs>>): Prisma__PatentsClient<$Result.GetResult<Prisma.$PatentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsCountArgs} args - Arguments to filter Patents to count.
     * @example
     * // Count the number of Patents
     * const count = await prisma.patents.count({
     *   where: {
     *     // ... the filter for the Patents we want to count
     *   }
     * })
    **/
    count<T extends PatentsCountArgs>(
      args?: Subset<T, PatentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatentsAggregateArgs>(args: Subset<T, PatentsAggregateArgs>): Prisma.PrismaPromise<GetPatentsAggregateType<T>>

    /**
     * Group by Patents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatentsGroupByArgs['orderBy'] }
        : { orderBy?: PatentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patents model
   */
  readonly fields: PatentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Type<T extends TYPESDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TYPESDefaultArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patents model
   */
  interface PatentsFieldRefs {
    readonly TypeID: FieldRef<"Patents", 'String'>
    readonly FacultyID: FieldRef<"Patents", 'Int'>
    readonly Title: FieldRef<"Patents", 'String'>
    readonly FilingDate: FieldRef<"Patents", 'DateTime'>
    readonly PublicationDate: FieldRef<"Patents", 'DateTime'>
    readonly PatentNumber: FieldRef<"Patents", 'String'>
    readonly Authority: FieldRef<"Patents", 'String'>
    readonly CollaborationInstitute: FieldRef<"Patents", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patents findUnique
   */
  export type PatentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    /**
     * Filter, which Patents to fetch.
     */
    where: PatentsWhereUniqueInput
  }

  /**
   * Patents findUniqueOrThrow
   */
  export type PatentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    /**
     * Filter, which Patents to fetch.
     */
    where: PatentsWhereUniqueInput
  }

  /**
   * Patents findFirst
   */
  export type PatentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    /**
     * Filter, which Patents to fetch.
     */
    where?: PatentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patents to fetch.
     */
    orderBy?: PatentsOrderByWithRelationInput | PatentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patents.
     */
    cursor?: PatentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patents.
     */
    distinct?: PatentsScalarFieldEnum | PatentsScalarFieldEnum[]
  }

  /**
   * Patents findFirstOrThrow
   */
  export type PatentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    /**
     * Filter, which Patents to fetch.
     */
    where?: PatentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patents to fetch.
     */
    orderBy?: PatentsOrderByWithRelationInput | PatentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patents.
     */
    cursor?: PatentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patents.
     */
    distinct?: PatentsScalarFieldEnum | PatentsScalarFieldEnum[]
  }

  /**
   * Patents findMany
   */
  export type PatentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    /**
     * Filter, which Patents to fetch.
     */
    where?: PatentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patents to fetch.
     */
    orderBy?: PatentsOrderByWithRelationInput | PatentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patents.
     */
    cursor?: PatentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patents.
     */
    skip?: number
    distinct?: PatentsScalarFieldEnum | PatentsScalarFieldEnum[]
  }

  /**
   * Patents create
   */
  export type PatentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Patents.
     */
    data: XOR<PatentsCreateInput, PatentsUncheckedCreateInput>
  }

  /**
   * Patents createMany
   */
  export type PatentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patents.
     */
    data: PatentsCreateManyInput | PatentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patents createManyAndReturn
   */
  export type PatentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * The data used to create many Patents.
     */
    data: PatentsCreateManyInput | PatentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patents update
   */
  export type PatentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Patents.
     */
    data: XOR<PatentsUpdateInput, PatentsUncheckedUpdateInput>
    /**
     * Choose, which Patents to update.
     */
    where: PatentsWhereUniqueInput
  }

  /**
   * Patents updateMany
   */
  export type PatentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patents.
     */
    data: XOR<PatentsUpdateManyMutationInput, PatentsUncheckedUpdateManyInput>
    /**
     * Filter which Patents to update
     */
    where?: PatentsWhereInput
    /**
     * Limit how many Patents to update.
     */
    limit?: number
  }

  /**
   * Patents updateManyAndReturn
   */
  export type PatentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * The data used to update Patents.
     */
    data: XOR<PatentsUpdateManyMutationInput, PatentsUncheckedUpdateManyInput>
    /**
     * Filter which Patents to update
     */
    where?: PatentsWhereInput
    /**
     * Limit how many Patents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patents upsert
   */
  export type PatentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Patents to update in case it exists.
     */
    where: PatentsWhereUniqueInput
    /**
     * In case the Patents found by the `where` argument doesn't exist, create a new Patents with this data.
     */
    create: XOR<PatentsCreateInput, PatentsUncheckedCreateInput>
    /**
     * In case the Patents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatentsUpdateInput, PatentsUncheckedUpdateInput>
  }

  /**
   * Patents delete
   */
  export type PatentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
    /**
     * Filter which Patents to delete.
     */
    where: PatentsWhereUniqueInput
  }

  /**
   * Patents deleteMany
   */
  export type PatentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patents to delete
     */
    where?: PatentsWhereInput
    /**
     * Limit how many Patents to delete.
     */
    limit?: number
  }

  /**
   * Patents without action
   */
  export type PatentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null
  }


  /**
   * Model ResearchProjects
   */

  export type AggregateResearchProjects = {
    _count: ResearchProjectsCountAggregateOutputType | null
    _avg: ResearchProjectsAvgAggregateOutputType | null
    _sum: ResearchProjectsSumAggregateOutputType | null
    _min: ResearchProjectsMinAggregateOutputType | null
    _max: ResearchProjectsMaxAggregateOutputType | null
  }

  export type ResearchProjectsAvgAggregateOutputType = {
    FacultyID: number | null
    Budget: Decimal | null
  }

  export type ResearchProjectsSumAggregateOutputType = {
    FacultyID: number | null
    Budget: Decimal | null
  }

  export type ResearchProjectsMinAggregateOutputType = {
    TypeID: string | null
    FacultyID: number | null
    Title: string | null
    FundingAgency: string | null
    StartDate: Date | null
    EndDate: Date | null
    Budget: Decimal | null
  }

  export type ResearchProjectsMaxAggregateOutputType = {
    TypeID: string | null
    FacultyID: number | null
    Title: string | null
    FundingAgency: string | null
    StartDate: Date | null
    EndDate: Date | null
    Budget: Decimal | null
  }

  export type ResearchProjectsCountAggregateOutputType = {
    TypeID: number
    FacultyID: number
    Title: number
    FundingAgency: number
    StartDate: number
    EndDate: number
    Budget: number
    _all: number
  }


  export type ResearchProjectsAvgAggregateInputType = {
    FacultyID?: true
    Budget?: true
  }

  export type ResearchProjectsSumAggregateInputType = {
    FacultyID?: true
    Budget?: true
  }

  export type ResearchProjectsMinAggregateInputType = {
    TypeID?: true
    FacultyID?: true
    Title?: true
    FundingAgency?: true
    StartDate?: true
    EndDate?: true
    Budget?: true
  }

  export type ResearchProjectsMaxAggregateInputType = {
    TypeID?: true
    FacultyID?: true
    Title?: true
    FundingAgency?: true
    StartDate?: true
    EndDate?: true
    Budget?: true
  }

  export type ResearchProjectsCountAggregateInputType = {
    TypeID?: true
    FacultyID?: true
    Title?: true
    FundingAgency?: true
    StartDate?: true
    EndDate?: true
    Budget?: true
    _all?: true
  }

  export type ResearchProjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchProjects to aggregate.
     */
    where?: ResearchProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProjects to fetch.
     */
    orderBy?: ResearchProjectsOrderByWithRelationInput | ResearchProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResearchProjects
    **/
    _count?: true | ResearchProjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchProjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchProjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchProjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchProjectsMaxAggregateInputType
  }

  export type GetResearchProjectsAggregateType<T extends ResearchProjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchProjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchProjects[P]>
      : GetScalarType<T[P], AggregateResearchProjects[P]>
  }




  export type ResearchProjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchProjectsWhereInput
    orderBy?: ResearchProjectsOrderByWithAggregationInput | ResearchProjectsOrderByWithAggregationInput[]
    by: ResearchProjectsScalarFieldEnum[] | ResearchProjectsScalarFieldEnum
    having?: ResearchProjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchProjectsCountAggregateInputType | true
    _avg?: ResearchProjectsAvgAggregateInputType
    _sum?: ResearchProjectsSumAggregateInputType
    _min?: ResearchProjectsMinAggregateInputType
    _max?: ResearchProjectsMaxAggregateInputType
  }

  export type ResearchProjectsGroupByOutputType = {
    TypeID: string
    FacultyID: number
    Title: string
    FundingAgency: string | null
    StartDate: Date
    EndDate: Date | null
    Budget: Decimal | null
    _count: ResearchProjectsCountAggregateOutputType | null
    _avg: ResearchProjectsAvgAggregateOutputType | null
    _sum: ResearchProjectsSumAggregateOutputType | null
    _min: ResearchProjectsMinAggregateOutputType | null
    _max: ResearchProjectsMaxAggregateOutputType | null
  }

  type GetResearchProjectsGroupByPayload<T extends ResearchProjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchProjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchProjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchProjectsGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchProjectsGroupByOutputType[P]>
        }
      >
    >


  export type ResearchProjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TypeID?: boolean
    FacultyID?: boolean
    Title?: boolean
    FundingAgency?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Budget?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchProjects"]>

  export type ResearchProjectsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TypeID?: boolean
    FacultyID?: boolean
    Title?: boolean
    FundingAgency?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Budget?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchProjects"]>

  export type ResearchProjectsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TypeID?: boolean
    FacultyID?: boolean
    Title?: boolean
    FundingAgency?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Budget?: boolean
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchProjects"]>

  export type ResearchProjectsSelectScalar = {
    TypeID?: boolean
    FacultyID?: boolean
    Title?: boolean
    FundingAgency?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Budget?: boolean
  }

  export type ResearchProjectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"TypeID" | "FacultyID" | "Title" | "FundingAgency" | "StartDate" | "EndDate" | "Budget", ExtArgs["result"]["researchProjects"]>
  export type ResearchProjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }
  export type ResearchProjectsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }
  export type ResearchProjectsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    Type?: boolean | TYPESDefaultArgs<ExtArgs>
  }

  export type $ResearchProjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResearchProjects"
    objects: {
      Faculty: Prisma.$FacultyPayload<ExtArgs>
      Type: Prisma.$TYPESPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      TypeID: string
      FacultyID: number
      Title: string
      FundingAgency: string | null
      StartDate: Date
      EndDate: Date | null
      Budget: Prisma.Decimal | null
    }, ExtArgs["result"]["researchProjects"]>
    composites: {}
  }

  type ResearchProjectsGetPayload<S extends boolean | null | undefined | ResearchProjectsDefaultArgs> = $Result.GetResult<Prisma.$ResearchProjectsPayload, S>

  type ResearchProjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResearchProjectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResearchProjectsCountAggregateInputType | true
    }

  export interface ResearchProjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResearchProjects'], meta: { name: 'ResearchProjects' } }
    /**
     * Find zero or one ResearchProjects that matches the filter.
     * @param {ResearchProjectsFindUniqueArgs} args - Arguments to find a ResearchProjects
     * @example
     * // Get one ResearchProjects
     * const researchProjects = await prisma.researchProjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchProjectsFindUniqueArgs>(args: SelectSubset<T, ResearchProjectsFindUniqueArgs<ExtArgs>>): Prisma__ResearchProjectsClient<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResearchProjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResearchProjectsFindUniqueOrThrowArgs} args - Arguments to find a ResearchProjects
     * @example
     * // Get one ResearchProjects
     * const researchProjects = await prisma.researchProjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchProjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchProjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchProjectsClient<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResearchProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectsFindFirstArgs} args - Arguments to find a ResearchProjects
     * @example
     * // Get one ResearchProjects
     * const researchProjects = await prisma.researchProjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchProjectsFindFirstArgs>(args?: SelectSubset<T, ResearchProjectsFindFirstArgs<ExtArgs>>): Prisma__ResearchProjectsClient<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResearchProjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectsFindFirstOrThrowArgs} args - Arguments to find a ResearchProjects
     * @example
     * // Get one ResearchProjects
     * const researchProjects = await prisma.researchProjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchProjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchProjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchProjectsClient<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResearchProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResearchProjects
     * const researchProjects = await prisma.researchProjects.findMany()
     * 
     * // Get first 10 ResearchProjects
     * const researchProjects = await prisma.researchProjects.findMany({ take: 10 })
     * 
     * // Only select the `TypeID`
     * const researchProjectsWithTypeIDOnly = await prisma.researchProjects.findMany({ select: { TypeID: true } })
     * 
     */
    findMany<T extends ResearchProjectsFindManyArgs>(args?: SelectSubset<T, ResearchProjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResearchProjects.
     * @param {ResearchProjectsCreateArgs} args - Arguments to create a ResearchProjects.
     * @example
     * // Create one ResearchProjects
     * const ResearchProjects = await prisma.researchProjects.create({
     *   data: {
     *     // ... data to create a ResearchProjects
     *   }
     * })
     * 
     */
    create<T extends ResearchProjectsCreateArgs>(args: SelectSubset<T, ResearchProjectsCreateArgs<ExtArgs>>): Prisma__ResearchProjectsClient<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResearchProjects.
     * @param {ResearchProjectsCreateManyArgs} args - Arguments to create many ResearchProjects.
     * @example
     * // Create many ResearchProjects
     * const researchProjects = await prisma.researchProjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchProjectsCreateManyArgs>(args?: SelectSubset<T, ResearchProjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResearchProjects and returns the data saved in the database.
     * @param {ResearchProjectsCreateManyAndReturnArgs} args - Arguments to create many ResearchProjects.
     * @example
     * // Create many ResearchProjects
     * const researchProjects = await prisma.researchProjects.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResearchProjects and only return the `TypeID`
     * const researchProjectsWithTypeIDOnly = await prisma.researchProjects.createManyAndReturn({
     *   select: { TypeID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchProjectsCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchProjectsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResearchProjects.
     * @param {ResearchProjectsDeleteArgs} args - Arguments to delete one ResearchProjects.
     * @example
     * // Delete one ResearchProjects
     * const ResearchProjects = await prisma.researchProjects.delete({
     *   where: {
     *     // ... filter to delete one ResearchProjects
     *   }
     * })
     * 
     */
    delete<T extends ResearchProjectsDeleteArgs>(args: SelectSubset<T, ResearchProjectsDeleteArgs<ExtArgs>>): Prisma__ResearchProjectsClient<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResearchProjects.
     * @param {ResearchProjectsUpdateArgs} args - Arguments to update one ResearchProjects.
     * @example
     * // Update one ResearchProjects
     * const researchProjects = await prisma.researchProjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchProjectsUpdateArgs>(args: SelectSubset<T, ResearchProjectsUpdateArgs<ExtArgs>>): Prisma__ResearchProjectsClient<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResearchProjects.
     * @param {ResearchProjectsDeleteManyArgs} args - Arguments to filter ResearchProjects to delete.
     * @example
     * // Delete a few ResearchProjects
     * const { count } = await prisma.researchProjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchProjectsDeleteManyArgs>(args?: SelectSubset<T, ResearchProjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResearchProjects
     * const researchProjects = await prisma.researchProjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchProjectsUpdateManyArgs>(args: SelectSubset<T, ResearchProjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchProjects and returns the data updated in the database.
     * @param {ResearchProjectsUpdateManyAndReturnArgs} args - Arguments to update many ResearchProjects.
     * @example
     * // Update many ResearchProjects
     * const researchProjects = await prisma.researchProjects.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResearchProjects and only return the `TypeID`
     * const researchProjectsWithTypeIDOnly = await prisma.researchProjects.updateManyAndReturn({
     *   select: { TypeID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResearchProjectsUpdateManyAndReturnArgs>(args: SelectSubset<T, ResearchProjectsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResearchProjects.
     * @param {ResearchProjectsUpsertArgs} args - Arguments to update or create a ResearchProjects.
     * @example
     * // Update or create a ResearchProjects
     * const researchProjects = await prisma.researchProjects.upsert({
     *   create: {
     *     // ... data to create a ResearchProjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResearchProjects we want to update
     *   }
     * })
     */
    upsert<T extends ResearchProjectsUpsertArgs>(args: SelectSubset<T, ResearchProjectsUpsertArgs<ExtArgs>>): Prisma__ResearchProjectsClient<$Result.GetResult<Prisma.$ResearchProjectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResearchProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectsCountArgs} args - Arguments to filter ResearchProjects to count.
     * @example
     * // Count the number of ResearchProjects
     * const count = await prisma.researchProjects.count({
     *   where: {
     *     // ... the filter for the ResearchProjects we want to count
     *   }
     * })
    **/
    count<T extends ResearchProjectsCountArgs>(
      args?: Subset<T, ResearchProjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchProjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResearchProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchProjectsAggregateArgs>(args: Subset<T, ResearchProjectsAggregateArgs>): Prisma.PrismaPromise<GetResearchProjectsAggregateType<T>>

    /**
     * Group by ResearchProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchProjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchProjectsGroupByArgs['orderBy'] }
        : { orderBy?: ResearchProjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchProjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchProjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResearchProjects model
   */
  readonly fields: ResearchProjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResearchProjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchProjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Type<T extends TYPESDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TYPESDefaultArgs<ExtArgs>>): Prisma__TYPESClient<$Result.GetResult<Prisma.$TYPESPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResearchProjects model
   */
  interface ResearchProjectsFieldRefs {
    readonly TypeID: FieldRef<"ResearchProjects", 'String'>
    readonly FacultyID: FieldRef<"ResearchProjects", 'Int'>
    readonly Title: FieldRef<"ResearchProjects", 'String'>
    readonly FundingAgency: FieldRef<"ResearchProjects", 'String'>
    readonly StartDate: FieldRef<"ResearchProjects", 'DateTime'>
    readonly EndDate: FieldRef<"ResearchProjects", 'DateTime'>
    readonly Budget: FieldRef<"ResearchProjects", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ResearchProjects findUnique
   */
  export type ResearchProjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProjects to fetch.
     */
    where: ResearchProjectsWhereUniqueInput
  }

  /**
   * ResearchProjects findUniqueOrThrow
   */
  export type ResearchProjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProjects to fetch.
     */
    where: ResearchProjectsWhereUniqueInput
  }

  /**
   * ResearchProjects findFirst
   */
  export type ResearchProjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProjects to fetch.
     */
    where?: ResearchProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProjects to fetch.
     */
    orderBy?: ResearchProjectsOrderByWithRelationInput | ResearchProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchProjects.
     */
    cursor?: ResearchProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchProjects.
     */
    distinct?: ResearchProjectsScalarFieldEnum | ResearchProjectsScalarFieldEnum[]
  }

  /**
   * ResearchProjects findFirstOrThrow
   */
  export type ResearchProjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProjects to fetch.
     */
    where?: ResearchProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProjects to fetch.
     */
    orderBy?: ResearchProjectsOrderByWithRelationInput | ResearchProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchProjects.
     */
    cursor?: ResearchProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchProjects.
     */
    distinct?: ResearchProjectsScalarFieldEnum | ResearchProjectsScalarFieldEnum[]
  }

  /**
   * ResearchProjects findMany
   */
  export type ResearchProjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProjects to fetch.
     */
    where?: ResearchProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProjects to fetch.
     */
    orderBy?: ResearchProjectsOrderByWithRelationInput | ResearchProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResearchProjects.
     */
    cursor?: ResearchProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProjects.
     */
    skip?: number
    distinct?: ResearchProjectsScalarFieldEnum | ResearchProjectsScalarFieldEnum[]
  }

  /**
   * ResearchProjects create
   */
  export type ResearchProjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a ResearchProjects.
     */
    data: XOR<ResearchProjectsCreateInput, ResearchProjectsUncheckedCreateInput>
  }

  /**
   * ResearchProjects createMany
   */
  export type ResearchProjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResearchProjects.
     */
    data: ResearchProjectsCreateManyInput | ResearchProjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResearchProjects createManyAndReturn
   */
  export type ResearchProjectsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * The data used to create many ResearchProjects.
     */
    data: ResearchProjectsCreateManyInput | ResearchProjectsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchProjects update
   */
  export type ResearchProjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a ResearchProjects.
     */
    data: XOR<ResearchProjectsUpdateInput, ResearchProjectsUncheckedUpdateInput>
    /**
     * Choose, which ResearchProjects to update.
     */
    where: ResearchProjectsWhereUniqueInput
  }

  /**
   * ResearchProjects updateMany
   */
  export type ResearchProjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResearchProjects.
     */
    data: XOR<ResearchProjectsUpdateManyMutationInput, ResearchProjectsUncheckedUpdateManyInput>
    /**
     * Filter which ResearchProjects to update
     */
    where?: ResearchProjectsWhereInput
    /**
     * Limit how many ResearchProjects to update.
     */
    limit?: number
  }

  /**
   * ResearchProjects updateManyAndReturn
   */
  export type ResearchProjectsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * The data used to update ResearchProjects.
     */
    data: XOR<ResearchProjectsUpdateManyMutationInput, ResearchProjectsUncheckedUpdateManyInput>
    /**
     * Filter which ResearchProjects to update
     */
    where?: ResearchProjectsWhereInput
    /**
     * Limit how many ResearchProjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchProjects upsert
   */
  export type ResearchProjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the ResearchProjects to update in case it exists.
     */
    where: ResearchProjectsWhereUniqueInput
    /**
     * In case the ResearchProjects found by the `where` argument doesn't exist, create a new ResearchProjects with this data.
     */
    create: XOR<ResearchProjectsCreateInput, ResearchProjectsUncheckedCreateInput>
    /**
     * In case the ResearchProjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchProjectsUpdateInput, ResearchProjectsUncheckedUpdateInput>
  }

  /**
   * ResearchProjects delete
   */
  export type ResearchProjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
    /**
     * Filter which ResearchProjects to delete.
     */
    where: ResearchProjectsWhereUniqueInput
  }

  /**
   * ResearchProjects deleteMany
   */
  export type ResearchProjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchProjects to delete
     */
    where?: ResearchProjectsWhereInput
    /**
     * Limit how many ResearchProjects to delete.
     */
    limit?: number
  }

  /**
   * ResearchProjects without action
   */
  export type ResearchProjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjects
     */
    select?: ResearchProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchProjects
     */
    omit?: ResearchProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DepartmentScalarFieldEnum: {
    DepartmentID: 'DepartmentID',
    DepartmentName: 'DepartmentName'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const FacultyScalarFieldEnum: {
    FacultyID: 'FacultyID',
    FirstName: 'FirstName',
    LastName: 'LastName',
    Gender: 'Gender',
    DOB: 'DOB',
    Role: 'Role',
    Phone_no: 'Phone_no',
    Email: 'Email',
    DepartmentID: 'DepartmentID'
  };

  export type FacultyScalarFieldEnum = (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum]


  export const SubjectTaughtScalarFieldEnum: {
    FacultyID: 'FacultyID',
    Level: 'Level',
    SubjectName: 'SubjectName',
    CourseCode: 'CourseCode',
    ProgramName: 'ProgramName',
    Note: 'Note'
  };

  export type SubjectTaughtScalarFieldEnum = (typeof SubjectTaughtScalarFieldEnum)[keyof typeof SubjectTaughtScalarFieldEnum]


  export const FacultyQualificationScalarFieldEnum: {
    QualificationID: 'QualificationID',
    FacultyID: 'FacultyID',
    Degree: 'Degree',
    Institution: 'Institution',
    YearOfCompletion: 'YearOfCompletion'
  };

  export type FacultyQualificationScalarFieldEnum = (typeof FacultyQualificationScalarFieldEnum)[keyof typeof FacultyQualificationScalarFieldEnum]


  export const OutReachActivitiesScalarFieldEnum: {
    ActivityID: 'ActivityID',
    FacultyID: 'FacultyID',
    ActivityType: 'ActivityType',
    ActivityTitle: 'ActivityTitle',
    InstitutionName: 'InstitutionName',
    ActivityDate: 'ActivityDate',
    Description: 'Description'
  };

  export type OutReachActivitiesScalarFieldEnum = (typeof OutReachActivitiesScalarFieldEnum)[keyof typeof OutReachActivitiesScalarFieldEnum]


  export const EventTypeScalarFieldEnum: {
    EventID: 'EventID',
    EventType: 'EventType'
  };

  export type EventTypeScalarFieldEnum = (typeof EventTypeScalarFieldEnum)[keyof typeof EventTypeScalarFieldEnum]


  export const EventsOrganisedScalarFieldEnum: {
    FacultyID: 'FacultyID',
    Event_id: 'Event_id',
    Title: 'Title',
    Organizer: 'Organizer',
    Location: 'Location',
    StartDate: 'StartDate',
    EndDate: 'EndDate',
    Description: 'Description',
    Role: 'Role',
    FundingAgency: 'FundingAgency'
  };

  export type EventsOrganisedScalarFieldEnum = (typeof EventsOrganisedScalarFieldEnum)[keyof typeof EventsOrganisedScalarFieldEnum]


  export const AwardsScalarFieldEnum: {
    AwardID: 'AwardID',
    FacultyID: 'FacultyID',
    AwardName: 'AwardName',
    AwardingBody: 'AwardingBody',
    Location: 'Location',
    YearAwarded: 'YearAwarded'
  };

  export type AwardsScalarFieldEnum = (typeof AwardsScalarFieldEnum)[keyof typeof AwardsScalarFieldEnum]


  export const TeachingExperienceScalarFieldEnum: {
    ExperienceID: 'ExperienceID',
    FacultyID: 'FacultyID',
    OrganizationName: 'OrganizationName',
    Designation: 'Designation',
    StartDate: 'StartDate',
    EndDate: 'EndDate',
    NatureOfWork: 'NatureOfWork'
  };

  export type TeachingExperienceScalarFieldEnum = (typeof TeachingExperienceScalarFieldEnum)[keyof typeof TeachingExperienceScalarFieldEnum]


  export const CitationMetricsScalarFieldEnum: {
    MetricsID: 'MetricsID',
    FacultyID: 'FacultyID',
    YearRecorded: 'YearRecorded',
    Source: 'Source',
    HIndex: 'HIndex',
    I10Index: 'I10Index',
    TotalCitations: 'TotalCitations',
    ImpactFactor: 'ImpactFactor'
  };

  export type CitationMetricsScalarFieldEnum = (typeof CitationMetricsScalarFieldEnum)[keyof typeof CitationMetricsScalarFieldEnum]


  export const TYPESScalarFieldEnum: {
    TypeID: 'TypeID',
    Type: 'Type',
    Status: 'Status'
  };

  export type TYPESScalarFieldEnum = (typeof TYPESScalarFieldEnum)[keyof typeof TYPESScalarFieldEnum]


  export const PublicationsScalarFieldEnum: {
    PublicationID: 'PublicationID',
    TypeID: 'TypeID',
    Authors: 'Authors',
    Title: 'Title',
    PublicationYear: 'PublicationYear',
    FundingAgency: 'FundingAgency'
  };

  export type PublicationsScalarFieldEnum = (typeof PublicationsScalarFieldEnum)[keyof typeof PublicationsScalarFieldEnum]


  export const JournalPublicationDetailsScalarFieldEnum: {
    PublicationID: 'PublicationID',
    Name: 'Name',
    VolumeNumber: 'VolumeNumber',
    IssueNumber: 'IssueNumber',
    ISSN_Number: 'ISSN_Number'
  };

  export type JournalPublicationDetailsScalarFieldEnum = (typeof JournalPublicationDetailsScalarFieldEnum)[keyof typeof JournalPublicationDetailsScalarFieldEnum]


  export const BookPublicationDetailsScalarFieldEnum: {
    PublicationID: 'PublicationID',
    Publisher: 'Publisher',
    Edition: 'Edition',
    VolumeNumber: 'VolumeNumber',
    ISBN_Number: 'ISBN_Number'
  };

  export type BookPublicationDetailsScalarFieldEnum = (typeof BookPublicationDetailsScalarFieldEnum)[keyof typeof BookPublicationDetailsScalarFieldEnum]


  export const ConferencePaperDetailsScalarFieldEnum: {
    PublicationID: 'PublicationID',
    Publisher: 'Publisher',
    Location: 'Location',
    PageNumbers: 'PageNumbers'
  };

  export type ConferencePaperDetailsScalarFieldEnum = (typeof ConferencePaperDetailsScalarFieldEnum)[keyof typeof ConferencePaperDetailsScalarFieldEnum]


  export const FacultyPublicationLinkScalarFieldEnum: {
    PublicationID: 'PublicationID',
    FacultyID: 'FacultyID',
    TypeOfIndexing: 'TypeOfIndexing'
  };

  export type FacultyPublicationLinkScalarFieldEnum = (typeof FacultyPublicationLinkScalarFieldEnum)[keyof typeof FacultyPublicationLinkScalarFieldEnum]


  export const PatentsScalarFieldEnum: {
    TypeID: 'TypeID',
    FacultyID: 'FacultyID',
    Title: 'Title',
    FilingDate: 'FilingDate',
    PublicationDate: 'PublicationDate',
    PatentNumber: 'PatentNumber',
    Authority: 'Authority',
    CollaborationInstitute: 'CollaborationInstitute'
  };

  export type PatentsScalarFieldEnum = (typeof PatentsScalarFieldEnum)[keyof typeof PatentsScalarFieldEnum]


  export const ResearchProjectsScalarFieldEnum: {
    TypeID: 'TypeID',
    FacultyID: 'FacultyID',
    Title: 'Title',
    FundingAgency: 'FundingAgency',
    StartDate: 'StartDate',
    EndDate: 'EndDate',
    Budget: 'Budget'
  };

  export type ResearchProjectsScalarFieldEnum = (typeof ResearchProjectsScalarFieldEnum)[keyof typeof ResearchProjectsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'event_type'
   */
  export type Enumevent_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'event_type'>
    


  /**
   * Reference to a field of type 'event_type[]'
   */
  export type ListEnumevent_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'event_type[]'>
    


  /**
   * Reference to a field of type 'role_type'
   */
  export type Enumrole_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'role_type'>
    


  /**
   * Reference to a field of type 'role_type[]'
   */
  export type ListEnumrole_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'role_type[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'publication_type'
   */
  export type Enumpublication_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'publication_type'>
    


  /**
   * Reference to a field of type 'publication_type[]'
   */
  export type ListEnumpublication_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'publication_type[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    DepartmentID?: IntFilter<"Department"> | number
    DepartmentName?: StringFilter<"Department"> | string
    Faculty?: FacultyListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    DepartmentID?: SortOrder
    DepartmentName?: SortOrder
    Faculty?: FacultyOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    DepartmentID?: number
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    DepartmentName?: StringFilter<"Department"> | string
    Faculty?: FacultyListRelationFilter
  }, "DepartmentID">

  export type DepartmentOrderByWithAggregationInput = {
    DepartmentID?: SortOrder
    DepartmentName?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    DepartmentID?: IntWithAggregatesFilter<"Department"> | number
    DepartmentName?: StringWithAggregatesFilter<"Department"> | string
  }

  export type FacultyWhereInput = {
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    FacultyID?: IntFilter<"Faculty"> | number
    FirstName?: StringFilter<"Faculty"> | string
    LastName?: StringFilter<"Faculty"> | string
    Gender?: StringFilter<"Faculty"> | string
    DOB?: DateTimeFilter<"Faculty"> | Date | string
    Role?: StringFilter<"Faculty"> | string
    Phone_no?: StringFilter<"Faculty"> | string
    Email?: StringFilter<"Faculty"> | string
    DepartmentID?: IntFilter<"Faculty"> | number
    Department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    SubjectsTaught?: SubjectTaughtListRelationFilter
    Qualifications?: FacultyQualificationListRelationFilter
    OutreachActivities?: OutReachActivitiesListRelationFilter
    EventsOrganised?: EventsOrganisedListRelationFilter
    Awards?: AwardsListRelationFilter
    TeachingExperiences?: TeachingExperienceListRelationFilter
    CitationMetrics?: CitationMetricsListRelationFilter
    Publications?: FacultyPublicationLinkListRelationFilter
    Patents?: PatentsListRelationFilter
    ResearchProjects?: ResearchProjectsListRelationFilter
  }

  export type FacultyOrderByWithRelationInput = {
    FacultyID?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    DOB?: SortOrder
    Role?: SortOrder
    Phone_no?: SortOrder
    Email?: SortOrder
    DepartmentID?: SortOrder
    Department?: DepartmentOrderByWithRelationInput
    SubjectsTaught?: SubjectTaughtOrderByRelationAggregateInput
    Qualifications?: FacultyQualificationOrderByRelationAggregateInput
    OutreachActivities?: OutReachActivitiesOrderByRelationAggregateInput
    EventsOrganised?: EventsOrganisedOrderByRelationAggregateInput
    Awards?: AwardsOrderByRelationAggregateInput
    TeachingExperiences?: TeachingExperienceOrderByRelationAggregateInput
    CitationMetrics?: CitationMetricsOrderByRelationAggregateInput
    Publications?: FacultyPublicationLinkOrderByRelationAggregateInput
    Patents?: PatentsOrderByRelationAggregateInput
    ResearchProjects?: ResearchProjectsOrderByRelationAggregateInput
  }

  export type FacultyWhereUniqueInput = Prisma.AtLeast<{
    FacultyID?: number
    Email?: string
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    FirstName?: StringFilter<"Faculty"> | string
    LastName?: StringFilter<"Faculty"> | string
    Gender?: StringFilter<"Faculty"> | string
    DOB?: DateTimeFilter<"Faculty"> | Date | string
    Role?: StringFilter<"Faculty"> | string
    Phone_no?: StringFilter<"Faculty"> | string
    DepartmentID?: IntFilter<"Faculty"> | number
    Department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    SubjectsTaught?: SubjectTaughtListRelationFilter
    Qualifications?: FacultyQualificationListRelationFilter
    OutreachActivities?: OutReachActivitiesListRelationFilter
    EventsOrganised?: EventsOrganisedListRelationFilter
    Awards?: AwardsListRelationFilter
    TeachingExperiences?: TeachingExperienceListRelationFilter
    CitationMetrics?: CitationMetricsListRelationFilter
    Publications?: FacultyPublicationLinkListRelationFilter
    Patents?: PatentsListRelationFilter
    ResearchProjects?: ResearchProjectsListRelationFilter
  }, "FacultyID" | "Email">

  export type FacultyOrderByWithAggregationInput = {
    FacultyID?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    DOB?: SortOrder
    Role?: SortOrder
    Phone_no?: SortOrder
    Email?: SortOrder
    DepartmentID?: SortOrder
    _count?: FacultyCountOrderByAggregateInput
    _avg?: FacultyAvgOrderByAggregateInput
    _max?: FacultyMaxOrderByAggregateInput
    _min?: FacultyMinOrderByAggregateInput
    _sum?: FacultySumOrderByAggregateInput
  }

  export type FacultyScalarWhereWithAggregatesInput = {
    AND?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    OR?: FacultyScalarWhereWithAggregatesInput[]
    NOT?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    FacultyID?: IntWithAggregatesFilter<"Faculty"> | number
    FirstName?: StringWithAggregatesFilter<"Faculty"> | string
    LastName?: StringWithAggregatesFilter<"Faculty"> | string
    Gender?: StringWithAggregatesFilter<"Faculty"> | string
    DOB?: DateTimeWithAggregatesFilter<"Faculty"> | Date | string
    Role?: StringWithAggregatesFilter<"Faculty"> | string
    Phone_no?: StringWithAggregatesFilter<"Faculty"> | string
    Email?: StringWithAggregatesFilter<"Faculty"> | string
    DepartmentID?: IntWithAggregatesFilter<"Faculty"> | number
  }

  export type SubjectTaughtWhereInput = {
    AND?: SubjectTaughtWhereInput | SubjectTaughtWhereInput[]
    OR?: SubjectTaughtWhereInput[]
    NOT?: SubjectTaughtWhereInput | SubjectTaughtWhereInput[]
    FacultyID?: IntFilter<"SubjectTaught"> | number
    Level?: StringFilter<"SubjectTaught"> | string
    SubjectName?: StringFilter<"SubjectTaught"> | string
    CourseCode?: StringNullableFilter<"SubjectTaught"> | string | null
    ProgramName?: StringNullableFilter<"SubjectTaught"> | string | null
    Note?: StringNullableFilter<"SubjectTaught"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }

  export type SubjectTaughtOrderByWithRelationInput = {
    FacultyID?: SortOrder
    Level?: SortOrder
    SubjectName?: SortOrder
    CourseCode?: SortOrderInput | SortOrder
    ProgramName?: SortOrderInput | SortOrder
    Note?: SortOrderInput | SortOrder
    Faculty?: FacultyOrderByWithRelationInput
  }

  export type SubjectTaughtWhereUniqueInput = Prisma.AtLeast<{
    FacultyID_Level_SubjectName?: SubjectTaughtFacultyIDLevelSubjectNameCompoundUniqueInput
    AND?: SubjectTaughtWhereInput | SubjectTaughtWhereInput[]
    OR?: SubjectTaughtWhereInput[]
    NOT?: SubjectTaughtWhereInput | SubjectTaughtWhereInput[]
    FacultyID?: IntFilter<"SubjectTaught"> | number
    Level?: StringFilter<"SubjectTaught"> | string
    SubjectName?: StringFilter<"SubjectTaught"> | string
    CourseCode?: StringNullableFilter<"SubjectTaught"> | string | null
    ProgramName?: StringNullableFilter<"SubjectTaught"> | string | null
    Note?: StringNullableFilter<"SubjectTaught"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }, "FacultyID_Level_SubjectName">

  export type SubjectTaughtOrderByWithAggregationInput = {
    FacultyID?: SortOrder
    Level?: SortOrder
    SubjectName?: SortOrder
    CourseCode?: SortOrderInput | SortOrder
    ProgramName?: SortOrderInput | SortOrder
    Note?: SortOrderInput | SortOrder
    _count?: SubjectTaughtCountOrderByAggregateInput
    _avg?: SubjectTaughtAvgOrderByAggregateInput
    _max?: SubjectTaughtMaxOrderByAggregateInput
    _min?: SubjectTaughtMinOrderByAggregateInput
    _sum?: SubjectTaughtSumOrderByAggregateInput
  }

  export type SubjectTaughtScalarWhereWithAggregatesInput = {
    AND?: SubjectTaughtScalarWhereWithAggregatesInput | SubjectTaughtScalarWhereWithAggregatesInput[]
    OR?: SubjectTaughtScalarWhereWithAggregatesInput[]
    NOT?: SubjectTaughtScalarWhereWithAggregatesInput | SubjectTaughtScalarWhereWithAggregatesInput[]
    FacultyID?: IntWithAggregatesFilter<"SubjectTaught"> | number
    Level?: StringWithAggregatesFilter<"SubjectTaught"> | string
    SubjectName?: StringWithAggregatesFilter<"SubjectTaught"> | string
    CourseCode?: StringNullableWithAggregatesFilter<"SubjectTaught"> | string | null
    ProgramName?: StringNullableWithAggregatesFilter<"SubjectTaught"> | string | null
    Note?: StringNullableWithAggregatesFilter<"SubjectTaught"> | string | null
  }

  export type FacultyQualificationWhereInput = {
    AND?: FacultyQualificationWhereInput | FacultyQualificationWhereInput[]
    OR?: FacultyQualificationWhereInput[]
    NOT?: FacultyQualificationWhereInput | FacultyQualificationWhereInput[]
    QualificationID?: IntFilter<"FacultyQualification"> | number
    FacultyID?: IntFilter<"FacultyQualification"> | number
    Degree?: StringFilter<"FacultyQualification"> | string
    Institution?: StringFilter<"FacultyQualification"> | string
    YearOfCompletion?: DateTimeFilter<"FacultyQualification"> | Date | string
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }

  export type FacultyQualificationOrderByWithRelationInput = {
    QualificationID?: SortOrder
    FacultyID?: SortOrder
    Degree?: SortOrder
    Institution?: SortOrder
    YearOfCompletion?: SortOrder
    Faculty?: FacultyOrderByWithRelationInput
  }

  export type FacultyQualificationWhereUniqueInput = Prisma.AtLeast<{
    QualificationID?: number
    AND?: FacultyQualificationWhereInput | FacultyQualificationWhereInput[]
    OR?: FacultyQualificationWhereInput[]
    NOT?: FacultyQualificationWhereInput | FacultyQualificationWhereInput[]
    FacultyID?: IntFilter<"FacultyQualification"> | number
    Degree?: StringFilter<"FacultyQualification"> | string
    Institution?: StringFilter<"FacultyQualification"> | string
    YearOfCompletion?: DateTimeFilter<"FacultyQualification"> | Date | string
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }, "QualificationID">

  export type FacultyQualificationOrderByWithAggregationInput = {
    QualificationID?: SortOrder
    FacultyID?: SortOrder
    Degree?: SortOrder
    Institution?: SortOrder
    YearOfCompletion?: SortOrder
    _count?: FacultyQualificationCountOrderByAggregateInput
    _avg?: FacultyQualificationAvgOrderByAggregateInput
    _max?: FacultyQualificationMaxOrderByAggregateInput
    _min?: FacultyQualificationMinOrderByAggregateInput
    _sum?: FacultyQualificationSumOrderByAggregateInput
  }

  export type FacultyQualificationScalarWhereWithAggregatesInput = {
    AND?: FacultyQualificationScalarWhereWithAggregatesInput | FacultyQualificationScalarWhereWithAggregatesInput[]
    OR?: FacultyQualificationScalarWhereWithAggregatesInput[]
    NOT?: FacultyQualificationScalarWhereWithAggregatesInput | FacultyQualificationScalarWhereWithAggregatesInput[]
    QualificationID?: IntWithAggregatesFilter<"FacultyQualification"> | number
    FacultyID?: IntWithAggregatesFilter<"FacultyQualification"> | number
    Degree?: StringWithAggregatesFilter<"FacultyQualification"> | string
    Institution?: StringWithAggregatesFilter<"FacultyQualification"> | string
    YearOfCompletion?: DateTimeWithAggregatesFilter<"FacultyQualification"> | Date | string
  }

  export type OutReachActivitiesWhereInput = {
    AND?: OutReachActivitiesWhereInput | OutReachActivitiesWhereInput[]
    OR?: OutReachActivitiesWhereInput[]
    NOT?: OutReachActivitiesWhereInput | OutReachActivitiesWhereInput[]
    ActivityID?: IntFilter<"OutReachActivities"> | number
    FacultyID?: IntFilter<"OutReachActivities"> | number
    ActivityType?: StringFilter<"OutReachActivities"> | string
    ActivityTitle?: StringFilter<"OutReachActivities"> | string
    InstitutionName?: StringNullableFilter<"OutReachActivities"> | string | null
    ActivityDate?: DateTimeFilter<"OutReachActivities"> | Date | string
    Description?: StringNullableFilter<"OutReachActivities"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }

  export type OutReachActivitiesOrderByWithRelationInput = {
    ActivityID?: SortOrder
    FacultyID?: SortOrder
    ActivityType?: SortOrder
    ActivityTitle?: SortOrder
    InstitutionName?: SortOrderInput | SortOrder
    ActivityDate?: SortOrder
    Description?: SortOrderInput | SortOrder
    Faculty?: FacultyOrderByWithRelationInput
  }

  export type OutReachActivitiesWhereUniqueInput = Prisma.AtLeast<{
    ActivityID?: number
    AND?: OutReachActivitiesWhereInput | OutReachActivitiesWhereInput[]
    OR?: OutReachActivitiesWhereInput[]
    NOT?: OutReachActivitiesWhereInput | OutReachActivitiesWhereInput[]
    FacultyID?: IntFilter<"OutReachActivities"> | number
    ActivityType?: StringFilter<"OutReachActivities"> | string
    ActivityTitle?: StringFilter<"OutReachActivities"> | string
    InstitutionName?: StringNullableFilter<"OutReachActivities"> | string | null
    ActivityDate?: DateTimeFilter<"OutReachActivities"> | Date | string
    Description?: StringNullableFilter<"OutReachActivities"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }, "ActivityID">

  export type OutReachActivitiesOrderByWithAggregationInput = {
    ActivityID?: SortOrder
    FacultyID?: SortOrder
    ActivityType?: SortOrder
    ActivityTitle?: SortOrder
    InstitutionName?: SortOrderInput | SortOrder
    ActivityDate?: SortOrder
    Description?: SortOrderInput | SortOrder
    _count?: OutReachActivitiesCountOrderByAggregateInput
    _avg?: OutReachActivitiesAvgOrderByAggregateInput
    _max?: OutReachActivitiesMaxOrderByAggregateInput
    _min?: OutReachActivitiesMinOrderByAggregateInput
    _sum?: OutReachActivitiesSumOrderByAggregateInput
  }

  export type OutReachActivitiesScalarWhereWithAggregatesInput = {
    AND?: OutReachActivitiesScalarWhereWithAggregatesInput | OutReachActivitiesScalarWhereWithAggregatesInput[]
    OR?: OutReachActivitiesScalarWhereWithAggregatesInput[]
    NOT?: OutReachActivitiesScalarWhereWithAggregatesInput | OutReachActivitiesScalarWhereWithAggregatesInput[]
    ActivityID?: IntWithAggregatesFilter<"OutReachActivities"> | number
    FacultyID?: IntWithAggregatesFilter<"OutReachActivities"> | number
    ActivityType?: StringWithAggregatesFilter<"OutReachActivities"> | string
    ActivityTitle?: StringWithAggregatesFilter<"OutReachActivities"> | string
    InstitutionName?: StringNullableWithAggregatesFilter<"OutReachActivities"> | string | null
    ActivityDate?: DateTimeWithAggregatesFilter<"OutReachActivities"> | Date | string
    Description?: StringNullableWithAggregatesFilter<"OutReachActivities"> | string | null
  }

  export type EventTypeWhereInput = {
    AND?: EventTypeWhereInput | EventTypeWhereInput[]
    OR?: EventTypeWhereInput[]
    NOT?: EventTypeWhereInput | EventTypeWhereInput[]
    EventID?: IntFilter<"EventType"> | number
    EventType?: Enumevent_typeFilter<"EventType"> | $Enums.event_type
    EventsOrganised?: EventsOrganisedListRelationFilter
  }

  export type EventTypeOrderByWithRelationInput = {
    EventID?: SortOrder
    EventType?: SortOrder
    EventsOrganised?: EventsOrganisedOrderByRelationAggregateInput
  }

  export type EventTypeWhereUniqueInput = Prisma.AtLeast<{
    EventID?: number
    AND?: EventTypeWhereInput | EventTypeWhereInput[]
    OR?: EventTypeWhereInput[]
    NOT?: EventTypeWhereInput | EventTypeWhereInput[]
    EventType?: Enumevent_typeFilter<"EventType"> | $Enums.event_type
    EventsOrganised?: EventsOrganisedListRelationFilter
  }, "EventID">

  export type EventTypeOrderByWithAggregationInput = {
    EventID?: SortOrder
    EventType?: SortOrder
    _count?: EventTypeCountOrderByAggregateInput
    _avg?: EventTypeAvgOrderByAggregateInput
    _max?: EventTypeMaxOrderByAggregateInput
    _min?: EventTypeMinOrderByAggregateInput
    _sum?: EventTypeSumOrderByAggregateInput
  }

  export type EventTypeScalarWhereWithAggregatesInput = {
    AND?: EventTypeScalarWhereWithAggregatesInput | EventTypeScalarWhereWithAggregatesInput[]
    OR?: EventTypeScalarWhereWithAggregatesInput[]
    NOT?: EventTypeScalarWhereWithAggregatesInput | EventTypeScalarWhereWithAggregatesInput[]
    EventID?: IntWithAggregatesFilter<"EventType"> | number
    EventType?: Enumevent_typeWithAggregatesFilter<"EventType"> | $Enums.event_type
  }

  export type EventsOrganisedWhereInput = {
    AND?: EventsOrganisedWhereInput | EventsOrganisedWhereInput[]
    OR?: EventsOrganisedWhereInput[]
    NOT?: EventsOrganisedWhereInput | EventsOrganisedWhereInput[]
    FacultyID?: IntFilter<"EventsOrganised"> | number
    Event_id?: IntFilter<"EventsOrganised"> | number
    Title?: StringFilter<"EventsOrganised"> | string
    Organizer?: StringNullableFilter<"EventsOrganised"> | string | null
    Location?: StringNullableFilter<"EventsOrganised"> | string | null
    StartDate?: DateTimeNullableFilter<"EventsOrganised"> | Date | string | null
    EndDate?: DateTimeNullableFilter<"EventsOrganised"> | Date | string | null
    Description?: StringNullableFilter<"EventsOrganised"> | string | null
    Role?: Enumrole_typeNullableFilter<"EventsOrganised"> | $Enums.role_type | null
    FundingAgency?: StringNullableFilter<"EventsOrganised"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    Event?: XOR<EventTypeScalarRelationFilter, EventTypeWhereInput>
  }

  export type EventsOrganisedOrderByWithRelationInput = {
    FacultyID?: SortOrder
    Event_id?: SortOrder
    Title?: SortOrder
    Organizer?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    StartDate?: SortOrderInput | SortOrder
    EndDate?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    Role?: SortOrderInput | SortOrder
    FundingAgency?: SortOrderInput | SortOrder
    Faculty?: FacultyOrderByWithRelationInput
    Event?: EventTypeOrderByWithRelationInput
  }

  export type EventsOrganisedWhereUniqueInput = Prisma.AtLeast<{
    FacultyID_Event_id?: EventsOrganisedFacultyIDEvent_idCompoundUniqueInput
    AND?: EventsOrganisedWhereInput | EventsOrganisedWhereInput[]
    OR?: EventsOrganisedWhereInput[]
    NOT?: EventsOrganisedWhereInput | EventsOrganisedWhereInput[]
    FacultyID?: IntFilter<"EventsOrganised"> | number
    Event_id?: IntFilter<"EventsOrganised"> | number
    Title?: StringFilter<"EventsOrganised"> | string
    Organizer?: StringNullableFilter<"EventsOrganised"> | string | null
    Location?: StringNullableFilter<"EventsOrganised"> | string | null
    StartDate?: DateTimeNullableFilter<"EventsOrganised"> | Date | string | null
    EndDate?: DateTimeNullableFilter<"EventsOrganised"> | Date | string | null
    Description?: StringNullableFilter<"EventsOrganised"> | string | null
    Role?: Enumrole_typeNullableFilter<"EventsOrganised"> | $Enums.role_type | null
    FundingAgency?: StringNullableFilter<"EventsOrganised"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    Event?: XOR<EventTypeScalarRelationFilter, EventTypeWhereInput>
  }, "FacultyID_Event_id">

  export type EventsOrganisedOrderByWithAggregationInput = {
    FacultyID?: SortOrder
    Event_id?: SortOrder
    Title?: SortOrder
    Organizer?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    StartDate?: SortOrderInput | SortOrder
    EndDate?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    Role?: SortOrderInput | SortOrder
    FundingAgency?: SortOrderInput | SortOrder
    _count?: EventsOrganisedCountOrderByAggregateInput
    _avg?: EventsOrganisedAvgOrderByAggregateInput
    _max?: EventsOrganisedMaxOrderByAggregateInput
    _min?: EventsOrganisedMinOrderByAggregateInput
    _sum?: EventsOrganisedSumOrderByAggregateInput
  }

  export type EventsOrganisedScalarWhereWithAggregatesInput = {
    AND?: EventsOrganisedScalarWhereWithAggregatesInput | EventsOrganisedScalarWhereWithAggregatesInput[]
    OR?: EventsOrganisedScalarWhereWithAggregatesInput[]
    NOT?: EventsOrganisedScalarWhereWithAggregatesInput | EventsOrganisedScalarWhereWithAggregatesInput[]
    FacultyID?: IntWithAggregatesFilter<"EventsOrganised"> | number
    Event_id?: IntWithAggregatesFilter<"EventsOrganised"> | number
    Title?: StringWithAggregatesFilter<"EventsOrganised"> | string
    Organizer?: StringNullableWithAggregatesFilter<"EventsOrganised"> | string | null
    Location?: StringNullableWithAggregatesFilter<"EventsOrganised"> | string | null
    StartDate?: DateTimeNullableWithAggregatesFilter<"EventsOrganised"> | Date | string | null
    EndDate?: DateTimeNullableWithAggregatesFilter<"EventsOrganised"> | Date | string | null
    Description?: StringNullableWithAggregatesFilter<"EventsOrganised"> | string | null
    Role?: Enumrole_typeNullableWithAggregatesFilter<"EventsOrganised"> | $Enums.role_type | null
    FundingAgency?: StringNullableWithAggregatesFilter<"EventsOrganised"> | string | null
  }

  export type AwardsWhereInput = {
    AND?: AwardsWhereInput | AwardsWhereInput[]
    OR?: AwardsWhereInput[]
    NOT?: AwardsWhereInput | AwardsWhereInput[]
    AwardID?: IntFilter<"Awards"> | number
    FacultyID?: IntFilter<"Awards"> | number
    AwardName?: StringFilter<"Awards"> | string
    AwardingBody?: StringNullableFilter<"Awards"> | string | null
    Location?: StringNullableFilter<"Awards"> | string | null
    YearAwarded?: IntFilter<"Awards"> | number
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }

  export type AwardsOrderByWithRelationInput = {
    AwardID?: SortOrder
    FacultyID?: SortOrder
    AwardName?: SortOrder
    AwardingBody?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    YearAwarded?: SortOrder
    Faculty?: FacultyOrderByWithRelationInput
  }

  export type AwardsWhereUniqueInput = Prisma.AtLeast<{
    AwardID?: number
    AND?: AwardsWhereInput | AwardsWhereInput[]
    OR?: AwardsWhereInput[]
    NOT?: AwardsWhereInput | AwardsWhereInput[]
    FacultyID?: IntFilter<"Awards"> | number
    AwardName?: StringFilter<"Awards"> | string
    AwardingBody?: StringNullableFilter<"Awards"> | string | null
    Location?: StringNullableFilter<"Awards"> | string | null
    YearAwarded?: IntFilter<"Awards"> | number
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }, "AwardID">

  export type AwardsOrderByWithAggregationInput = {
    AwardID?: SortOrder
    FacultyID?: SortOrder
    AwardName?: SortOrder
    AwardingBody?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    YearAwarded?: SortOrder
    _count?: AwardsCountOrderByAggregateInput
    _avg?: AwardsAvgOrderByAggregateInput
    _max?: AwardsMaxOrderByAggregateInput
    _min?: AwardsMinOrderByAggregateInput
    _sum?: AwardsSumOrderByAggregateInput
  }

  export type AwardsScalarWhereWithAggregatesInput = {
    AND?: AwardsScalarWhereWithAggregatesInput | AwardsScalarWhereWithAggregatesInput[]
    OR?: AwardsScalarWhereWithAggregatesInput[]
    NOT?: AwardsScalarWhereWithAggregatesInput | AwardsScalarWhereWithAggregatesInput[]
    AwardID?: IntWithAggregatesFilter<"Awards"> | number
    FacultyID?: IntWithAggregatesFilter<"Awards"> | number
    AwardName?: StringWithAggregatesFilter<"Awards"> | string
    AwardingBody?: StringNullableWithAggregatesFilter<"Awards"> | string | null
    Location?: StringNullableWithAggregatesFilter<"Awards"> | string | null
    YearAwarded?: IntWithAggregatesFilter<"Awards"> | number
  }

  export type TeachingExperienceWhereInput = {
    AND?: TeachingExperienceWhereInput | TeachingExperienceWhereInput[]
    OR?: TeachingExperienceWhereInput[]
    NOT?: TeachingExperienceWhereInput | TeachingExperienceWhereInput[]
    ExperienceID?: IntFilter<"TeachingExperience"> | number
    FacultyID?: IntFilter<"TeachingExperience"> | number
    OrganizationName?: StringFilter<"TeachingExperience"> | string
    Designation?: StringFilter<"TeachingExperience"> | string
    StartDate?: DateTimeFilter<"TeachingExperience"> | Date | string
    EndDate?: StringNullableFilter<"TeachingExperience"> | string | null
    NatureOfWork?: StringNullableFilter<"TeachingExperience"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }

  export type TeachingExperienceOrderByWithRelationInput = {
    ExperienceID?: SortOrder
    FacultyID?: SortOrder
    OrganizationName?: SortOrder
    Designation?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrderInput | SortOrder
    NatureOfWork?: SortOrderInput | SortOrder
    Faculty?: FacultyOrderByWithRelationInput
  }

  export type TeachingExperienceWhereUniqueInput = Prisma.AtLeast<{
    ExperienceID?: number
    AND?: TeachingExperienceWhereInput | TeachingExperienceWhereInput[]
    OR?: TeachingExperienceWhereInput[]
    NOT?: TeachingExperienceWhereInput | TeachingExperienceWhereInput[]
    FacultyID?: IntFilter<"TeachingExperience"> | number
    OrganizationName?: StringFilter<"TeachingExperience"> | string
    Designation?: StringFilter<"TeachingExperience"> | string
    StartDate?: DateTimeFilter<"TeachingExperience"> | Date | string
    EndDate?: StringNullableFilter<"TeachingExperience"> | string | null
    NatureOfWork?: StringNullableFilter<"TeachingExperience"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }, "ExperienceID">

  export type TeachingExperienceOrderByWithAggregationInput = {
    ExperienceID?: SortOrder
    FacultyID?: SortOrder
    OrganizationName?: SortOrder
    Designation?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrderInput | SortOrder
    NatureOfWork?: SortOrderInput | SortOrder
    _count?: TeachingExperienceCountOrderByAggregateInput
    _avg?: TeachingExperienceAvgOrderByAggregateInput
    _max?: TeachingExperienceMaxOrderByAggregateInput
    _min?: TeachingExperienceMinOrderByAggregateInput
    _sum?: TeachingExperienceSumOrderByAggregateInput
  }

  export type TeachingExperienceScalarWhereWithAggregatesInput = {
    AND?: TeachingExperienceScalarWhereWithAggregatesInput | TeachingExperienceScalarWhereWithAggregatesInput[]
    OR?: TeachingExperienceScalarWhereWithAggregatesInput[]
    NOT?: TeachingExperienceScalarWhereWithAggregatesInput | TeachingExperienceScalarWhereWithAggregatesInput[]
    ExperienceID?: IntWithAggregatesFilter<"TeachingExperience"> | number
    FacultyID?: IntWithAggregatesFilter<"TeachingExperience"> | number
    OrganizationName?: StringWithAggregatesFilter<"TeachingExperience"> | string
    Designation?: StringWithAggregatesFilter<"TeachingExperience"> | string
    StartDate?: DateTimeWithAggregatesFilter<"TeachingExperience"> | Date | string
    EndDate?: StringNullableWithAggregatesFilter<"TeachingExperience"> | string | null
    NatureOfWork?: StringNullableWithAggregatesFilter<"TeachingExperience"> | string | null
  }

  export type CitationMetricsWhereInput = {
    AND?: CitationMetricsWhereInput | CitationMetricsWhereInput[]
    OR?: CitationMetricsWhereInput[]
    NOT?: CitationMetricsWhereInput | CitationMetricsWhereInput[]
    MetricsID?: IntFilter<"CitationMetrics"> | number
    FacultyID?: IntFilter<"CitationMetrics"> | number
    YearRecorded?: IntFilter<"CitationMetrics"> | number
    Source?: StringFilter<"CitationMetrics"> | string
    HIndex?: IntNullableFilter<"CitationMetrics"> | number | null
    I10Index?: IntNullableFilter<"CitationMetrics"> | number | null
    TotalCitations?: IntNullableFilter<"CitationMetrics"> | number | null
    ImpactFactor?: DecimalNullableFilter<"CitationMetrics"> | Decimal | DecimalJsLike | number | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }

  export type CitationMetricsOrderByWithRelationInput = {
    MetricsID?: SortOrder
    FacultyID?: SortOrder
    YearRecorded?: SortOrder
    Source?: SortOrder
    HIndex?: SortOrderInput | SortOrder
    I10Index?: SortOrderInput | SortOrder
    TotalCitations?: SortOrderInput | SortOrder
    ImpactFactor?: SortOrderInput | SortOrder
    Faculty?: FacultyOrderByWithRelationInput
  }

  export type CitationMetricsWhereUniqueInput = Prisma.AtLeast<{
    MetricsID?: number
    AND?: CitationMetricsWhereInput | CitationMetricsWhereInput[]
    OR?: CitationMetricsWhereInput[]
    NOT?: CitationMetricsWhereInput | CitationMetricsWhereInput[]
    FacultyID?: IntFilter<"CitationMetrics"> | number
    YearRecorded?: IntFilter<"CitationMetrics"> | number
    Source?: StringFilter<"CitationMetrics"> | string
    HIndex?: IntNullableFilter<"CitationMetrics"> | number | null
    I10Index?: IntNullableFilter<"CitationMetrics"> | number | null
    TotalCitations?: IntNullableFilter<"CitationMetrics"> | number | null
    ImpactFactor?: DecimalNullableFilter<"CitationMetrics"> | Decimal | DecimalJsLike | number | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }, "MetricsID">

  export type CitationMetricsOrderByWithAggregationInput = {
    MetricsID?: SortOrder
    FacultyID?: SortOrder
    YearRecorded?: SortOrder
    Source?: SortOrder
    HIndex?: SortOrderInput | SortOrder
    I10Index?: SortOrderInput | SortOrder
    TotalCitations?: SortOrderInput | SortOrder
    ImpactFactor?: SortOrderInput | SortOrder
    _count?: CitationMetricsCountOrderByAggregateInput
    _avg?: CitationMetricsAvgOrderByAggregateInput
    _max?: CitationMetricsMaxOrderByAggregateInput
    _min?: CitationMetricsMinOrderByAggregateInput
    _sum?: CitationMetricsSumOrderByAggregateInput
  }

  export type CitationMetricsScalarWhereWithAggregatesInput = {
    AND?: CitationMetricsScalarWhereWithAggregatesInput | CitationMetricsScalarWhereWithAggregatesInput[]
    OR?: CitationMetricsScalarWhereWithAggregatesInput[]
    NOT?: CitationMetricsScalarWhereWithAggregatesInput | CitationMetricsScalarWhereWithAggregatesInput[]
    MetricsID?: IntWithAggregatesFilter<"CitationMetrics"> | number
    FacultyID?: IntWithAggregatesFilter<"CitationMetrics"> | number
    YearRecorded?: IntWithAggregatesFilter<"CitationMetrics"> | number
    Source?: StringWithAggregatesFilter<"CitationMetrics"> | string
    HIndex?: IntNullableWithAggregatesFilter<"CitationMetrics"> | number | null
    I10Index?: IntNullableWithAggregatesFilter<"CitationMetrics"> | number | null
    TotalCitations?: IntNullableWithAggregatesFilter<"CitationMetrics"> | number | null
    ImpactFactor?: DecimalNullableWithAggregatesFilter<"CitationMetrics"> | Decimal | DecimalJsLike | number | string | null
  }

  export type TYPESWhereInput = {
    AND?: TYPESWhereInput | TYPESWhereInput[]
    OR?: TYPESWhereInput[]
    NOT?: TYPESWhereInput | TYPESWhereInput[]
    TypeID?: StringFilter<"TYPES"> | string
    Type?: Enumpublication_typeFilter<"TYPES"> | $Enums.publication_type
    Status?: StringNullableFilter<"TYPES"> | string | null
    Publications?: PublicationsListRelationFilter
    Patents?: PatentsListRelationFilter
    ResearchProjects?: ResearchProjectsListRelationFilter
  }

  export type TYPESOrderByWithRelationInput = {
    TypeID?: SortOrder
    Type?: SortOrder
    Status?: SortOrderInput | SortOrder
    Publications?: PublicationsOrderByRelationAggregateInput
    Patents?: PatentsOrderByRelationAggregateInput
    ResearchProjects?: ResearchProjectsOrderByRelationAggregateInput
  }

  export type TYPESWhereUniqueInput = Prisma.AtLeast<{
    TypeID?: string
    AND?: TYPESWhereInput | TYPESWhereInput[]
    OR?: TYPESWhereInput[]
    NOT?: TYPESWhereInput | TYPESWhereInput[]
    Type?: Enumpublication_typeFilter<"TYPES"> | $Enums.publication_type
    Status?: StringNullableFilter<"TYPES"> | string | null
    Publications?: PublicationsListRelationFilter
    Patents?: PatentsListRelationFilter
    ResearchProjects?: ResearchProjectsListRelationFilter
  }, "TypeID">

  export type TYPESOrderByWithAggregationInput = {
    TypeID?: SortOrder
    Type?: SortOrder
    Status?: SortOrderInput | SortOrder
    _count?: TYPESCountOrderByAggregateInput
    _max?: TYPESMaxOrderByAggregateInput
    _min?: TYPESMinOrderByAggregateInput
  }

  export type TYPESScalarWhereWithAggregatesInput = {
    AND?: TYPESScalarWhereWithAggregatesInput | TYPESScalarWhereWithAggregatesInput[]
    OR?: TYPESScalarWhereWithAggregatesInput[]
    NOT?: TYPESScalarWhereWithAggregatesInput | TYPESScalarWhereWithAggregatesInput[]
    TypeID?: StringWithAggregatesFilter<"TYPES"> | string
    Type?: Enumpublication_typeWithAggregatesFilter<"TYPES"> | $Enums.publication_type
    Status?: StringNullableWithAggregatesFilter<"TYPES"> | string | null
  }

  export type PublicationsWhereInput = {
    AND?: PublicationsWhereInput | PublicationsWhereInput[]
    OR?: PublicationsWhereInput[]
    NOT?: PublicationsWhereInput | PublicationsWhereInput[]
    PublicationID?: IntFilter<"Publications"> | number
    TypeID?: StringFilter<"Publications"> | string
    Authors?: StringFilter<"Publications"> | string
    Title?: StringFilter<"Publications"> | string
    PublicationYear?: DateTimeFilter<"Publications"> | Date | string
    FundingAgency?: StringNullableFilter<"Publications"> | string | null
    Type?: XOR<TYPESScalarRelationFilter, TYPESWhereInput>
    JournalPublicationDetails?: XOR<JournalPublicationDetailsNullableScalarRelationFilter, JournalPublicationDetailsWhereInput> | null
    BookPublicationDetails?: XOR<BookPublicationDetailsNullableScalarRelationFilter, BookPublicationDetailsWhereInput> | null
    ConferencePaperDetails?: XOR<ConferencePaperDetailsNullableScalarRelationFilter, ConferencePaperDetailsWhereInput> | null
    FacultyPublicationLink?: FacultyPublicationLinkListRelationFilter
  }

  export type PublicationsOrderByWithRelationInput = {
    PublicationID?: SortOrder
    TypeID?: SortOrder
    Authors?: SortOrder
    Title?: SortOrder
    PublicationYear?: SortOrder
    FundingAgency?: SortOrderInput | SortOrder
    Type?: TYPESOrderByWithRelationInput
    JournalPublicationDetails?: JournalPublicationDetailsOrderByWithRelationInput
    BookPublicationDetails?: BookPublicationDetailsOrderByWithRelationInput
    ConferencePaperDetails?: ConferencePaperDetailsOrderByWithRelationInput
    FacultyPublicationLink?: FacultyPublicationLinkOrderByRelationAggregateInput
  }

  export type PublicationsWhereUniqueInput = Prisma.AtLeast<{
    PublicationID?: number
    AND?: PublicationsWhereInput | PublicationsWhereInput[]
    OR?: PublicationsWhereInput[]
    NOT?: PublicationsWhereInput | PublicationsWhereInput[]
    TypeID?: StringFilter<"Publications"> | string
    Authors?: StringFilter<"Publications"> | string
    Title?: StringFilter<"Publications"> | string
    PublicationYear?: DateTimeFilter<"Publications"> | Date | string
    FundingAgency?: StringNullableFilter<"Publications"> | string | null
    Type?: XOR<TYPESScalarRelationFilter, TYPESWhereInput>
    JournalPublicationDetails?: XOR<JournalPublicationDetailsNullableScalarRelationFilter, JournalPublicationDetailsWhereInput> | null
    BookPublicationDetails?: XOR<BookPublicationDetailsNullableScalarRelationFilter, BookPublicationDetailsWhereInput> | null
    ConferencePaperDetails?: XOR<ConferencePaperDetailsNullableScalarRelationFilter, ConferencePaperDetailsWhereInput> | null
    FacultyPublicationLink?: FacultyPublicationLinkListRelationFilter
  }, "PublicationID">

  export type PublicationsOrderByWithAggregationInput = {
    PublicationID?: SortOrder
    TypeID?: SortOrder
    Authors?: SortOrder
    Title?: SortOrder
    PublicationYear?: SortOrder
    FundingAgency?: SortOrderInput | SortOrder
    _count?: PublicationsCountOrderByAggregateInput
    _avg?: PublicationsAvgOrderByAggregateInput
    _max?: PublicationsMaxOrderByAggregateInput
    _min?: PublicationsMinOrderByAggregateInput
    _sum?: PublicationsSumOrderByAggregateInput
  }

  export type PublicationsScalarWhereWithAggregatesInput = {
    AND?: PublicationsScalarWhereWithAggregatesInput | PublicationsScalarWhereWithAggregatesInput[]
    OR?: PublicationsScalarWhereWithAggregatesInput[]
    NOT?: PublicationsScalarWhereWithAggregatesInput | PublicationsScalarWhereWithAggregatesInput[]
    PublicationID?: IntWithAggregatesFilter<"Publications"> | number
    TypeID?: StringWithAggregatesFilter<"Publications"> | string
    Authors?: StringWithAggregatesFilter<"Publications"> | string
    Title?: StringWithAggregatesFilter<"Publications"> | string
    PublicationYear?: DateTimeWithAggregatesFilter<"Publications"> | Date | string
    FundingAgency?: StringNullableWithAggregatesFilter<"Publications"> | string | null
  }

  export type JournalPublicationDetailsWhereInput = {
    AND?: JournalPublicationDetailsWhereInput | JournalPublicationDetailsWhereInput[]
    OR?: JournalPublicationDetailsWhereInput[]
    NOT?: JournalPublicationDetailsWhereInput | JournalPublicationDetailsWhereInput[]
    PublicationID?: IntFilter<"JournalPublicationDetails"> | number
    Name?: StringNullableFilter<"JournalPublicationDetails"> | string | null
    VolumeNumber?: StringNullableFilter<"JournalPublicationDetails"> | string | null
    IssueNumber?: StringNullableFilter<"JournalPublicationDetails"> | string | null
    ISSN_Number?: IntNullableFilter<"JournalPublicationDetails"> | number | null
    Publication?: XOR<PublicationsScalarRelationFilter, PublicationsWhereInput>
  }

  export type JournalPublicationDetailsOrderByWithRelationInput = {
    PublicationID?: SortOrder
    Name?: SortOrderInput | SortOrder
    VolumeNumber?: SortOrderInput | SortOrder
    IssueNumber?: SortOrderInput | SortOrder
    ISSN_Number?: SortOrderInput | SortOrder
    Publication?: PublicationsOrderByWithRelationInput
  }

  export type JournalPublicationDetailsWhereUniqueInput = Prisma.AtLeast<{
    PublicationID?: number
    AND?: JournalPublicationDetailsWhereInput | JournalPublicationDetailsWhereInput[]
    OR?: JournalPublicationDetailsWhereInput[]
    NOT?: JournalPublicationDetailsWhereInput | JournalPublicationDetailsWhereInput[]
    Name?: StringNullableFilter<"JournalPublicationDetails"> | string | null
    VolumeNumber?: StringNullableFilter<"JournalPublicationDetails"> | string | null
    IssueNumber?: StringNullableFilter<"JournalPublicationDetails"> | string | null
    ISSN_Number?: IntNullableFilter<"JournalPublicationDetails"> | number | null
    Publication?: XOR<PublicationsScalarRelationFilter, PublicationsWhereInput>
  }, "PublicationID">

  export type JournalPublicationDetailsOrderByWithAggregationInput = {
    PublicationID?: SortOrder
    Name?: SortOrderInput | SortOrder
    VolumeNumber?: SortOrderInput | SortOrder
    IssueNumber?: SortOrderInput | SortOrder
    ISSN_Number?: SortOrderInput | SortOrder
    _count?: JournalPublicationDetailsCountOrderByAggregateInput
    _avg?: JournalPublicationDetailsAvgOrderByAggregateInput
    _max?: JournalPublicationDetailsMaxOrderByAggregateInput
    _min?: JournalPublicationDetailsMinOrderByAggregateInput
    _sum?: JournalPublicationDetailsSumOrderByAggregateInput
  }

  export type JournalPublicationDetailsScalarWhereWithAggregatesInput = {
    AND?: JournalPublicationDetailsScalarWhereWithAggregatesInput | JournalPublicationDetailsScalarWhereWithAggregatesInput[]
    OR?: JournalPublicationDetailsScalarWhereWithAggregatesInput[]
    NOT?: JournalPublicationDetailsScalarWhereWithAggregatesInput | JournalPublicationDetailsScalarWhereWithAggregatesInput[]
    PublicationID?: IntWithAggregatesFilter<"JournalPublicationDetails"> | number
    Name?: StringNullableWithAggregatesFilter<"JournalPublicationDetails"> | string | null
    VolumeNumber?: StringNullableWithAggregatesFilter<"JournalPublicationDetails"> | string | null
    IssueNumber?: StringNullableWithAggregatesFilter<"JournalPublicationDetails"> | string | null
    ISSN_Number?: IntNullableWithAggregatesFilter<"JournalPublicationDetails"> | number | null
  }

  export type BookPublicationDetailsWhereInput = {
    AND?: BookPublicationDetailsWhereInput | BookPublicationDetailsWhereInput[]
    OR?: BookPublicationDetailsWhereInput[]
    NOT?: BookPublicationDetailsWhereInput | BookPublicationDetailsWhereInput[]
    PublicationID?: IntFilter<"BookPublicationDetails"> | number
    Publisher?: StringNullableFilter<"BookPublicationDetails"> | string | null
    Edition?: StringNullableFilter<"BookPublicationDetails"> | string | null
    VolumeNumber?: StringNullableFilter<"BookPublicationDetails"> | string | null
    ISBN_Number?: StringNullableFilter<"BookPublicationDetails"> | string | null
    Publication?: XOR<PublicationsScalarRelationFilter, PublicationsWhereInput>
  }

  export type BookPublicationDetailsOrderByWithRelationInput = {
    PublicationID?: SortOrder
    Publisher?: SortOrderInput | SortOrder
    Edition?: SortOrderInput | SortOrder
    VolumeNumber?: SortOrderInput | SortOrder
    ISBN_Number?: SortOrderInput | SortOrder
    Publication?: PublicationsOrderByWithRelationInput
  }

  export type BookPublicationDetailsWhereUniqueInput = Prisma.AtLeast<{
    PublicationID?: number
    AND?: BookPublicationDetailsWhereInput | BookPublicationDetailsWhereInput[]
    OR?: BookPublicationDetailsWhereInput[]
    NOT?: BookPublicationDetailsWhereInput | BookPublicationDetailsWhereInput[]
    Publisher?: StringNullableFilter<"BookPublicationDetails"> | string | null
    Edition?: StringNullableFilter<"BookPublicationDetails"> | string | null
    VolumeNumber?: StringNullableFilter<"BookPublicationDetails"> | string | null
    ISBN_Number?: StringNullableFilter<"BookPublicationDetails"> | string | null
    Publication?: XOR<PublicationsScalarRelationFilter, PublicationsWhereInput>
  }, "PublicationID">

  export type BookPublicationDetailsOrderByWithAggregationInput = {
    PublicationID?: SortOrder
    Publisher?: SortOrderInput | SortOrder
    Edition?: SortOrderInput | SortOrder
    VolumeNumber?: SortOrderInput | SortOrder
    ISBN_Number?: SortOrderInput | SortOrder
    _count?: BookPublicationDetailsCountOrderByAggregateInput
    _avg?: BookPublicationDetailsAvgOrderByAggregateInput
    _max?: BookPublicationDetailsMaxOrderByAggregateInput
    _min?: BookPublicationDetailsMinOrderByAggregateInput
    _sum?: BookPublicationDetailsSumOrderByAggregateInput
  }

  export type BookPublicationDetailsScalarWhereWithAggregatesInput = {
    AND?: BookPublicationDetailsScalarWhereWithAggregatesInput | BookPublicationDetailsScalarWhereWithAggregatesInput[]
    OR?: BookPublicationDetailsScalarWhereWithAggregatesInput[]
    NOT?: BookPublicationDetailsScalarWhereWithAggregatesInput | BookPublicationDetailsScalarWhereWithAggregatesInput[]
    PublicationID?: IntWithAggregatesFilter<"BookPublicationDetails"> | number
    Publisher?: StringNullableWithAggregatesFilter<"BookPublicationDetails"> | string | null
    Edition?: StringNullableWithAggregatesFilter<"BookPublicationDetails"> | string | null
    VolumeNumber?: StringNullableWithAggregatesFilter<"BookPublicationDetails"> | string | null
    ISBN_Number?: StringNullableWithAggregatesFilter<"BookPublicationDetails"> | string | null
  }

  export type ConferencePaperDetailsWhereInput = {
    AND?: ConferencePaperDetailsWhereInput | ConferencePaperDetailsWhereInput[]
    OR?: ConferencePaperDetailsWhereInput[]
    NOT?: ConferencePaperDetailsWhereInput | ConferencePaperDetailsWhereInput[]
    PublicationID?: IntFilter<"ConferencePaperDetails"> | number
    Publisher?: StringNullableFilter<"ConferencePaperDetails"> | string | null
    Location?: StringNullableFilter<"ConferencePaperDetails"> | string | null
    PageNumbers?: StringNullableFilter<"ConferencePaperDetails"> | string | null
    Publication?: XOR<PublicationsScalarRelationFilter, PublicationsWhereInput>
  }

  export type ConferencePaperDetailsOrderByWithRelationInput = {
    PublicationID?: SortOrder
    Publisher?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    PageNumbers?: SortOrderInput | SortOrder
    Publication?: PublicationsOrderByWithRelationInput
  }

  export type ConferencePaperDetailsWhereUniqueInput = Prisma.AtLeast<{
    PublicationID?: number
    AND?: ConferencePaperDetailsWhereInput | ConferencePaperDetailsWhereInput[]
    OR?: ConferencePaperDetailsWhereInput[]
    NOT?: ConferencePaperDetailsWhereInput | ConferencePaperDetailsWhereInput[]
    Publisher?: StringNullableFilter<"ConferencePaperDetails"> | string | null
    Location?: StringNullableFilter<"ConferencePaperDetails"> | string | null
    PageNumbers?: StringNullableFilter<"ConferencePaperDetails"> | string | null
    Publication?: XOR<PublicationsScalarRelationFilter, PublicationsWhereInput>
  }, "PublicationID">

  export type ConferencePaperDetailsOrderByWithAggregationInput = {
    PublicationID?: SortOrder
    Publisher?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    PageNumbers?: SortOrderInput | SortOrder
    _count?: ConferencePaperDetailsCountOrderByAggregateInput
    _avg?: ConferencePaperDetailsAvgOrderByAggregateInput
    _max?: ConferencePaperDetailsMaxOrderByAggregateInput
    _min?: ConferencePaperDetailsMinOrderByAggregateInput
    _sum?: ConferencePaperDetailsSumOrderByAggregateInput
  }

  export type ConferencePaperDetailsScalarWhereWithAggregatesInput = {
    AND?: ConferencePaperDetailsScalarWhereWithAggregatesInput | ConferencePaperDetailsScalarWhereWithAggregatesInput[]
    OR?: ConferencePaperDetailsScalarWhereWithAggregatesInput[]
    NOT?: ConferencePaperDetailsScalarWhereWithAggregatesInput | ConferencePaperDetailsScalarWhereWithAggregatesInput[]
    PublicationID?: IntWithAggregatesFilter<"ConferencePaperDetails"> | number
    Publisher?: StringNullableWithAggregatesFilter<"ConferencePaperDetails"> | string | null
    Location?: StringNullableWithAggregatesFilter<"ConferencePaperDetails"> | string | null
    PageNumbers?: StringNullableWithAggregatesFilter<"ConferencePaperDetails"> | string | null
  }

  export type FacultyPublicationLinkWhereInput = {
    AND?: FacultyPublicationLinkWhereInput | FacultyPublicationLinkWhereInput[]
    OR?: FacultyPublicationLinkWhereInput[]
    NOT?: FacultyPublicationLinkWhereInput | FacultyPublicationLinkWhereInput[]
    PublicationID?: IntFilter<"FacultyPublicationLink"> | number
    FacultyID?: IntFilter<"FacultyPublicationLink"> | number
    TypeOfIndexing?: StringNullableFilter<"FacultyPublicationLink"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    Publication?: XOR<PublicationsScalarRelationFilter, PublicationsWhereInput>
  }

  export type FacultyPublicationLinkOrderByWithRelationInput = {
    PublicationID?: SortOrder
    FacultyID?: SortOrder
    TypeOfIndexing?: SortOrderInput | SortOrder
    Faculty?: FacultyOrderByWithRelationInput
    Publication?: PublicationsOrderByWithRelationInput
  }

  export type FacultyPublicationLinkWhereUniqueInput = Prisma.AtLeast<{
    PublicationID_FacultyID?: FacultyPublicationLinkPublicationIDFacultyIDCompoundUniqueInput
    AND?: FacultyPublicationLinkWhereInput | FacultyPublicationLinkWhereInput[]
    OR?: FacultyPublicationLinkWhereInput[]
    NOT?: FacultyPublicationLinkWhereInput | FacultyPublicationLinkWhereInput[]
    PublicationID?: IntFilter<"FacultyPublicationLink"> | number
    FacultyID?: IntFilter<"FacultyPublicationLink"> | number
    TypeOfIndexing?: StringNullableFilter<"FacultyPublicationLink"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    Publication?: XOR<PublicationsScalarRelationFilter, PublicationsWhereInput>
  }, "PublicationID_FacultyID">

  export type FacultyPublicationLinkOrderByWithAggregationInput = {
    PublicationID?: SortOrder
    FacultyID?: SortOrder
    TypeOfIndexing?: SortOrderInput | SortOrder
    _count?: FacultyPublicationLinkCountOrderByAggregateInput
    _avg?: FacultyPublicationLinkAvgOrderByAggregateInput
    _max?: FacultyPublicationLinkMaxOrderByAggregateInput
    _min?: FacultyPublicationLinkMinOrderByAggregateInput
    _sum?: FacultyPublicationLinkSumOrderByAggregateInput
  }

  export type FacultyPublicationLinkScalarWhereWithAggregatesInput = {
    AND?: FacultyPublicationLinkScalarWhereWithAggregatesInput | FacultyPublicationLinkScalarWhereWithAggregatesInput[]
    OR?: FacultyPublicationLinkScalarWhereWithAggregatesInput[]
    NOT?: FacultyPublicationLinkScalarWhereWithAggregatesInput | FacultyPublicationLinkScalarWhereWithAggregatesInput[]
    PublicationID?: IntWithAggregatesFilter<"FacultyPublicationLink"> | number
    FacultyID?: IntWithAggregatesFilter<"FacultyPublicationLink"> | number
    TypeOfIndexing?: StringNullableWithAggregatesFilter<"FacultyPublicationLink"> | string | null
  }

  export type PatentsWhereInput = {
    AND?: PatentsWhereInput | PatentsWhereInput[]
    OR?: PatentsWhereInput[]
    NOT?: PatentsWhereInput | PatentsWhereInput[]
    TypeID?: StringFilter<"Patents"> | string
    FacultyID?: IntFilter<"Patents"> | number
    Title?: StringFilter<"Patents"> | string
    FilingDate?: DateTimeFilter<"Patents"> | Date | string
    PublicationDate?: DateTimeNullableFilter<"Patents"> | Date | string | null
    PatentNumber?: StringFilter<"Patents"> | string
    Authority?: StringNullableFilter<"Patents"> | string | null
    CollaborationInstitute?: StringNullableFilter<"Patents"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    Type?: XOR<TYPESScalarRelationFilter, TYPESWhereInput>
  }

  export type PatentsOrderByWithRelationInput = {
    TypeID?: SortOrder
    FacultyID?: SortOrder
    Title?: SortOrder
    FilingDate?: SortOrder
    PublicationDate?: SortOrderInput | SortOrder
    PatentNumber?: SortOrder
    Authority?: SortOrderInput | SortOrder
    CollaborationInstitute?: SortOrderInput | SortOrder
    Faculty?: FacultyOrderByWithRelationInput
    Type?: TYPESOrderByWithRelationInput
  }

  export type PatentsWhereUniqueInput = Prisma.AtLeast<{
    TypeID_FacultyID?: PatentsTypeIDFacultyIDCompoundUniqueInput
    AND?: PatentsWhereInput | PatentsWhereInput[]
    OR?: PatentsWhereInput[]
    NOT?: PatentsWhereInput | PatentsWhereInput[]
    TypeID?: StringFilter<"Patents"> | string
    FacultyID?: IntFilter<"Patents"> | number
    Title?: StringFilter<"Patents"> | string
    FilingDate?: DateTimeFilter<"Patents"> | Date | string
    PublicationDate?: DateTimeNullableFilter<"Patents"> | Date | string | null
    PatentNumber?: StringFilter<"Patents"> | string
    Authority?: StringNullableFilter<"Patents"> | string | null
    CollaborationInstitute?: StringNullableFilter<"Patents"> | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    Type?: XOR<TYPESScalarRelationFilter, TYPESWhereInput>
  }, "TypeID_FacultyID">

  export type PatentsOrderByWithAggregationInput = {
    TypeID?: SortOrder
    FacultyID?: SortOrder
    Title?: SortOrder
    FilingDate?: SortOrder
    PublicationDate?: SortOrderInput | SortOrder
    PatentNumber?: SortOrder
    Authority?: SortOrderInput | SortOrder
    CollaborationInstitute?: SortOrderInput | SortOrder
    _count?: PatentsCountOrderByAggregateInput
    _avg?: PatentsAvgOrderByAggregateInput
    _max?: PatentsMaxOrderByAggregateInput
    _min?: PatentsMinOrderByAggregateInput
    _sum?: PatentsSumOrderByAggregateInput
  }

  export type PatentsScalarWhereWithAggregatesInput = {
    AND?: PatentsScalarWhereWithAggregatesInput | PatentsScalarWhereWithAggregatesInput[]
    OR?: PatentsScalarWhereWithAggregatesInput[]
    NOT?: PatentsScalarWhereWithAggregatesInput | PatentsScalarWhereWithAggregatesInput[]
    TypeID?: StringWithAggregatesFilter<"Patents"> | string
    FacultyID?: IntWithAggregatesFilter<"Patents"> | number
    Title?: StringWithAggregatesFilter<"Patents"> | string
    FilingDate?: DateTimeWithAggregatesFilter<"Patents"> | Date | string
    PublicationDate?: DateTimeNullableWithAggregatesFilter<"Patents"> | Date | string | null
    PatentNumber?: StringWithAggregatesFilter<"Patents"> | string
    Authority?: StringNullableWithAggregatesFilter<"Patents"> | string | null
    CollaborationInstitute?: StringNullableWithAggregatesFilter<"Patents"> | string | null
  }

  export type ResearchProjectsWhereInput = {
    AND?: ResearchProjectsWhereInput | ResearchProjectsWhereInput[]
    OR?: ResearchProjectsWhereInput[]
    NOT?: ResearchProjectsWhereInput | ResearchProjectsWhereInput[]
    TypeID?: StringFilter<"ResearchProjects"> | string
    FacultyID?: IntFilter<"ResearchProjects"> | number
    Title?: StringFilter<"ResearchProjects"> | string
    FundingAgency?: StringNullableFilter<"ResearchProjects"> | string | null
    StartDate?: DateTimeFilter<"ResearchProjects"> | Date | string
    EndDate?: DateTimeNullableFilter<"ResearchProjects"> | Date | string | null
    Budget?: DecimalNullableFilter<"ResearchProjects"> | Decimal | DecimalJsLike | number | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    Type?: XOR<TYPESScalarRelationFilter, TYPESWhereInput>
  }

  export type ResearchProjectsOrderByWithRelationInput = {
    TypeID?: SortOrder
    FacultyID?: SortOrder
    Title?: SortOrder
    FundingAgency?: SortOrderInput | SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrderInput | SortOrder
    Budget?: SortOrderInput | SortOrder
    Faculty?: FacultyOrderByWithRelationInput
    Type?: TYPESOrderByWithRelationInput
  }

  export type ResearchProjectsWhereUniqueInput = Prisma.AtLeast<{
    TypeID_FacultyID?: ResearchProjectsTypeIDFacultyIDCompoundUniqueInput
    AND?: ResearchProjectsWhereInput | ResearchProjectsWhereInput[]
    OR?: ResearchProjectsWhereInput[]
    NOT?: ResearchProjectsWhereInput | ResearchProjectsWhereInput[]
    TypeID?: StringFilter<"ResearchProjects"> | string
    FacultyID?: IntFilter<"ResearchProjects"> | number
    Title?: StringFilter<"ResearchProjects"> | string
    FundingAgency?: StringNullableFilter<"ResearchProjects"> | string | null
    StartDate?: DateTimeFilter<"ResearchProjects"> | Date | string
    EndDate?: DateTimeNullableFilter<"ResearchProjects"> | Date | string | null
    Budget?: DecimalNullableFilter<"ResearchProjects"> | Decimal | DecimalJsLike | number | string | null
    Faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    Type?: XOR<TYPESScalarRelationFilter, TYPESWhereInput>
  }, "TypeID_FacultyID">

  export type ResearchProjectsOrderByWithAggregationInput = {
    TypeID?: SortOrder
    FacultyID?: SortOrder
    Title?: SortOrder
    FundingAgency?: SortOrderInput | SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrderInput | SortOrder
    Budget?: SortOrderInput | SortOrder
    _count?: ResearchProjectsCountOrderByAggregateInput
    _avg?: ResearchProjectsAvgOrderByAggregateInput
    _max?: ResearchProjectsMaxOrderByAggregateInput
    _min?: ResearchProjectsMinOrderByAggregateInput
    _sum?: ResearchProjectsSumOrderByAggregateInput
  }

  export type ResearchProjectsScalarWhereWithAggregatesInput = {
    AND?: ResearchProjectsScalarWhereWithAggregatesInput | ResearchProjectsScalarWhereWithAggregatesInput[]
    OR?: ResearchProjectsScalarWhereWithAggregatesInput[]
    NOT?: ResearchProjectsScalarWhereWithAggregatesInput | ResearchProjectsScalarWhereWithAggregatesInput[]
    TypeID?: StringWithAggregatesFilter<"ResearchProjects"> | string
    FacultyID?: IntWithAggregatesFilter<"ResearchProjects"> | number
    Title?: StringWithAggregatesFilter<"ResearchProjects"> | string
    FundingAgency?: StringNullableWithAggregatesFilter<"ResearchProjects"> | string | null
    StartDate?: DateTimeWithAggregatesFilter<"ResearchProjects"> | Date | string
    EndDate?: DateTimeNullableWithAggregatesFilter<"ResearchProjects"> | Date | string | null
    Budget?: DecimalNullableWithAggregatesFilter<"ResearchProjects"> | Decimal | DecimalJsLike | number | string | null
  }

  export type DepartmentCreateInput = {
    DepartmentName: string
    Faculty?: FacultyCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    DepartmentID?: number
    DepartmentName: string
    Faculty?: FacultyUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    DepartmentName?: StringFieldUpdateOperationsInput | string
    Faculty?: FacultyUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    DepartmentID?: IntFieldUpdateOperationsInput | number
    DepartmentName?: StringFieldUpdateOperationsInput | string
    Faculty?: FacultyUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    DepartmentID?: number
    DepartmentName: string
  }

  export type DepartmentUpdateManyMutationInput = {
    DepartmentName?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    DepartmentID?: IntFieldUpdateOperationsInput | number
    DepartmentName?: StringFieldUpdateOperationsInput | string
  }

  export type FacultyCreateInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUpdateInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyCreateManyInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
  }

  export type FacultyUpdateManyMutationInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
  }

  export type FacultyUncheckedUpdateManyInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
  }

  export type SubjectTaughtCreateInput = {
    Level: string
    SubjectName: string
    CourseCode?: string | null
    ProgramName?: string | null
    Note?: string | null
    Faculty: FacultyCreateNestedOneWithoutSubjectsTaughtInput
  }

  export type SubjectTaughtUncheckedCreateInput = {
    FacultyID: number
    Level: string
    SubjectName: string
    CourseCode?: string | null
    ProgramName?: string | null
    Note?: string | null
  }

  export type SubjectTaughtUpdateInput = {
    Level?: StringFieldUpdateOperationsInput | string
    SubjectName?: StringFieldUpdateOperationsInput | string
    CourseCode?: NullableStringFieldUpdateOperationsInput | string | null
    ProgramName?: NullableStringFieldUpdateOperationsInput | string | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutSubjectsTaughtNestedInput
  }

  export type SubjectTaughtUncheckedUpdateInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    Level?: StringFieldUpdateOperationsInput | string
    SubjectName?: StringFieldUpdateOperationsInput | string
    CourseCode?: NullableStringFieldUpdateOperationsInput | string | null
    ProgramName?: NullableStringFieldUpdateOperationsInput | string | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubjectTaughtCreateManyInput = {
    FacultyID: number
    Level: string
    SubjectName: string
    CourseCode?: string | null
    ProgramName?: string | null
    Note?: string | null
  }

  export type SubjectTaughtUpdateManyMutationInput = {
    Level?: StringFieldUpdateOperationsInput | string
    SubjectName?: StringFieldUpdateOperationsInput | string
    CourseCode?: NullableStringFieldUpdateOperationsInput | string | null
    ProgramName?: NullableStringFieldUpdateOperationsInput | string | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubjectTaughtUncheckedUpdateManyInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    Level?: StringFieldUpdateOperationsInput | string
    SubjectName?: StringFieldUpdateOperationsInput | string
    CourseCode?: NullableStringFieldUpdateOperationsInput | string | null
    ProgramName?: NullableStringFieldUpdateOperationsInput | string | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyQualificationCreateInput = {
    Degree: string
    Institution: string
    YearOfCompletion: Date | string
    Faculty: FacultyCreateNestedOneWithoutQualificationsInput
  }

  export type FacultyQualificationUncheckedCreateInput = {
    QualificationID?: number
    FacultyID: number
    Degree: string
    Institution: string
    YearOfCompletion: Date | string
  }

  export type FacultyQualificationUpdateInput = {
    Degree?: StringFieldUpdateOperationsInput | string
    Institution?: StringFieldUpdateOperationsInput | string
    YearOfCompletion?: DateTimeFieldUpdateOperationsInput | Date | string
    Faculty?: FacultyUpdateOneRequiredWithoutQualificationsNestedInput
  }

  export type FacultyQualificationUncheckedUpdateInput = {
    QualificationID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    Degree?: StringFieldUpdateOperationsInput | string
    Institution?: StringFieldUpdateOperationsInput | string
    YearOfCompletion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyQualificationCreateManyInput = {
    QualificationID?: number
    FacultyID: number
    Degree: string
    Institution: string
    YearOfCompletion: Date | string
  }

  export type FacultyQualificationUpdateManyMutationInput = {
    Degree?: StringFieldUpdateOperationsInput | string
    Institution?: StringFieldUpdateOperationsInput | string
    YearOfCompletion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyQualificationUncheckedUpdateManyInput = {
    QualificationID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    Degree?: StringFieldUpdateOperationsInput | string
    Institution?: StringFieldUpdateOperationsInput | string
    YearOfCompletion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutReachActivitiesCreateInput = {
    ActivityType: string
    ActivityTitle: string
    InstitutionName?: string | null
    ActivityDate: Date | string
    Description?: string | null
    Faculty: FacultyCreateNestedOneWithoutOutreachActivitiesInput
  }

  export type OutReachActivitiesUncheckedCreateInput = {
    ActivityID?: number
    FacultyID: number
    ActivityType: string
    ActivityTitle: string
    InstitutionName?: string | null
    ActivityDate: Date | string
    Description?: string | null
  }

  export type OutReachActivitiesUpdateInput = {
    ActivityType?: StringFieldUpdateOperationsInput | string
    ActivityTitle?: StringFieldUpdateOperationsInput | string
    InstitutionName?: NullableStringFieldUpdateOperationsInput | string | null
    ActivityDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutOutreachActivitiesNestedInput
  }

  export type OutReachActivitiesUncheckedUpdateInput = {
    ActivityID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    ActivityType?: StringFieldUpdateOperationsInput | string
    ActivityTitle?: StringFieldUpdateOperationsInput | string
    InstitutionName?: NullableStringFieldUpdateOperationsInput | string | null
    ActivityDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OutReachActivitiesCreateManyInput = {
    ActivityID?: number
    FacultyID: number
    ActivityType: string
    ActivityTitle: string
    InstitutionName?: string | null
    ActivityDate: Date | string
    Description?: string | null
  }

  export type OutReachActivitiesUpdateManyMutationInput = {
    ActivityType?: StringFieldUpdateOperationsInput | string
    ActivityTitle?: StringFieldUpdateOperationsInput | string
    InstitutionName?: NullableStringFieldUpdateOperationsInput | string | null
    ActivityDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OutReachActivitiesUncheckedUpdateManyInput = {
    ActivityID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    ActivityType?: StringFieldUpdateOperationsInput | string
    ActivityTitle?: StringFieldUpdateOperationsInput | string
    InstitutionName?: NullableStringFieldUpdateOperationsInput | string | null
    ActivityDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventTypeCreateInput = {
    EventID: number
    EventType: $Enums.event_type
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutEventInput
  }

  export type EventTypeUncheckedCreateInput = {
    EventID: number
    EventType: $Enums.event_type
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventTypeUpdateInput = {
    EventID?: IntFieldUpdateOperationsInput | number
    EventType?: Enumevent_typeFieldUpdateOperationsInput | $Enums.event_type
    EventsOrganised?: EventsOrganisedUpdateManyWithoutEventNestedInput
  }

  export type EventTypeUncheckedUpdateInput = {
    EventID?: IntFieldUpdateOperationsInput | number
    EventType?: Enumevent_typeFieldUpdateOperationsInput | $Enums.event_type
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventTypeCreateManyInput = {
    EventID: number
    EventType: $Enums.event_type
  }

  export type EventTypeUpdateManyMutationInput = {
    EventID?: IntFieldUpdateOperationsInput | number
    EventType?: Enumevent_typeFieldUpdateOperationsInput | $Enums.event_type
  }

  export type EventTypeUncheckedUpdateManyInput = {
    EventID?: IntFieldUpdateOperationsInput | number
    EventType?: Enumevent_typeFieldUpdateOperationsInput | $Enums.event_type
  }

  export type EventsOrganisedCreateInput = {
    Title: string
    Organizer?: string | null
    Location?: string | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Description?: string | null
    Role?: $Enums.role_type | null
    FundingAgency?: string | null
    Faculty: FacultyCreateNestedOneWithoutEventsOrganisedInput
    Event: EventTypeCreateNestedOneWithoutEventsOrganisedInput
  }

  export type EventsOrganisedUncheckedCreateInput = {
    FacultyID: number
    Event_id: number
    Title: string
    Organizer?: string | null
    Location?: string | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Description?: string | null
    Role?: $Enums.role_type | null
    FundingAgency?: string | null
  }

  export type EventsOrganisedUpdateInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Organizer?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableEnumrole_typeFieldUpdateOperationsInput | $Enums.role_type | null
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutEventsOrganisedNestedInput
    Event?: EventTypeUpdateOneRequiredWithoutEventsOrganisedNestedInput
  }

  export type EventsOrganisedUncheckedUpdateInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    Event_id?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    Organizer?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableEnumrole_typeFieldUpdateOperationsInput | $Enums.role_type | null
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventsOrganisedCreateManyInput = {
    FacultyID: number
    Event_id: number
    Title: string
    Organizer?: string | null
    Location?: string | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Description?: string | null
    Role?: $Enums.role_type | null
    FundingAgency?: string | null
  }

  export type EventsOrganisedUpdateManyMutationInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Organizer?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableEnumrole_typeFieldUpdateOperationsInput | $Enums.role_type | null
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventsOrganisedUncheckedUpdateManyInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    Event_id?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    Organizer?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableEnumrole_typeFieldUpdateOperationsInput | $Enums.role_type | null
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AwardsCreateInput = {
    AwardName: string
    AwardingBody?: string | null
    Location?: string | null
    YearAwarded: number
    Faculty: FacultyCreateNestedOneWithoutAwardsInput
  }

  export type AwardsUncheckedCreateInput = {
    AwardID?: number
    FacultyID: number
    AwardName: string
    AwardingBody?: string | null
    Location?: string | null
    YearAwarded: number
  }

  export type AwardsUpdateInput = {
    AwardName?: StringFieldUpdateOperationsInput | string
    AwardingBody?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    YearAwarded?: IntFieldUpdateOperationsInput | number
    Faculty?: FacultyUpdateOneRequiredWithoutAwardsNestedInput
  }

  export type AwardsUncheckedUpdateInput = {
    AwardID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    AwardName?: StringFieldUpdateOperationsInput | string
    AwardingBody?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    YearAwarded?: IntFieldUpdateOperationsInput | number
  }

  export type AwardsCreateManyInput = {
    AwardID?: number
    FacultyID: number
    AwardName: string
    AwardingBody?: string | null
    Location?: string | null
    YearAwarded: number
  }

  export type AwardsUpdateManyMutationInput = {
    AwardName?: StringFieldUpdateOperationsInput | string
    AwardingBody?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    YearAwarded?: IntFieldUpdateOperationsInput | number
  }

  export type AwardsUncheckedUpdateManyInput = {
    AwardID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    AwardName?: StringFieldUpdateOperationsInput | string
    AwardingBody?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    YearAwarded?: IntFieldUpdateOperationsInput | number
  }

  export type TeachingExperienceCreateInput = {
    OrganizationName: string
    Designation: string
    StartDate: Date | string
    EndDate?: string | null
    NatureOfWork?: string | null
    Faculty: FacultyCreateNestedOneWithoutTeachingExperiencesInput
  }

  export type TeachingExperienceUncheckedCreateInput = {
    ExperienceID?: number
    FacultyID: number
    OrganizationName: string
    Designation: string
    StartDate: Date | string
    EndDate?: string | null
    NatureOfWork?: string | null
  }

  export type TeachingExperienceUpdateInput = {
    OrganizationName?: StringFieldUpdateOperationsInput | string
    Designation?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableStringFieldUpdateOperationsInput | string | null
    NatureOfWork?: NullableStringFieldUpdateOperationsInput | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutTeachingExperiencesNestedInput
  }

  export type TeachingExperienceUncheckedUpdateInput = {
    ExperienceID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    OrganizationName?: StringFieldUpdateOperationsInput | string
    Designation?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableStringFieldUpdateOperationsInput | string | null
    NatureOfWork?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingExperienceCreateManyInput = {
    ExperienceID?: number
    FacultyID: number
    OrganizationName: string
    Designation: string
    StartDate: Date | string
    EndDate?: string | null
    NatureOfWork?: string | null
  }

  export type TeachingExperienceUpdateManyMutationInput = {
    OrganizationName?: StringFieldUpdateOperationsInput | string
    Designation?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableStringFieldUpdateOperationsInput | string | null
    NatureOfWork?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingExperienceUncheckedUpdateManyInput = {
    ExperienceID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    OrganizationName?: StringFieldUpdateOperationsInput | string
    Designation?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableStringFieldUpdateOperationsInput | string | null
    NatureOfWork?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CitationMetricsCreateInput = {
    YearRecorded: number
    Source: string
    HIndex?: number | null
    I10Index?: number | null
    TotalCitations?: number | null
    ImpactFactor?: Decimal | DecimalJsLike | number | string | null
    Faculty: FacultyCreateNestedOneWithoutCitationMetricsInput
  }

  export type CitationMetricsUncheckedCreateInput = {
    MetricsID?: number
    FacultyID: number
    YearRecorded: number
    Source: string
    HIndex?: number | null
    I10Index?: number | null
    TotalCitations?: number | null
    ImpactFactor?: Decimal | DecimalJsLike | number | string | null
  }

  export type CitationMetricsUpdateInput = {
    YearRecorded?: IntFieldUpdateOperationsInput | number
    Source?: StringFieldUpdateOperationsInput | string
    HIndex?: NullableIntFieldUpdateOperationsInput | number | null
    I10Index?: NullableIntFieldUpdateOperationsInput | number | null
    TotalCitations?: NullableIntFieldUpdateOperationsInput | number | null
    ImpactFactor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutCitationMetricsNestedInput
  }

  export type CitationMetricsUncheckedUpdateInput = {
    MetricsID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    YearRecorded?: IntFieldUpdateOperationsInput | number
    Source?: StringFieldUpdateOperationsInput | string
    HIndex?: NullableIntFieldUpdateOperationsInput | number | null
    I10Index?: NullableIntFieldUpdateOperationsInput | number | null
    TotalCitations?: NullableIntFieldUpdateOperationsInput | number | null
    ImpactFactor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CitationMetricsCreateManyInput = {
    MetricsID?: number
    FacultyID: number
    YearRecorded: number
    Source: string
    HIndex?: number | null
    I10Index?: number | null
    TotalCitations?: number | null
    ImpactFactor?: Decimal | DecimalJsLike | number | string | null
  }

  export type CitationMetricsUpdateManyMutationInput = {
    YearRecorded?: IntFieldUpdateOperationsInput | number
    Source?: StringFieldUpdateOperationsInput | string
    HIndex?: NullableIntFieldUpdateOperationsInput | number | null
    I10Index?: NullableIntFieldUpdateOperationsInput | number | null
    TotalCitations?: NullableIntFieldUpdateOperationsInput | number | null
    ImpactFactor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CitationMetricsUncheckedUpdateManyInput = {
    MetricsID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    YearRecorded?: IntFieldUpdateOperationsInput | number
    Source?: StringFieldUpdateOperationsInput | string
    HIndex?: NullableIntFieldUpdateOperationsInput | number | null
    I10Index?: NullableIntFieldUpdateOperationsInput | number | null
    TotalCitations?: NullableIntFieldUpdateOperationsInput | number | null
    ImpactFactor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TYPESCreateInput = {
    TypeID: string
    Type: $Enums.publication_type
    Status?: string | null
    Publications?: PublicationsCreateNestedManyWithoutTypeInput
    Patents?: PatentsCreateNestedManyWithoutTypeInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutTypeInput
  }

  export type TYPESUncheckedCreateInput = {
    TypeID: string
    Type: $Enums.publication_type
    Status?: string | null
    Publications?: PublicationsUncheckedCreateNestedManyWithoutTypeInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutTypeInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TYPESUpdateInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Type?: Enumpublication_typeFieldUpdateOperationsInput | $Enums.publication_type
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Publications?: PublicationsUpdateManyWithoutTypeNestedInput
    Patents?: PatentsUpdateManyWithoutTypeNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutTypeNestedInput
  }

  export type TYPESUncheckedUpdateInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Type?: Enumpublication_typeFieldUpdateOperationsInput | $Enums.publication_type
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Publications?: PublicationsUncheckedUpdateManyWithoutTypeNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutTypeNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type TYPESCreateManyInput = {
    TypeID: string
    Type: $Enums.publication_type
    Status?: string | null
  }

  export type TYPESUpdateManyMutationInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Type?: Enumpublication_typeFieldUpdateOperationsInput | $Enums.publication_type
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TYPESUncheckedUpdateManyInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Type?: Enumpublication_typeFieldUpdateOperationsInput | $Enums.publication_type
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublicationsCreateInput = {
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    Type: TYPESCreateNestedOneWithoutPublicationsInput
    JournalPublicationDetails?: JournalPublicationDetailsCreateNestedOneWithoutPublicationInput
    BookPublicationDetails?: BookPublicationDetailsCreateNestedOneWithoutPublicationInput
    ConferencePaperDetails?: ConferencePaperDetailsCreateNestedOneWithoutPublicationInput
    FacultyPublicationLink?: FacultyPublicationLinkCreateNestedManyWithoutPublicationInput
  }

  export type PublicationsUncheckedCreateInput = {
    PublicationID?: number
    TypeID: string
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    JournalPublicationDetails?: JournalPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput
    BookPublicationDetails?: BookPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput
    ConferencePaperDetails?: ConferencePaperDetailsUncheckedCreateNestedOneWithoutPublicationInput
    FacultyPublicationLink?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationsUpdateInput = {
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: TYPESUpdateOneRequiredWithoutPublicationsNestedInput
    JournalPublicationDetails?: JournalPublicationDetailsUpdateOneWithoutPublicationNestedInput
    BookPublicationDetails?: BookPublicationDetailsUpdateOneWithoutPublicationNestedInput
    ConferencePaperDetails?: ConferencePaperDetailsUpdateOneWithoutPublicationNestedInput
    FacultyPublicationLink?: FacultyPublicationLinkUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationsUncheckedUpdateInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    TypeID?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    JournalPublicationDetails?: JournalPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    BookPublicationDetails?: BookPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    ConferencePaperDetails?: ConferencePaperDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    FacultyPublicationLink?: FacultyPublicationLinkUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationsCreateManyInput = {
    PublicationID?: number
    TypeID: string
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
  }

  export type PublicationsUpdateManyMutationInput = {
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublicationsUncheckedUpdateManyInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    TypeID?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalPublicationDetailsCreateInput = {
    Name?: string | null
    VolumeNumber?: string | null
    IssueNumber?: string | null
    ISSN_Number?: number | null
    Publication: PublicationsCreateNestedOneWithoutJournalPublicationDetailsInput
  }

  export type JournalPublicationDetailsUncheckedCreateInput = {
    PublicationID: number
    Name?: string | null
    VolumeNumber?: string | null
    IssueNumber?: string | null
    ISSN_Number?: number | null
  }

  export type JournalPublicationDetailsUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IssueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISSN_Number?: NullableIntFieldUpdateOperationsInput | number | null
    Publication?: PublicationsUpdateOneRequiredWithoutJournalPublicationDetailsNestedInput
  }

  export type JournalPublicationDetailsUncheckedUpdateInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IssueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISSN_Number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JournalPublicationDetailsCreateManyInput = {
    PublicationID: number
    Name?: string | null
    VolumeNumber?: string | null
    IssueNumber?: string | null
    ISSN_Number?: number | null
  }

  export type JournalPublicationDetailsUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IssueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISSN_Number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JournalPublicationDetailsUncheckedUpdateManyInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IssueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISSN_Number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookPublicationDetailsCreateInput = {
    Publisher?: string | null
    Edition?: string | null
    VolumeNumber?: string | null
    ISBN_Number?: string | null
    Publication: PublicationsCreateNestedOneWithoutBookPublicationDetailsInput
  }

  export type BookPublicationDetailsUncheckedCreateInput = {
    PublicationID: number
    Publisher?: string | null
    Edition?: string | null
    VolumeNumber?: string | null
    ISBN_Number?: string | null
  }

  export type BookPublicationDetailsUpdateInput = {
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Edition?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISBN_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Publication?: PublicationsUpdateOneRequiredWithoutBookPublicationDetailsNestedInput
  }

  export type BookPublicationDetailsUncheckedUpdateInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Edition?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISBN_Number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookPublicationDetailsCreateManyInput = {
    PublicationID: number
    Publisher?: string | null
    Edition?: string | null
    VolumeNumber?: string | null
    ISBN_Number?: string | null
  }

  export type BookPublicationDetailsUpdateManyMutationInput = {
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Edition?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISBN_Number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookPublicationDetailsUncheckedUpdateManyInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Edition?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISBN_Number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConferencePaperDetailsCreateInput = {
    Publisher?: string | null
    Location?: string | null
    PageNumbers?: string | null
    Publication: PublicationsCreateNestedOneWithoutConferencePaperDetailsInput
  }

  export type ConferencePaperDetailsUncheckedCreateInput = {
    PublicationID: number
    Publisher?: string | null
    Location?: string | null
    PageNumbers?: string | null
  }

  export type ConferencePaperDetailsUpdateInput = {
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    PageNumbers?: NullableStringFieldUpdateOperationsInput | string | null
    Publication?: PublicationsUpdateOneRequiredWithoutConferencePaperDetailsNestedInput
  }

  export type ConferencePaperDetailsUncheckedUpdateInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    PageNumbers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConferencePaperDetailsCreateManyInput = {
    PublicationID: number
    Publisher?: string | null
    Location?: string | null
    PageNumbers?: string | null
  }

  export type ConferencePaperDetailsUpdateManyMutationInput = {
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    PageNumbers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConferencePaperDetailsUncheckedUpdateManyInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    PageNumbers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyPublicationLinkCreateInput = {
    TypeOfIndexing?: string | null
    Faculty: FacultyCreateNestedOneWithoutPublicationsInput
    Publication: PublicationsCreateNestedOneWithoutFacultyPublicationLinkInput
  }

  export type FacultyPublicationLinkUncheckedCreateInput = {
    PublicationID: number
    FacultyID: number
    TypeOfIndexing?: string | null
  }

  export type FacultyPublicationLinkUpdateInput = {
    TypeOfIndexing?: NullableStringFieldUpdateOperationsInput | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutPublicationsNestedInput
    Publication?: PublicationsUpdateOneRequiredWithoutFacultyPublicationLinkNestedInput
  }

  export type FacultyPublicationLinkUncheckedUpdateInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    TypeOfIndexing?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyPublicationLinkCreateManyInput = {
    PublicationID: number
    FacultyID: number
    TypeOfIndexing?: string | null
  }

  export type FacultyPublicationLinkUpdateManyMutationInput = {
    TypeOfIndexing?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyPublicationLinkUncheckedUpdateManyInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    FacultyID?: IntFieldUpdateOperationsInput | number
    TypeOfIndexing?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentsCreateInput = {
    Title: string
    FilingDate: Date | string
    PublicationDate?: Date | string | null
    PatentNumber: string
    Authority?: string | null
    CollaborationInstitute?: string | null
    Faculty: FacultyCreateNestedOneWithoutPatentsInput
    Type: TYPESCreateNestedOneWithoutPatentsInput
  }

  export type PatentsUncheckedCreateInput = {
    TypeID: string
    FacultyID: number
    Title: string
    FilingDate: Date | string
    PublicationDate?: Date | string | null
    PatentNumber: string
    Authority?: string | null
    CollaborationInstitute?: string | null
  }

  export type PatentsUpdateInput = {
    Title?: StringFieldUpdateOperationsInput | string
    FilingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PatentNumber?: StringFieldUpdateOperationsInput | string
    Authority?: NullableStringFieldUpdateOperationsInput | string | null
    CollaborationInstitute?: NullableStringFieldUpdateOperationsInput | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutPatentsNestedInput
    Type?: TYPESUpdateOneRequiredWithoutPatentsNestedInput
  }

  export type PatentsUncheckedUpdateInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    FacultyID?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    FilingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PatentNumber?: StringFieldUpdateOperationsInput | string
    Authority?: NullableStringFieldUpdateOperationsInput | string | null
    CollaborationInstitute?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentsCreateManyInput = {
    TypeID: string
    FacultyID: number
    Title: string
    FilingDate: Date | string
    PublicationDate?: Date | string | null
    PatentNumber: string
    Authority?: string | null
    CollaborationInstitute?: string | null
  }

  export type PatentsUpdateManyMutationInput = {
    Title?: StringFieldUpdateOperationsInput | string
    FilingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PatentNumber?: StringFieldUpdateOperationsInput | string
    Authority?: NullableStringFieldUpdateOperationsInput | string | null
    CollaborationInstitute?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentsUncheckedUpdateManyInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    FacultyID?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    FilingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PatentNumber?: StringFieldUpdateOperationsInput | string
    Authority?: NullableStringFieldUpdateOperationsInput | string | null
    CollaborationInstitute?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResearchProjectsCreateInput = {
    Title: string
    FundingAgency?: string | null
    StartDate: Date | string
    EndDate?: Date | string | null
    Budget?: Decimal | DecimalJsLike | number | string | null
    Faculty: FacultyCreateNestedOneWithoutResearchProjectsInput
    Type: TYPESCreateNestedOneWithoutResearchProjectsInput
  }

  export type ResearchProjectsUncheckedCreateInput = {
    TypeID: string
    FacultyID: number
    Title: string
    FundingAgency?: string | null
    StartDate: Date | string
    EndDate?: Date | string | null
    Budget?: Decimal | DecimalJsLike | number | string | null
  }

  export type ResearchProjectsUpdateInput = {
    Title?: StringFieldUpdateOperationsInput | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutResearchProjectsNestedInput
    Type?: TYPESUpdateOneRequiredWithoutResearchProjectsNestedInput
  }

  export type ResearchProjectsUncheckedUpdateInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    FacultyID?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ResearchProjectsCreateManyInput = {
    TypeID: string
    FacultyID: number
    Title: string
    FundingAgency?: string | null
    StartDate: Date | string
    EndDate?: Date | string | null
    Budget?: Decimal | DecimalJsLike | number | string | null
  }

  export type ResearchProjectsUpdateManyMutationInput = {
    Title?: StringFieldUpdateOperationsInput | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ResearchProjectsUncheckedUpdateManyInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    FacultyID?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FacultyListRelationFilter = {
    every?: FacultyWhereInput
    some?: FacultyWhereInput
    none?: FacultyWhereInput
  }

  export type FacultyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    DepartmentID?: SortOrder
    DepartmentName?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    DepartmentID?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    DepartmentID?: SortOrder
    DepartmentName?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    DepartmentID?: SortOrder
    DepartmentName?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    DepartmentID?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DepartmentScalarRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type SubjectTaughtListRelationFilter = {
    every?: SubjectTaughtWhereInput
    some?: SubjectTaughtWhereInput
    none?: SubjectTaughtWhereInput
  }

  export type FacultyQualificationListRelationFilter = {
    every?: FacultyQualificationWhereInput
    some?: FacultyQualificationWhereInput
    none?: FacultyQualificationWhereInput
  }

  export type OutReachActivitiesListRelationFilter = {
    every?: OutReachActivitiesWhereInput
    some?: OutReachActivitiesWhereInput
    none?: OutReachActivitiesWhereInput
  }

  export type EventsOrganisedListRelationFilter = {
    every?: EventsOrganisedWhereInput
    some?: EventsOrganisedWhereInput
    none?: EventsOrganisedWhereInput
  }

  export type AwardsListRelationFilter = {
    every?: AwardsWhereInput
    some?: AwardsWhereInput
    none?: AwardsWhereInput
  }

  export type TeachingExperienceListRelationFilter = {
    every?: TeachingExperienceWhereInput
    some?: TeachingExperienceWhereInput
    none?: TeachingExperienceWhereInput
  }

  export type CitationMetricsListRelationFilter = {
    every?: CitationMetricsWhereInput
    some?: CitationMetricsWhereInput
    none?: CitationMetricsWhereInput
  }

  export type FacultyPublicationLinkListRelationFilter = {
    every?: FacultyPublicationLinkWhereInput
    some?: FacultyPublicationLinkWhereInput
    none?: FacultyPublicationLinkWhereInput
  }

  export type PatentsListRelationFilter = {
    every?: PatentsWhereInput
    some?: PatentsWhereInput
    none?: PatentsWhereInput
  }

  export type ResearchProjectsListRelationFilter = {
    every?: ResearchProjectsWhereInput
    some?: ResearchProjectsWhereInput
    none?: ResearchProjectsWhereInput
  }

  export type SubjectTaughtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyQualificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutReachActivitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventsOrganisedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AwardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeachingExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CitationMetricsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyPublicationLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchProjectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyCountOrderByAggregateInput = {
    FacultyID?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    DOB?: SortOrder
    Role?: SortOrder
    Phone_no?: SortOrder
    Email?: SortOrder
    DepartmentID?: SortOrder
  }

  export type FacultyAvgOrderByAggregateInput = {
    FacultyID?: SortOrder
    DepartmentID?: SortOrder
  }

  export type FacultyMaxOrderByAggregateInput = {
    FacultyID?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    DOB?: SortOrder
    Role?: SortOrder
    Phone_no?: SortOrder
    Email?: SortOrder
    DepartmentID?: SortOrder
  }

  export type FacultyMinOrderByAggregateInput = {
    FacultyID?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    DOB?: SortOrder
    Role?: SortOrder
    Phone_no?: SortOrder
    Email?: SortOrder
    DepartmentID?: SortOrder
  }

  export type FacultySumOrderByAggregateInput = {
    FacultyID?: SortOrder
    DepartmentID?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FacultyScalarRelationFilter = {
    is?: FacultyWhereInput
    isNot?: FacultyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SubjectTaughtFacultyIDLevelSubjectNameCompoundUniqueInput = {
    FacultyID: number
    Level: string
    SubjectName: string
  }

  export type SubjectTaughtCountOrderByAggregateInput = {
    FacultyID?: SortOrder
    Level?: SortOrder
    SubjectName?: SortOrder
    CourseCode?: SortOrder
    ProgramName?: SortOrder
    Note?: SortOrder
  }

  export type SubjectTaughtAvgOrderByAggregateInput = {
    FacultyID?: SortOrder
  }

  export type SubjectTaughtMaxOrderByAggregateInput = {
    FacultyID?: SortOrder
    Level?: SortOrder
    SubjectName?: SortOrder
    CourseCode?: SortOrder
    ProgramName?: SortOrder
    Note?: SortOrder
  }

  export type SubjectTaughtMinOrderByAggregateInput = {
    FacultyID?: SortOrder
    Level?: SortOrder
    SubjectName?: SortOrder
    CourseCode?: SortOrder
    ProgramName?: SortOrder
    Note?: SortOrder
  }

  export type SubjectTaughtSumOrderByAggregateInput = {
    FacultyID?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FacultyQualificationCountOrderByAggregateInput = {
    QualificationID?: SortOrder
    FacultyID?: SortOrder
    Degree?: SortOrder
    Institution?: SortOrder
    YearOfCompletion?: SortOrder
  }

  export type FacultyQualificationAvgOrderByAggregateInput = {
    QualificationID?: SortOrder
    FacultyID?: SortOrder
  }

  export type FacultyQualificationMaxOrderByAggregateInput = {
    QualificationID?: SortOrder
    FacultyID?: SortOrder
    Degree?: SortOrder
    Institution?: SortOrder
    YearOfCompletion?: SortOrder
  }

  export type FacultyQualificationMinOrderByAggregateInput = {
    QualificationID?: SortOrder
    FacultyID?: SortOrder
    Degree?: SortOrder
    Institution?: SortOrder
    YearOfCompletion?: SortOrder
  }

  export type FacultyQualificationSumOrderByAggregateInput = {
    QualificationID?: SortOrder
    FacultyID?: SortOrder
  }

  export type OutReachActivitiesCountOrderByAggregateInput = {
    ActivityID?: SortOrder
    FacultyID?: SortOrder
    ActivityType?: SortOrder
    ActivityTitle?: SortOrder
    InstitutionName?: SortOrder
    ActivityDate?: SortOrder
    Description?: SortOrder
  }

  export type OutReachActivitiesAvgOrderByAggregateInput = {
    ActivityID?: SortOrder
    FacultyID?: SortOrder
  }

  export type OutReachActivitiesMaxOrderByAggregateInput = {
    ActivityID?: SortOrder
    FacultyID?: SortOrder
    ActivityType?: SortOrder
    ActivityTitle?: SortOrder
    InstitutionName?: SortOrder
    ActivityDate?: SortOrder
    Description?: SortOrder
  }

  export type OutReachActivitiesMinOrderByAggregateInput = {
    ActivityID?: SortOrder
    FacultyID?: SortOrder
    ActivityType?: SortOrder
    ActivityTitle?: SortOrder
    InstitutionName?: SortOrder
    ActivityDate?: SortOrder
    Description?: SortOrder
  }

  export type OutReachActivitiesSumOrderByAggregateInput = {
    ActivityID?: SortOrder
    FacultyID?: SortOrder
  }

  export type Enumevent_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.event_type | Enumevent_typeFieldRefInput<$PrismaModel>
    in?: $Enums.event_type[] | ListEnumevent_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.event_type[] | ListEnumevent_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumevent_typeFilter<$PrismaModel> | $Enums.event_type
  }

  export type EventTypeCountOrderByAggregateInput = {
    EventID?: SortOrder
    EventType?: SortOrder
  }

  export type EventTypeAvgOrderByAggregateInput = {
    EventID?: SortOrder
  }

  export type EventTypeMaxOrderByAggregateInput = {
    EventID?: SortOrder
    EventType?: SortOrder
  }

  export type EventTypeMinOrderByAggregateInput = {
    EventID?: SortOrder
    EventType?: SortOrder
  }

  export type EventTypeSumOrderByAggregateInput = {
    EventID?: SortOrder
  }

  export type Enumevent_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.event_type | Enumevent_typeFieldRefInput<$PrismaModel>
    in?: $Enums.event_type[] | ListEnumevent_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.event_type[] | ListEnumevent_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumevent_typeWithAggregatesFilter<$PrismaModel> | $Enums.event_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumevent_typeFilter<$PrismaModel>
    _max?: NestedEnumevent_typeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Enumrole_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.role_type | Enumrole_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.role_type[] | ListEnumrole_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.role_type[] | ListEnumrole_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrole_typeNullableFilter<$PrismaModel> | $Enums.role_type | null
  }

  export type EventTypeScalarRelationFilter = {
    is?: EventTypeWhereInput
    isNot?: EventTypeWhereInput
  }

  export type EventsOrganisedFacultyIDEvent_idCompoundUniqueInput = {
    FacultyID: number
    Event_id: number
  }

  export type EventsOrganisedCountOrderByAggregateInput = {
    FacultyID?: SortOrder
    Event_id?: SortOrder
    Title?: SortOrder
    Organizer?: SortOrder
    Location?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Description?: SortOrder
    Role?: SortOrder
    FundingAgency?: SortOrder
  }

  export type EventsOrganisedAvgOrderByAggregateInput = {
    FacultyID?: SortOrder
    Event_id?: SortOrder
  }

  export type EventsOrganisedMaxOrderByAggregateInput = {
    FacultyID?: SortOrder
    Event_id?: SortOrder
    Title?: SortOrder
    Organizer?: SortOrder
    Location?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Description?: SortOrder
    Role?: SortOrder
    FundingAgency?: SortOrder
  }

  export type EventsOrganisedMinOrderByAggregateInput = {
    FacultyID?: SortOrder
    Event_id?: SortOrder
    Title?: SortOrder
    Organizer?: SortOrder
    Location?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Description?: SortOrder
    Role?: SortOrder
    FundingAgency?: SortOrder
  }

  export type EventsOrganisedSumOrderByAggregateInput = {
    FacultyID?: SortOrder
    Event_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumrole_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role_type | Enumrole_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.role_type[] | ListEnumrole_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.role_type[] | ListEnumrole_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrole_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.role_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumrole_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumrole_typeNullableFilter<$PrismaModel>
  }

  export type AwardsCountOrderByAggregateInput = {
    AwardID?: SortOrder
    FacultyID?: SortOrder
    AwardName?: SortOrder
    AwardingBody?: SortOrder
    Location?: SortOrder
    YearAwarded?: SortOrder
  }

  export type AwardsAvgOrderByAggregateInput = {
    AwardID?: SortOrder
    FacultyID?: SortOrder
    YearAwarded?: SortOrder
  }

  export type AwardsMaxOrderByAggregateInput = {
    AwardID?: SortOrder
    FacultyID?: SortOrder
    AwardName?: SortOrder
    AwardingBody?: SortOrder
    Location?: SortOrder
    YearAwarded?: SortOrder
  }

  export type AwardsMinOrderByAggregateInput = {
    AwardID?: SortOrder
    FacultyID?: SortOrder
    AwardName?: SortOrder
    AwardingBody?: SortOrder
    Location?: SortOrder
    YearAwarded?: SortOrder
  }

  export type AwardsSumOrderByAggregateInput = {
    AwardID?: SortOrder
    FacultyID?: SortOrder
    YearAwarded?: SortOrder
  }

  export type TeachingExperienceCountOrderByAggregateInput = {
    ExperienceID?: SortOrder
    FacultyID?: SortOrder
    OrganizationName?: SortOrder
    Designation?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    NatureOfWork?: SortOrder
  }

  export type TeachingExperienceAvgOrderByAggregateInput = {
    ExperienceID?: SortOrder
    FacultyID?: SortOrder
  }

  export type TeachingExperienceMaxOrderByAggregateInput = {
    ExperienceID?: SortOrder
    FacultyID?: SortOrder
    OrganizationName?: SortOrder
    Designation?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    NatureOfWork?: SortOrder
  }

  export type TeachingExperienceMinOrderByAggregateInput = {
    ExperienceID?: SortOrder
    FacultyID?: SortOrder
    OrganizationName?: SortOrder
    Designation?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    NatureOfWork?: SortOrder
  }

  export type TeachingExperienceSumOrderByAggregateInput = {
    ExperienceID?: SortOrder
    FacultyID?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CitationMetricsCountOrderByAggregateInput = {
    MetricsID?: SortOrder
    FacultyID?: SortOrder
    YearRecorded?: SortOrder
    Source?: SortOrder
    HIndex?: SortOrder
    I10Index?: SortOrder
    TotalCitations?: SortOrder
    ImpactFactor?: SortOrder
  }

  export type CitationMetricsAvgOrderByAggregateInput = {
    MetricsID?: SortOrder
    FacultyID?: SortOrder
    YearRecorded?: SortOrder
    HIndex?: SortOrder
    I10Index?: SortOrder
    TotalCitations?: SortOrder
    ImpactFactor?: SortOrder
  }

  export type CitationMetricsMaxOrderByAggregateInput = {
    MetricsID?: SortOrder
    FacultyID?: SortOrder
    YearRecorded?: SortOrder
    Source?: SortOrder
    HIndex?: SortOrder
    I10Index?: SortOrder
    TotalCitations?: SortOrder
    ImpactFactor?: SortOrder
  }

  export type CitationMetricsMinOrderByAggregateInput = {
    MetricsID?: SortOrder
    FacultyID?: SortOrder
    YearRecorded?: SortOrder
    Source?: SortOrder
    HIndex?: SortOrder
    I10Index?: SortOrder
    TotalCitations?: SortOrder
    ImpactFactor?: SortOrder
  }

  export type CitationMetricsSumOrderByAggregateInput = {
    MetricsID?: SortOrder
    FacultyID?: SortOrder
    YearRecorded?: SortOrder
    HIndex?: SortOrder
    I10Index?: SortOrder
    TotalCitations?: SortOrder
    ImpactFactor?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type Enumpublication_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.publication_type | Enumpublication_typeFieldRefInput<$PrismaModel>
    in?: $Enums.publication_type[] | ListEnumpublication_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.publication_type[] | ListEnumpublication_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumpublication_typeFilter<$PrismaModel> | $Enums.publication_type
  }

  export type PublicationsListRelationFilter = {
    every?: PublicationsWhereInput
    some?: PublicationsWhereInput
    none?: PublicationsWhereInput
  }

  export type PublicationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TYPESCountOrderByAggregateInput = {
    TypeID?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
  }

  export type TYPESMaxOrderByAggregateInput = {
    TypeID?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
  }

  export type TYPESMinOrderByAggregateInput = {
    TypeID?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
  }

  export type Enumpublication_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.publication_type | Enumpublication_typeFieldRefInput<$PrismaModel>
    in?: $Enums.publication_type[] | ListEnumpublication_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.publication_type[] | ListEnumpublication_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumpublication_typeWithAggregatesFilter<$PrismaModel> | $Enums.publication_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpublication_typeFilter<$PrismaModel>
    _max?: NestedEnumpublication_typeFilter<$PrismaModel>
  }

  export type TYPESScalarRelationFilter = {
    is?: TYPESWhereInput
    isNot?: TYPESWhereInput
  }

  export type JournalPublicationDetailsNullableScalarRelationFilter = {
    is?: JournalPublicationDetailsWhereInput | null
    isNot?: JournalPublicationDetailsWhereInput | null
  }

  export type BookPublicationDetailsNullableScalarRelationFilter = {
    is?: BookPublicationDetailsWhereInput | null
    isNot?: BookPublicationDetailsWhereInput | null
  }

  export type ConferencePaperDetailsNullableScalarRelationFilter = {
    is?: ConferencePaperDetailsWhereInput | null
    isNot?: ConferencePaperDetailsWhereInput | null
  }

  export type PublicationsCountOrderByAggregateInput = {
    PublicationID?: SortOrder
    TypeID?: SortOrder
    Authors?: SortOrder
    Title?: SortOrder
    PublicationYear?: SortOrder
    FundingAgency?: SortOrder
  }

  export type PublicationsAvgOrderByAggregateInput = {
    PublicationID?: SortOrder
  }

  export type PublicationsMaxOrderByAggregateInput = {
    PublicationID?: SortOrder
    TypeID?: SortOrder
    Authors?: SortOrder
    Title?: SortOrder
    PublicationYear?: SortOrder
    FundingAgency?: SortOrder
  }

  export type PublicationsMinOrderByAggregateInput = {
    PublicationID?: SortOrder
    TypeID?: SortOrder
    Authors?: SortOrder
    Title?: SortOrder
    PublicationYear?: SortOrder
    FundingAgency?: SortOrder
  }

  export type PublicationsSumOrderByAggregateInput = {
    PublicationID?: SortOrder
  }

  export type PublicationsScalarRelationFilter = {
    is?: PublicationsWhereInput
    isNot?: PublicationsWhereInput
  }

  export type JournalPublicationDetailsCountOrderByAggregateInput = {
    PublicationID?: SortOrder
    Name?: SortOrder
    VolumeNumber?: SortOrder
    IssueNumber?: SortOrder
    ISSN_Number?: SortOrder
  }

  export type JournalPublicationDetailsAvgOrderByAggregateInput = {
    PublicationID?: SortOrder
    ISSN_Number?: SortOrder
  }

  export type JournalPublicationDetailsMaxOrderByAggregateInput = {
    PublicationID?: SortOrder
    Name?: SortOrder
    VolumeNumber?: SortOrder
    IssueNumber?: SortOrder
    ISSN_Number?: SortOrder
  }

  export type JournalPublicationDetailsMinOrderByAggregateInput = {
    PublicationID?: SortOrder
    Name?: SortOrder
    VolumeNumber?: SortOrder
    IssueNumber?: SortOrder
    ISSN_Number?: SortOrder
  }

  export type JournalPublicationDetailsSumOrderByAggregateInput = {
    PublicationID?: SortOrder
    ISSN_Number?: SortOrder
  }

  export type BookPublicationDetailsCountOrderByAggregateInput = {
    PublicationID?: SortOrder
    Publisher?: SortOrder
    Edition?: SortOrder
    VolumeNumber?: SortOrder
    ISBN_Number?: SortOrder
  }

  export type BookPublicationDetailsAvgOrderByAggregateInput = {
    PublicationID?: SortOrder
  }

  export type BookPublicationDetailsMaxOrderByAggregateInput = {
    PublicationID?: SortOrder
    Publisher?: SortOrder
    Edition?: SortOrder
    VolumeNumber?: SortOrder
    ISBN_Number?: SortOrder
  }

  export type BookPublicationDetailsMinOrderByAggregateInput = {
    PublicationID?: SortOrder
    Publisher?: SortOrder
    Edition?: SortOrder
    VolumeNumber?: SortOrder
    ISBN_Number?: SortOrder
  }

  export type BookPublicationDetailsSumOrderByAggregateInput = {
    PublicationID?: SortOrder
  }

  export type ConferencePaperDetailsCountOrderByAggregateInput = {
    PublicationID?: SortOrder
    Publisher?: SortOrder
    Location?: SortOrder
    PageNumbers?: SortOrder
  }

  export type ConferencePaperDetailsAvgOrderByAggregateInput = {
    PublicationID?: SortOrder
  }

  export type ConferencePaperDetailsMaxOrderByAggregateInput = {
    PublicationID?: SortOrder
    Publisher?: SortOrder
    Location?: SortOrder
    PageNumbers?: SortOrder
  }

  export type ConferencePaperDetailsMinOrderByAggregateInput = {
    PublicationID?: SortOrder
    Publisher?: SortOrder
    Location?: SortOrder
    PageNumbers?: SortOrder
  }

  export type ConferencePaperDetailsSumOrderByAggregateInput = {
    PublicationID?: SortOrder
  }

  export type FacultyPublicationLinkPublicationIDFacultyIDCompoundUniqueInput = {
    PublicationID: number
    FacultyID: number
  }

  export type FacultyPublicationLinkCountOrderByAggregateInput = {
    PublicationID?: SortOrder
    FacultyID?: SortOrder
    TypeOfIndexing?: SortOrder
  }

  export type FacultyPublicationLinkAvgOrderByAggregateInput = {
    PublicationID?: SortOrder
    FacultyID?: SortOrder
  }

  export type FacultyPublicationLinkMaxOrderByAggregateInput = {
    PublicationID?: SortOrder
    FacultyID?: SortOrder
    TypeOfIndexing?: SortOrder
  }

  export type FacultyPublicationLinkMinOrderByAggregateInput = {
    PublicationID?: SortOrder
    FacultyID?: SortOrder
    TypeOfIndexing?: SortOrder
  }

  export type FacultyPublicationLinkSumOrderByAggregateInput = {
    PublicationID?: SortOrder
    FacultyID?: SortOrder
  }

  export type PatentsTypeIDFacultyIDCompoundUniqueInput = {
    TypeID: string
    FacultyID: number
  }

  export type PatentsCountOrderByAggregateInput = {
    TypeID?: SortOrder
    FacultyID?: SortOrder
    Title?: SortOrder
    FilingDate?: SortOrder
    PublicationDate?: SortOrder
    PatentNumber?: SortOrder
    Authority?: SortOrder
    CollaborationInstitute?: SortOrder
  }

  export type PatentsAvgOrderByAggregateInput = {
    FacultyID?: SortOrder
  }

  export type PatentsMaxOrderByAggregateInput = {
    TypeID?: SortOrder
    FacultyID?: SortOrder
    Title?: SortOrder
    FilingDate?: SortOrder
    PublicationDate?: SortOrder
    PatentNumber?: SortOrder
    Authority?: SortOrder
    CollaborationInstitute?: SortOrder
  }

  export type PatentsMinOrderByAggregateInput = {
    TypeID?: SortOrder
    FacultyID?: SortOrder
    Title?: SortOrder
    FilingDate?: SortOrder
    PublicationDate?: SortOrder
    PatentNumber?: SortOrder
    Authority?: SortOrder
    CollaborationInstitute?: SortOrder
  }

  export type PatentsSumOrderByAggregateInput = {
    FacultyID?: SortOrder
  }

  export type ResearchProjectsTypeIDFacultyIDCompoundUniqueInput = {
    TypeID: string
    FacultyID: number
  }

  export type ResearchProjectsCountOrderByAggregateInput = {
    TypeID?: SortOrder
    FacultyID?: SortOrder
    Title?: SortOrder
    FundingAgency?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Budget?: SortOrder
  }

  export type ResearchProjectsAvgOrderByAggregateInput = {
    FacultyID?: SortOrder
    Budget?: SortOrder
  }

  export type ResearchProjectsMaxOrderByAggregateInput = {
    TypeID?: SortOrder
    FacultyID?: SortOrder
    Title?: SortOrder
    FundingAgency?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Budget?: SortOrder
  }

  export type ResearchProjectsMinOrderByAggregateInput = {
    TypeID?: SortOrder
    FacultyID?: SortOrder
    Title?: SortOrder
    FundingAgency?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Budget?: SortOrder
  }

  export type ResearchProjectsSumOrderByAggregateInput = {
    FacultyID?: SortOrder
    Budget?: SortOrder
  }

  export type FacultyCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<FacultyCreateWithoutDepartmentInput, FacultyUncheckedCreateWithoutDepartmentInput> | FacultyCreateWithoutDepartmentInput[] | FacultyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutDepartmentInput | FacultyCreateOrConnectWithoutDepartmentInput[]
    createMany?: FacultyCreateManyDepartmentInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type FacultyUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<FacultyCreateWithoutDepartmentInput, FacultyUncheckedCreateWithoutDepartmentInput> | FacultyCreateWithoutDepartmentInput[] | FacultyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutDepartmentInput | FacultyCreateOrConnectWithoutDepartmentInput[]
    createMany?: FacultyCreateManyDepartmentInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FacultyUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<FacultyCreateWithoutDepartmentInput, FacultyUncheckedCreateWithoutDepartmentInput> | FacultyCreateWithoutDepartmentInput[] | FacultyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutDepartmentInput | FacultyCreateOrConnectWithoutDepartmentInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutDepartmentInput | FacultyUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: FacultyCreateManyDepartmentInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutDepartmentInput | FacultyUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutDepartmentInput | FacultyUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FacultyUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<FacultyCreateWithoutDepartmentInput, FacultyUncheckedCreateWithoutDepartmentInput> | FacultyCreateWithoutDepartmentInput[] | FacultyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutDepartmentInput | FacultyCreateOrConnectWithoutDepartmentInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutDepartmentInput | FacultyUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: FacultyCreateManyDepartmentInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutDepartmentInput | FacultyUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutDepartmentInput | FacultyUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutFacultyInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput
    connect?: DepartmentWhereUniqueInput
  }

  export type SubjectTaughtCreateNestedManyWithoutFacultyInput = {
    create?: XOR<SubjectTaughtCreateWithoutFacultyInput, SubjectTaughtUncheckedCreateWithoutFacultyInput> | SubjectTaughtCreateWithoutFacultyInput[] | SubjectTaughtUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: SubjectTaughtCreateOrConnectWithoutFacultyInput | SubjectTaughtCreateOrConnectWithoutFacultyInput[]
    createMany?: SubjectTaughtCreateManyFacultyInputEnvelope
    connect?: SubjectTaughtWhereUniqueInput | SubjectTaughtWhereUniqueInput[]
  }

  export type FacultyQualificationCreateNestedManyWithoutFacultyInput = {
    create?: XOR<FacultyQualificationCreateWithoutFacultyInput, FacultyQualificationUncheckedCreateWithoutFacultyInput> | FacultyQualificationCreateWithoutFacultyInput[] | FacultyQualificationUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultyQualificationCreateOrConnectWithoutFacultyInput | FacultyQualificationCreateOrConnectWithoutFacultyInput[]
    createMany?: FacultyQualificationCreateManyFacultyInputEnvelope
    connect?: FacultyQualificationWhereUniqueInput | FacultyQualificationWhereUniqueInput[]
  }

  export type OutReachActivitiesCreateNestedManyWithoutFacultyInput = {
    create?: XOR<OutReachActivitiesCreateWithoutFacultyInput, OutReachActivitiesUncheckedCreateWithoutFacultyInput> | OutReachActivitiesCreateWithoutFacultyInput[] | OutReachActivitiesUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OutReachActivitiesCreateOrConnectWithoutFacultyInput | OutReachActivitiesCreateOrConnectWithoutFacultyInput[]
    createMany?: OutReachActivitiesCreateManyFacultyInputEnvelope
    connect?: OutReachActivitiesWhereUniqueInput | OutReachActivitiesWhereUniqueInput[]
  }

  export type EventsOrganisedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<EventsOrganisedCreateWithoutFacultyInput, EventsOrganisedUncheckedCreateWithoutFacultyInput> | EventsOrganisedCreateWithoutFacultyInput[] | EventsOrganisedUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: EventsOrganisedCreateOrConnectWithoutFacultyInput | EventsOrganisedCreateOrConnectWithoutFacultyInput[]
    createMany?: EventsOrganisedCreateManyFacultyInputEnvelope
    connect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
  }

  export type AwardsCreateNestedManyWithoutFacultyInput = {
    create?: XOR<AwardsCreateWithoutFacultyInput, AwardsUncheckedCreateWithoutFacultyInput> | AwardsCreateWithoutFacultyInput[] | AwardsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: AwardsCreateOrConnectWithoutFacultyInput | AwardsCreateOrConnectWithoutFacultyInput[]
    createMany?: AwardsCreateManyFacultyInputEnvelope
    connect?: AwardsWhereUniqueInput | AwardsWhereUniqueInput[]
  }

  export type TeachingExperienceCreateNestedManyWithoutFacultyInput = {
    create?: XOR<TeachingExperienceCreateWithoutFacultyInput, TeachingExperienceUncheckedCreateWithoutFacultyInput> | TeachingExperienceCreateWithoutFacultyInput[] | TeachingExperienceUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: TeachingExperienceCreateOrConnectWithoutFacultyInput | TeachingExperienceCreateOrConnectWithoutFacultyInput[]
    createMany?: TeachingExperienceCreateManyFacultyInputEnvelope
    connect?: TeachingExperienceWhereUniqueInput | TeachingExperienceWhereUniqueInput[]
  }

  export type CitationMetricsCreateNestedManyWithoutFacultyInput = {
    create?: XOR<CitationMetricsCreateWithoutFacultyInput, CitationMetricsUncheckedCreateWithoutFacultyInput> | CitationMetricsCreateWithoutFacultyInput[] | CitationMetricsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CitationMetricsCreateOrConnectWithoutFacultyInput | CitationMetricsCreateOrConnectWithoutFacultyInput[]
    createMany?: CitationMetricsCreateManyFacultyInputEnvelope
    connect?: CitationMetricsWhereUniqueInput | CitationMetricsWhereUniqueInput[]
  }

  export type FacultyPublicationLinkCreateNestedManyWithoutFacultyInput = {
    create?: XOR<FacultyPublicationLinkCreateWithoutFacultyInput, FacultyPublicationLinkUncheckedCreateWithoutFacultyInput> | FacultyPublicationLinkCreateWithoutFacultyInput[] | FacultyPublicationLinkUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultyPublicationLinkCreateOrConnectWithoutFacultyInput | FacultyPublicationLinkCreateOrConnectWithoutFacultyInput[]
    createMany?: FacultyPublicationLinkCreateManyFacultyInputEnvelope
    connect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
  }

  export type PatentsCreateNestedManyWithoutFacultyInput = {
    create?: XOR<PatentsCreateWithoutFacultyInput, PatentsUncheckedCreateWithoutFacultyInput> | PatentsCreateWithoutFacultyInput[] | PatentsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: PatentsCreateOrConnectWithoutFacultyInput | PatentsCreateOrConnectWithoutFacultyInput[]
    createMany?: PatentsCreateManyFacultyInputEnvelope
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
  }

  export type ResearchProjectsCreateNestedManyWithoutFacultyInput = {
    create?: XOR<ResearchProjectsCreateWithoutFacultyInput, ResearchProjectsUncheckedCreateWithoutFacultyInput> | ResearchProjectsCreateWithoutFacultyInput[] | ResearchProjectsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: ResearchProjectsCreateOrConnectWithoutFacultyInput | ResearchProjectsCreateOrConnectWithoutFacultyInput[]
    createMany?: ResearchProjectsCreateManyFacultyInputEnvelope
    connect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
  }

  export type SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<SubjectTaughtCreateWithoutFacultyInput, SubjectTaughtUncheckedCreateWithoutFacultyInput> | SubjectTaughtCreateWithoutFacultyInput[] | SubjectTaughtUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: SubjectTaughtCreateOrConnectWithoutFacultyInput | SubjectTaughtCreateOrConnectWithoutFacultyInput[]
    createMany?: SubjectTaughtCreateManyFacultyInputEnvelope
    connect?: SubjectTaughtWhereUniqueInput | SubjectTaughtWhereUniqueInput[]
  }

  export type FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<FacultyQualificationCreateWithoutFacultyInput, FacultyQualificationUncheckedCreateWithoutFacultyInput> | FacultyQualificationCreateWithoutFacultyInput[] | FacultyQualificationUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultyQualificationCreateOrConnectWithoutFacultyInput | FacultyQualificationCreateOrConnectWithoutFacultyInput[]
    createMany?: FacultyQualificationCreateManyFacultyInputEnvelope
    connect?: FacultyQualificationWhereUniqueInput | FacultyQualificationWhereUniqueInput[]
  }

  export type OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<OutReachActivitiesCreateWithoutFacultyInput, OutReachActivitiesUncheckedCreateWithoutFacultyInput> | OutReachActivitiesCreateWithoutFacultyInput[] | OutReachActivitiesUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OutReachActivitiesCreateOrConnectWithoutFacultyInput | OutReachActivitiesCreateOrConnectWithoutFacultyInput[]
    createMany?: OutReachActivitiesCreateManyFacultyInputEnvelope
    connect?: OutReachActivitiesWhereUniqueInput | OutReachActivitiesWhereUniqueInput[]
  }

  export type EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<EventsOrganisedCreateWithoutFacultyInput, EventsOrganisedUncheckedCreateWithoutFacultyInput> | EventsOrganisedCreateWithoutFacultyInput[] | EventsOrganisedUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: EventsOrganisedCreateOrConnectWithoutFacultyInput | EventsOrganisedCreateOrConnectWithoutFacultyInput[]
    createMany?: EventsOrganisedCreateManyFacultyInputEnvelope
    connect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
  }

  export type AwardsUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<AwardsCreateWithoutFacultyInput, AwardsUncheckedCreateWithoutFacultyInput> | AwardsCreateWithoutFacultyInput[] | AwardsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: AwardsCreateOrConnectWithoutFacultyInput | AwardsCreateOrConnectWithoutFacultyInput[]
    createMany?: AwardsCreateManyFacultyInputEnvelope
    connect?: AwardsWhereUniqueInput | AwardsWhereUniqueInput[]
  }

  export type TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<TeachingExperienceCreateWithoutFacultyInput, TeachingExperienceUncheckedCreateWithoutFacultyInput> | TeachingExperienceCreateWithoutFacultyInput[] | TeachingExperienceUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: TeachingExperienceCreateOrConnectWithoutFacultyInput | TeachingExperienceCreateOrConnectWithoutFacultyInput[]
    createMany?: TeachingExperienceCreateManyFacultyInputEnvelope
    connect?: TeachingExperienceWhereUniqueInput | TeachingExperienceWhereUniqueInput[]
  }

  export type CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<CitationMetricsCreateWithoutFacultyInput, CitationMetricsUncheckedCreateWithoutFacultyInput> | CitationMetricsCreateWithoutFacultyInput[] | CitationMetricsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CitationMetricsCreateOrConnectWithoutFacultyInput | CitationMetricsCreateOrConnectWithoutFacultyInput[]
    createMany?: CitationMetricsCreateManyFacultyInputEnvelope
    connect?: CitationMetricsWhereUniqueInput | CitationMetricsWhereUniqueInput[]
  }

  export type FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<FacultyPublicationLinkCreateWithoutFacultyInput, FacultyPublicationLinkUncheckedCreateWithoutFacultyInput> | FacultyPublicationLinkCreateWithoutFacultyInput[] | FacultyPublicationLinkUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultyPublicationLinkCreateOrConnectWithoutFacultyInput | FacultyPublicationLinkCreateOrConnectWithoutFacultyInput[]
    createMany?: FacultyPublicationLinkCreateManyFacultyInputEnvelope
    connect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
  }

  export type PatentsUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<PatentsCreateWithoutFacultyInput, PatentsUncheckedCreateWithoutFacultyInput> | PatentsCreateWithoutFacultyInput[] | PatentsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: PatentsCreateOrConnectWithoutFacultyInput | PatentsCreateOrConnectWithoutFacultyInput[]
    createMany?: PatentsCreateManyFacultyInputEnvelope
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
  }

  export type ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<ResearchProjectsCreateWithoutFacultyInput, ResearchProjectsUncheckedCreateWithoutFacultyInput> | ResearchProjectsCreateWithoutFacultyInput[] | ResearchProjectsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: ResearchProjectsCreateOrConnectWithoutFacultyInput | ResearchProjectsCreateOrConnectWithoutFacultyInput[]
    createMany?: ResearchProjectsCreateManyFacultyInputEnvelope
    connect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DepartmentUpdateOneRequiredWithoutFacultyNestedInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput
    upsert?: DepartmentUpsertWithoutFacultyInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutFacultyInput, DepartmentUpdateWithoutFacultyInput>, DepartmentUncheckedUpdateWithoutFacultyInput>
  }

  export type SubjectTaughtUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<SubjectTaughtCreateWithoutFacultyInput, SubjectTaughtUncheckedCreateWithoutFacultyInput> | SubjectTaughtCreateWithoutFacultyInput[] | SubjectTaughtUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: SubjectTaughtCreateOrConnectWithoutFacultyInput | SubjectTaughtCreateOrConnectWithoutFacultyInput[]
    upsert?: SubjectTaughtUpsertWithWhereUniqueWithoutFacultyInput | SubjectTaughtUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: SubjectTaughtCreateManyFacultyInputEnvelope
    set?: SubjectTaughtWhereUniqueInput | SubjectTaughtWhereUniqueInput[]
    disconnect?: SubjectTaughtWhereUniqueInput | SubjectTaughtWhereUniqueInput[]
    delete?: SubjectTaughtWhereUniqueInput | SubjectTaughtWhereUniqueInput[]
    connect?: SubjectTaughtWhereUniqueInput | SubjectTaughtWhereUniqueInput[]
    update?: SubjectTaughtUpdateWithWhereUniqueWithoutFacultyInput | SubjectTaughtUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: SubjectTaughtUpdateManyWithWhereWithoutFacultyInput | SubjectTaughtUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: SubjectTaughtScalarWhereInput | SubjectTaughtScalarWhereInput[]
  }

  export type FacultyQualificationUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<FacultyQualificationCreateWithoutFacultyInput, FacultyQualificationUncheckedCreateWithoutFacultyInput> | FacultyQualificationCreateWithoutFacultyInput[] | FacultyQualificationUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultyQualificationCreateOrConnectWithoutFacultyInput | FacultyQualificationCreateOrConnectWithoutFacultyInput[]
    upsert?: FacultyQualificationUpsertWithWhereUniqueWithoutFacultyInput | FacultyQualificationUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: FacultyQualificationCreateManyFacultyInputEnvelope
    set?: FacultyQualificationWhereUniqueInput | FacultyQualificationWhereUniqueInput[]
    disconnect?: FacultyQualificationWhereUniqueInput | FacultyQualificationWhereUniqueInput[]
    delete?: FacultyQualificationWhereUniqueInput | FacultyQualificationWhereUniqueInput[]
    connect?: FacultyQualificationWhereUniqueInput | FacultyQualificationWhereUniqueInput[]
    update?: FacultyQualificationUpdateWithWhereUniqueWithoutFacultyInput | FacultyQualificationUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: FacultyQualificationUpdateManyWithWhereWithoutFacultyInput | FacultyQualificationUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: FacultyQualificationScalarWhereInput | FacultyQualificationScalarWhereInput[]
  }

  export type OutReachActivitiesUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<OutReachActivitiesCreateWithoutFacultyInput, OutReachActivitiesUncheckedCreateWithoutFacultyInput> | OutReachActivitiesCreateWithoutFacultyInput[] | OutReachActivitiesUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OutReachActivitiesCreateOrConnectWithoutFacultyInput | OutReachActivitiesCreateOrConnectWithoutFacultyInput[]
    upsert?: OutReachActivitiesUpsertWithWhereUniqueWithoutFacultyInput | OutReachActivitiesUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: OutReachActivitiesCreateManyFacultyInputEnvelope
    set?: OutReachActivitiesWhereUniqueInput | OutReachActivitiesWhereUniqueInput[]
    disconnect?: OutReachActivitiesWhereUniqueInput | OutReachActivitiesWhereUniqueInput[]
    delete?: OutReachActivitiesWhereUniqueInput | OutReachActivitiesWhereUniqueInput[]
    connect?: OutReachActivitiesWhereUniqueInput | OutReachActivitiesWhereUniqueInput[]
    update?: OutReachActivitiesUpdateWithWhereUniqueWithoutFacultyInput | OutReachActivitiesUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: OutReachActivitiesUpdateManyWithWhereWithoutFacultyInput | OutReachActivitiesUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: OutReachActivitiesScalarWhereInput | OutReachActivitiesScalarWhereInput[]
  }

  export type EventsOrganisedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<EventsOrganisedCreateWithoutFacultyInput, EventsOrganisedUncheckedCreateWithoutFacultyInput> | EventsOrganisedCreateWithoutFacultyInput[] | EventsOrganisedUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: EventsOrganisedCreateOrConnectWithoutFacultyInput | EventsOrganisedCreateOrConnectWithoutFacultyInput[]
    upsert?: EventsOrganisedUpsertWithWhereUniqueWithoutFacultyInput | EventsOrganisedUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: EventsOrganisedCreateManyFacultyInputEnvelope
    set?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    disconnect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    delete?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    connect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    update?: EventsOrganisedUpdateWithWhereUniqueWithoutFacultyInput | EventsOrganisedUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: EventsOrganisedUpdateManyWithWhereWithoutFacultyInput | EventsOrganisedUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: EventsOrganisedScalarWhereInput | EventsOrganisedScalarWhereInput[]
  }

  export type AwardsUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<AwardsCreateWithoutFacultyInput, AwardsUncheckedCreateWithoutFacultyInput> | AwardsCreateWithoutFacultyInput[] | AwardsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: AwardsCreateOrConnectWithoutFacultyInput | AwardsCreateOrConnectWithoutFacultyInput[]
    upsert?: AwardsUpsertWithWhereUniqueWithoutFacultyInput | AwardsUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: AwardsCreateManyFacultyInputEnvelope
    set?: AwardsWhereUniqueInput | AwardsWhereUniqueInput[]
    disconnect?: AwardsWhereUniqueInput | AwardsWhereUniqueInput[]
    delete?: AwardsWhereUniqueInput | AwardsWhereUniqueInput[]
    connect?: AwardsWhereUniqueInput | AwardsWhereUniqueInput[]
    update?: AwardsUpdateWithWhereUniqueWithoutFacultyInput | AwardsUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: AwardsUpdateManyWithWhereWithoutFacultyInput | AwardsUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: AwardsScalarWhereInput | AwardsScalarWhereInput[]
  }

  export type TeachingExperienceUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<TeachingExperienceCreateWithoutFacultyInput, TeachingExperienceUncheckedCreateWithoutFacultyInput> | TeachingExperienceCreateWithoutFacultyInput[] | TeachingExperienceUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: TeachingExperienceCreateOrConnectWithoutFacultyInput | TeachingExperienceCreateOrConnectWithoutFacultyInput[]
    upsert?: TeachingExperienceUpsertWithWhereUniqueWithoutFacultyInput | TeachingExperienceUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: TeachingExperienceCreateManyFacultyInputEnvelope
    set?: TeachingExperienceWhereUniqueInput | TeachingExperienceWhereUniqueInput[]
    disconnect?: TeachingExperienceWhereUniqueInput | TeachingExperienceWhereUniqueInput[]
    delete?: TeachingExperienceWhereUniqueInput | TeachingExperienceWhereUniqueInput[]
    connect?: TeachingExperienceWhereUniqueInput | TeachingExperienceWhereUniqueInput[]
    update?: TeachingExperienceUpdateWithWhereUniqueWithoutFacultyInput | TeachingExperienceUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: TeachingExperienceUpdateManyWithWhereWithoutFacultyInput | TeachingExperienceUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: TeachingExperienceScalarWhereInput | TeachingExperienceScalarWhereInput[]
  }

  export type CitationMetricsUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<CitationMetricsCreateWithoutFacultyInput, CitationMetricsUncheckedCreateWithoutFacultyInput> | CitationMetricsCreateWithoutFacultyInput[] | CitationMetricsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CitationMetricsCreateOrConnectWithoutFacultyInput | CitationMetricsCreateOrConnectWithoutFacultyInput[]
    upsert?: CitationMetricsUpsertWithWhereUniqueWithoutFacultyInput | CitationMetricsUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: CitationMetricsCreateManyFacultyInputEnvelope
    set?: CitationMetricsWhereUniqueInput | CitationMetricsWhereUniqueInput[]
    disconnect?: CitationMetricsWhereUniqueInput | CitationMetricsWhereUniqueInput[]
    delete?: CitationMetricsWhereUniqueInput | CitationMetricsWhereUniqueInput[]
    connect?: CitationMetricsWhereUniqueInput | CitationMetricsWhereUniqueInput[]
    update?: CitationMetricsUpdateWithWhereUniqueWithoutFacultyInput | CitationMetricsUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: CitationMetricsUpdateManyWithWhereWithoutFacultyInput | CitationMetricsUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: CitationMetricsScalarWhereInput | CitationMetricsScalarWhereInput[]
  }

  export type FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<FacultyPublicationLinkCreateWithoutFacultyInput, FacultyPublicationLinkUncheckedCreateWithoutFacultyInput> | FacultyPublicationLinkCreateWithoutFacultyInput[] | FacultyPublicationLinkUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultyPublicationLinkCreateOrConnectWithoutFacultyInput | FacultyPublicationLinkCreateOrConnectWithoutFacultyInput[]
    upsert?: FacultyPublicationLinkUpsertWithWhereUniqueWithoutFacultyInput | FacultyPublicationLinkUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: FacultyPublicationLinkCreateManyFacultyInputEnvelope
    set?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    disconnect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    delete?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    connect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    update?: FacultyPublicationLinkUpdateWithWhereUniqueWithoutFacultyInput | FacultyPublicationLinkUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: FacultyPublicationLinkUpdateManyWithWhereWithoutFacultyInput | FacultyPublicationLinkUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: FacultyPublicationLinkScalarWhereInput | FacultyPublicationLinkScalarWhereInput[]
  }

  export type PatentsUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<PatentsCreateWithoutFacultyInput, PatentsUncheckedCreateWithoutFacultyInput> | PatentsCreateWithoutFacultyInput[] | PatentsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: PatentsCreateOrConnectWithoutFacultyInput | PatentsCreateOrConnectWithoutFacultyInput[]
    upsert?: PatentsUpsertWithWhereUniqueWithoutFacultyInput | PatentsUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: PatentsCreateManyFacultyInputEnvelope
    set?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    disconnect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    delete?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    update?: PatentsUpdateWithWhereUniqueWithoutFacultyInput | PatentsUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: PatentsUpdateManyWithWhereWithoutFacultyInput | PatentsUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: PatentsScalarWhereInput | PatentsScalarWhereInput[]
  }

  export type ResearchProjectsUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<ResearchProjectsCreateWithoutFacultyInput, ResearchProjectsUncheckedCreateWithoutFacultyInput> | ResearchProjectsCreateWithoutFacultyInput[] | ResearchProjectsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: ResearchProjectsCreateOrConnectWithoutFacultyInput | ResearchProjectsCreateOrConnectWithoutFacultyInput[]
    upsert?: ResearchProjectsUpsertWithWhereUniqueWithoutFacultyInput | ResearchProjectsUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: ResearchProjectsCreateManyFacultyInputEnvelope
    set?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    disconnect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    delete?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    connect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    update?: ResearchProjectsUpdateWithWhereUniqueWithoutFacultyInput | ResearchProjectsUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: ResearchProjectsUpdateManyWithWhereWithoutFacultyInput | ResearchProjectsUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: ResearchProjectsScalarWhereInput | ResearchProjectsScalarWhereInput[]
  }

  export type SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<SubjectTaughtCreateWithoutFacultyInput, SubjectTaughtUncheckedCreateWithoutFacultyInput> | SubjectTaughtCreateWithoutFacultyInput[] | SubjectTaughtUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: SubjectTaughtCreateOrConnectWithoutFacultyInput | SubjectTaughtCreateOrConnectWithoutFacultyInput[]
    upsert?: SubjectTaughtUpsertWithWhereUniqueWithoutFacultyInput | SubjectTaughtUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: SubjectTaughtCreateManyFacultyInputEnvelope
    set?: SubjectTaughtWhereUniqueInput | SubjectTaughtWhereUniqueInput[]
    disconnect?: SubjectTaughtWhereUniqueInput | SubjectTaughtWhereUniqueInput[]
    delete?: SubjectTaughtWhereUniqueInput | SubjectTaughtWhereUniqueInput[]
    connect?: SubjectTaughtWhereUniqueInput | SubjectTaughtWhereUniqueInput[]
    update?: SubjectTaughtUpdateWithWhereUniqueWithoutFacultyInput | SubjectTaughtUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: SubjectTaughtUpdateManyWithWhereWithoutFacultyInput | SubjectTaughtUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: SubjectTaughtScalarWhereInput | SubjectTaughtScalarWhereInput[]
  }

  export type FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<FacultyQualificationCreateWithoutFacultyInput, FacultyQualificationUncheckedCreateWithoutFacultyInput> | FacultyQualificationCreateWithoutFacultyInput[] | FacultyQualificationUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultyQualificationCreateOrConnectWithoutFacultyInput | FacultyQualificationCreateOrConnectWithoutFacultyInput[]
    upsert?: FacultyQualificationUpsertWithWhereUniqueWithoutFacultyInput | FacultyQualificationUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: FacultyQualificationCreateManyFacultyInputEnvelope
    set?: FacultyQualificationWhereUniqueInput | FacultyQualificationWhereUniqueInput[]
    disconnect?: FacultyQualificationWhereUniqueInput | FacultyQualificationWhereUniqueInput[]
    delete?: FacultyQualificationWhereUniqueInput | FacultyQualificationWhereUniqueInput[]
    connect?: FacultyQualificationWhereUniqueInput | FacultyQualificationWhereUniqueInput[]
    update?: FacultyQualificationUpdateWithWhereUniqueWithoutFacultyInput | FacultyQualificationUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: FacultyQualificationUpdateManyWithWhereWithoutFacultyInput | FacultyQualificationUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: FacultyQualificationScalarWhereInput | FacultyQualificationScalarWhereInput[]
  }

  export type OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<OutReachActivitiesCreateWithoutFacultyInput, OutReachActivitiesUncheckedCreateWithoutFacultyInput> | OutReachActivitiesCreateWithoutFacultyInput[] | OutReachActivitiesUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OutReachActivitiesCreateOrConnectWithoutFacultyInput | OutReachActivitiesCreateOrConnectWithoutFacultyInput[]
    upsert?: OutReachActivitiesUpsertWithWhereUniqueWithoutFacultyInput | OutReachActivitiesUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: OutReachActivitiesCreateManyFacultyInputEnvelope
    set?: OutReachActivitiesWhereUniqueInput | OutReachActivitiesWhereUniqueInput[]
    disconnect?: OutReachActivitiesWhereUniqueInput | OutReachActivitiesWhereUniqueInput[]
    delete?: OutReachActivitiesWhereUniqueInput | OutReachActivitiesWhereUniqueInput[]
    connect?: OutReachActivitiesWhereUniqueInput | OutReachActivitiesWhereUniqueInput[]
    update?: OutReachActivitiesUpdateWithWhereUniqueWithoutFacultyInput | OutReachActivitiesUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: OutReachActivitiesUpdateManyWithWhereWithoutFacultyInput | OutReachActivitiesUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: OutReachActivitiesScalarWhereInput | OutReachActivitiesScalarWhereInput[]
  }

  export type EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<EventsOrganisedCreateWithoutFacultyInput, EventsOrganisedUncheckedCreateWithoutFacultyInput> | EventsOrganisedCreateWithoutFacultyInput[] | EventsOrganisedUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: EventsOrganisedCreateOrConnectWithoutFacultyInput | EventsOrganisedCreateOrConnectWithoutFacultyInput[]
    upsert?: EventsOrganisedUpsertWithWhereUniqueWithoutFacultyInput | EventsOrganisedUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: EventsOrganisedCreateManyFacultyInputEnvelope
    set?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    disconnect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    delete?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    connect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    update?: EventsOrganisedUpdateWithWhereUniqueWithoutFacultyInput | EventsOrganisedUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: EventsOrganisedUpdateManyWithWhereWithoutFacultyInput | EventsOrganisedUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: EventsOrganisedScalarWhereInput | EventsOrganisedScalarWhereInput[]
  }

  export type AwardsUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<AwardsCreateWithoutFacultyInput, AwardsUncheckedCreateWithoutFacultyInput> | AwardsCreateWithoutFacultyInput[] | AwardsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: AwardsCreateOrConnectWithoutFacultyInput | AwardsCreateOrConnectWithoutFacultyInput[]
    upsert?: AwardsUpsertWithWhereUniqueWithoutFacultyInput | AwardsUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: AwardsCreateManyFacultyInputEnvelope
    set?: AwardsWhereUniqueInput | AwardsWhereUniqueInput[]
    disconnect?: AwardsWhereUniqueInput | AwardsWhereUniqueInput[]
    delete?: AwardsWhereUniqueInput | AwardsWhereUniqueInput[]
    connect?: AwardsWhereUniqueInput | AwardsWhereUniqueInput[]
    update?: AwardsUpdateWithWhereUniqueWithoutFacultyInput | AwardsUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: AwardsUpdateManyWithWhereWithoutFacultyInput | AwardsUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: AwardsScalarWhereInput | AwardsScalarWhereInput[]
  }

  export type TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<TeachingExperienceCreateWithoutFacultyInput, TeachingExperienceUncheckedCreateWithoutFacultyInput> | TeachingExperienceCreateWithoutFacultyInput[] | TeachingExperienceUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: TeachingExperienceCreateOrConnectWithoutFacultyInput | TeachingExperienceCreateOrConnectWithoutFacultyInput[]
    upsert?: TeachingExperienceUpsertWithWhereUniqueWithoutFacultyInput | TeachingExperienceUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: TeachingExperienceCreateManyFacultyInputEnvelope
    set?: TeachingExperienceWhereUniqueInput | TeachingExperienceWhereUniqueInput[]
    disconnect?: TeachingExperienceWhereUniqueInput | TeachingExperienceWhereUniqueInput[]
    delete?: TeachingExperienceWhereUniqueInput | TeachingExperienceWhereUniqueInput[]
    connect?: TeachingExperienceWhereUniqueInput | TeachingExperienceWhereUniqueInput[]
    update?: TeachingExperienceUpdateWithWhereUniqueWithoutFacultyInput | TeachingExperienceUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: TeachingExperienceUpdateManyWithWhereWithoutFacultyInput | TeachingExperienceUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: TeachingExperienceScalarWhereInput | TeachingExperienceScalarWhereInput[]
  }

  export type CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<CitationMetricsCreateWithoutFacultyInput, CitationMetricsUncheckedCreateWithoutFacultyInput> | CitationMetricsCreateWithoutFacultyInput[] | CitationMetricsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CitationMetricsCreateOrConnectWithoutFacultyInput | CitationMetricsCreateOrConnectWithoutFacultyInput[]
    upsert?: CitationMetricsUpsertWithWhereUniqueWithoutFacultyInput | CitationMetricsUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: CitationMetricsCreateManyFacultyInputEnvelope
    set?: CitationMetricsWhereUniqueInput | CitationMetricsWhereUniqueInput[]
    disconnect?: CitationMetricsWhereUniqueInput | CitationMetricsWhereUniqueInput[]
    delete?: CitationMetricsWhereUniqueInput | CitationMetricsWhereUniqueInput[]
    connect?: CitationMetricsWhereUniqueInput | CitationMetricsWhereUniqueInput[]
    update?: CitationMetricsUpdateWithWhereUniqueWithoutFacultyInput | CitationMetricsUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: CitationMetricsUpdateManyWithWhereWithoutFacultyInput | CitationMetricsUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: CitationMetricsScalarWhereInput | CitationMetricsScalarWhereInput[]
  }

  export type FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<FacultyPublicationLinkCreateWithoutFacultyInput, FacultyPublicationLinkUncheckedCreateWithoutFacultyInput> | FacultyPublicationLinkCreateWithoutFacultyInput[] | FacultyPublicationLinkUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultyPublicationLinkCreateOrConnectWithoutFacultyInput | FacultyPublicationLinkCreateOrConnectWithoutFacultyInput[]
    upsert?: FacultyPublicationLinkUpsertWithWhereUniqueWithoutFacultyInput | FacultyPublicationLinkUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: FacultyPublicationLinkCreateManyFacultyInputEnvelope
    set?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    disconnect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    delete?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    connect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    update?: FacultyPublicationLinkUpdateWithWhereUniqueWithoutFacultyInput | FacultyPublicationLinkUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: FacultyPublicationLinkUpdateManyWithWhereWithoutFacultyInput | FacultyPublicationLinkUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: FacultyPublicationLinkScalarWhereInput | FacultyPublicationLinkScalarWhereInput[]
  }

  export type PatentsUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<PatentsCreateWithoutFacultyInput, PatentsUncheckedCreateWithoutFacultyInput> | PatentsCreateWithoutFacultyInput[] | PatentsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: PatentsCreateOrConnectWithoutFacultyInput | PatentsCreateOrConnectWithoutFacultyInput[]
    upsert?: PatentsUpsertWithWhereUniqueWithoutFacultyInput | PatentsUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: PatentsCreateManyFacultyInputEnvelope
    set?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    disconnect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    delete?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    update?: PatentsUpdateWithWhereUniqueWithoutFacultyInput | PatentsUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: PatentsUpdateManyWithWhereWithoutFacultyInput | PatentsUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: PatentsScalarWhereInput | PatentsScalarWhereInput[]
  }

  export type ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<ResearchProjectsCreateWithoutFacultyInput, ResearchProjectsUncheckedCreateWithoutFacultyInput> | ResearchProjectsCreateWithoutFacultyInput[] | ResearchProjectsUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: ResearchProjectsCreateOrConnectWithoutFacultyInput | ResearchProjectsCreateOrConnectWithoutFacultyInput[]
    upsert?: ResearchProjectsUpsertWithWhereUniqueWithoutFacultyInput | ResearchProjectsUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: ResearchProjectsCreateManyFacultyInputEnvelope
    set?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    disconnect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    delete?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    connect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    update?: ResearchProjectsUpdateWithWhereUniqueWithoutFacultyInput | ResearchProjectsUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: ResearchProjectsUpdateManyWithWhereWithoutFacultyInput | ResearchProjectsUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: ResearchProjectsScalarWhereInput | ResearchProjectsScalarWhereInput[]
  }

  export type FacultyCreateNestedOneWithoutSubjectsTaughtInput = {
    create?: XOR<FacultyCreateWithoutSubjectsTaughtInput, FacultyUncheckedCreateWithoutSubjectsTaughtInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutSubjectsTaughtInput
    connect?: FacultyWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FacultyUpdateOneRequiredWithoutSubjectsTaughtNestedInput = {
    create?: XOR<FacultyCreateWithoutSubjectsTaughtInput, FacultyUncheckedCreateWithoutSubjectsTaughtInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutSubjectsTaughtInput
    upsert?: FacultyUpsertWithoutSubjectsTaughtInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutSubjectsTaughtInput, FacultyUpdateWithoutSubjectsTaughtInput>, FacultyUncheckedUpdateWithoutSubjectsTaughtInput>
  }

  export type FacultyCreateNestedOneWithoutQualificationsInput = {
    create?: XOR<FacultyCreateWithoutQualificationsInput, FacultyUncheckedCreateWithoutQualificationsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutQualificationsInput
    connect?: FacultyWhereUniqueInput
  }

  export type FacultyUpdateOneRequiredWithoutQualificationsNestedInput = {
    create?: XOR<FacultyCreateWithoutQualificationsInput, FacultyUncheckedCreateWithoutQualificationsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutQualificationsInput
    upsert?: FacultyUpsertWithoutQualificationsInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutQualificationsInput, FacultyUpdateWithoutQualificationsInput>, FacultyUncheckedUpdateWithoutQualificationsInput>
  }

  export type FacultyCreateNestedOneWithoutOutreachActivitiesInput = {
    create?: XOR<FacultyCreateWithoutOutreachActivitiesInput, FacultyUncheckedCreateWithoutOutreachActivitiesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutOutreachActivitiesInput
    connect?: FacultyWhereUniqueInput
  }

  export type FacultyUpdateOneRequiredWithoutOutreachActivitiesNestedInput = {
    create?: XOR<FacultyCreateWithoutOutreachActivitiesInput, FacultyUncheckedCreateWithoutOutreachActivitiesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutOutreachActivitiesInput
    upsert?: FacultyUpsertWithoutOutreachActivitiesInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutOutreachActivitiesInput, FacultyUpdateWithoutOutreachActivitiesInput>, FacultyUncheckedUpdateWithoutOutreachActivitiesInput>
  }

  export type EventsOrganisedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventsOrganisedCreateWithoutEventInput, EventsOrganisedUncheckedCreateWithoutEventInput> | EventsOrganisedCreateWithoutEventInput[] | EventsOrganisedUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventsOrganisedCreateOrConnectWithoutEventInput | EventsOrganisedCreateOrConnectWithoutEventInput[]
    createMany?: EventsOrganisedCreateManyEventInputEnvelope
    connect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
  }

  export type EventsOrganisedUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventsOrganisedCreateWithoutEventInput, EventsOrganisedUncheckedCreateWithoutEventInput> | EventsOrganisedCreateWithoutEventInput[] | EventsOrganisedUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventsOrganisedCreateOrConnectWithoutEventInput | EventsOrganisedCreateOrConnectWithoutEventInput[]
    createMany?: EventsOrganisedCreateManyEventInputEnvelope
    connect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
  }

  export type Enumevent_typeFieldUpdateOperationsInput = {
    set?: $Enums.event_type
  }

  export type EventsOrganisedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventsOrganisedCreateWithoutEventInput, EventsOrganisedUncheckedCreateWithoutEventInput> | EventsOrganisedCreateWithoutEventInput[] | EventsOrganisedUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventsOrganisedCreateOrConnectWithoutEventInput | EventsOrganisedCreateOrConnectWithoutEventInput[]
    upsert?: EventsOrganisedUpsertWithWhereUniqueWithoutEventInput | EventsOrganisedUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventsOrganisedCreateManyEventInputEnvelope
    set?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    disconnect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    delete?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    connect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    update?: EventsOrganisedUpdateWithWhereUniqueWithoutEventInput | EventsOrganisedUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventsOrganisedUpdateManyWithWhereWithoutEventInput | EventsOrganisedUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventsOrganisedScalarWhereInput | EventsOrganisedScalarWhereInput[]
  }

  export type EventsOrganisedUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventsOrganisedCreateWithoutEventInput, EventsOrganisedUncheckedCreateWithoutEventInput> | EventsOrganisedCreateWithoutEventInput[] | EventsOrganisedUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventsOrganisedCreateOrConnectWithoutEventInput | EventsOrganisedCreateOrConnectWithoutEventInput[]
    upsert?: EventsOrganisedUpsertWithWhereUniqueWithoutEventInput | EventsOrganisedUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventsOrganisedCreateManyEventInputEnvelope
    set?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    disconnect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    delete?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    connect?: EventsOrganisedWhereUniqueInput | EventsOrganisedWhereUniqueInput[]
    update?: EventsOrganisedUpdateWithWhereUniqueWithoutEventInput | EventsOrganisedUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventsOrganisedUpdateManyWithWhereWithoutEventInput | EventsOrganisedUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventsOrganisedScalarWhereInput | EventsOrganisedScalarWhereInput[]
  }

  export type FacultyCreateNestedOneWithoutEventsOrganisedInput = {
    create?: XOR<FacultyCreateWithoutEventsOrganisedInput, FacultyUncheckedCreateWithoutEventsOrganisedInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutEventsOrganisedInput
    connect?: FacultyWhereUniqueInput
  }

  export type EventTypeCreateNestedOneWithoutEventsOrganisedInput = {
    create?: XOR<EventTypeCreateWithoutEventsOrganisedInput, EventTypeUncheckedCreateWithoutEventsOrganisedInput>
    connectOrCreate?: EventTypeCreateOrConnectWithoutEventsOrganisedInput
    connect?: EventTypeWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumrole_typeFieldUpdateOperationsInput = {
    set?: $Enums.role_type | null
  }

  export type FacultyUpdateOneRequiredWithoutEventsOrganisedNestedInput = {
    create?: XOR<FacultyCreateWithoutEventsOrganisedInput, FacultyUncheckedCreateWithoutEventsOrganisedInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutEventsOrganisedInput
    upsert?: FacultyUpsertWithoutEventsOrganisedInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutEventsOrganisedInput, FacultyUpdateWithoutEventsOrganisedInput>, FacultyUncheckedUpdateWithoutEventsOrganisedInput>
  }

  export type EventTypeUpdateOneRequiredWithoutEventsOrganisedNestedInput = {
    create?: XOR<EventTypeCreateWithoutEventsOrganisedInput, EventTypeUncheckedCreateWithoutEventsOrganisedInput>
    connectOrCreate?: EventTypeCreateOrConnectWithoutEventsOrganisedInput
    upsert?: EventTypeUpsertWithoutEventsOrganisedInput
    connect?: EventTypeWhereUniqueInput
    update?: XOR<XOR<EventTypeUpdateToOneWithWhereWithoutEventsOrganisedInput, EventTypeUpdateWithoutEventsOrganisedInput>, EventTypeUncheckedUpdateWithoutEventsOrganisedInput>
  }

  export type FacultyCreateNestedOneWithoutAwardsInput = {
    create?: XOR<FacultyCreateWithoutAwardsInput, FacultyUncheckedCreateWithoutAwardsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAwardsInput
    connect?: FacultyWhereUniqueInput
  }

  export type FacultyUpdateOneRequiredWithoutAwardsNestedInput = {
    create?: XOR<FacultyCreateWithoutAwardsInput, FacultyUncheckedCreateWithoutAwardsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAwardsInput
    upsert?: FacultyUpsertWithoutAwardsInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutAwardsInput, FacultyUpdateWithoutAwardsInput>, FacultyUncheckedUpdateWithoutAwardsInput>
  }

  export type FacultyCreateNestedOneWithoutTeachingExperiencesInput = {
    create?: XOR<FacultyCreateWithoutTeachingExperiencesInput, FacultyUncheckedCreateWithoutTeachingExperiencesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutTeachingExperiencesInput
    connect?: FacultyWhereUniqueInput
  }

  export type FacultyUpdateOneRequiredWithoutTeachingExperiencesNestedInput = {
    create?: XOR<FacultyCreateWithoutTeachingExperiencesInput, FacultyUncheckedCreateWithoutTeachingExperiencesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutTeachingExperiencesInput
    upsert?: FacultyUpsertWithoutTeachingExperiencesInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutTeachingExperiencesInput, FacultyUpdateWithoutTeachingExperiencesInput>, FacultyUncheckedUpdateWithoutTeachingExperiencesInput>
  }

  export type FacultyCreateNestedOneWithoutCitationMetricsInput = {
    create?: XOR<FacultyCreateWithoutCitationMetricsInput, FacultyUncheckedCreateWithoutCitationMetricsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutCitationMetricsInput
    connect?: FacultyWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type FacultyUpdateOneRequiredWithoutCitationMetricsNestedInput = {
    create?: XOR<FacultyCreateWithoutCitationMetricsInput, FacultyUncheckedCreateWithoutCitationMetricsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutCitationMetricsInput
    upsert?: FacultyUpsertWithoutCitationMetricsInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutCitationMetricsInput, FacultyUpdateWithoutCitationMetricsInput>, FacultyUncheckedUpdateWithoutCitationMetricsInput>
  }

  export type PublicationsCreateNestedManyWithoutTypeInput = {
    create?: XOR<PublicationsCreateWithoutTypeInput, PublicationsUncheckedCreateWithoutTypeInput> | PublicationsCreateWithoutTypeInput[] | PublicationsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PublicationsCreateOrConnectWithoutTypeInput | PublicationsCreateOrConnectWithoutTypeInput[]
    createMany?: PublicationsCreateManyTypeInputEnvelope
    connect?: PublicationsWhereUniqueInput | PublicationsWhereUniqueInput[]
  }

  export type PatentsCreateNestedManyWithoutTypeInput = {
    create?: XOR<PatentsCreateWithoutTypeInput, PatentsUncheckedCreateWithoutTypeInput> | PatentsCreateWithoutTypeInput[] | PatentsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PatentsCreateOrConnectWithoutTypeInput | PatentsCreateOrConnectWithoutTypeInput[]
    createMany?: PatentsCreateManyTypeInputEnvelope
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
  }

  export type ResearchProjectsCreateNestedManyWithoutTypeInput = {
    create?: XOR<ResearchProjectsCreateWithoutTypeInput, ResearchProjectsUncheckedCreateWithoutTypeInput> | ResearchProjectsCreateWithoutTypeInput[] | ResearchProjectsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ResearchProjectsCreateOrConnectWithoutTypeInput | ResearchProjectsCreateOrConnectWithoutTypeInput[]
    createMany?: ResearchProjectsCreateManyTypeInputEnvelope
    connect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
  }

  export type PublicationsUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<PublicationsCreateWithoutTypeInput, PublicationsUncheckedCreateWithoutTypeInput> | PublicationsCreateWithoutTypeInput[] | PublicationsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PublicationsCreateOrConnectWithoutTypeInput | PublicationsCreateOrConnectWithoutTypeInput[]
    createMany?: PublicationsCreateManyTypeInputEnvelope
    connect?: PublicationsWhereUniqueInput | PublicationsWhereUniqueInput[]
  }

  export type PatentsUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<PatentsCreateWithoutTypeInput, PatentsUncheckedCreateWithoutTypeInput> | PatentsCreateWithoutTypeInput[] | PatentsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PatentsCreateOrConnectWithoutTypeInput | PatentsCreateOrConnectWithoutTypeInput[]
    createMany?: PatentsCreateManyTypeInputEnvelope
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
  }

  export type ResearchProjectsUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<ResearchProjectsCreateWithoutTypeInput, ResearchProjectsUncheckedCreateWithoutTypeInput> | ResearchProjectsCreateWithoutTypeInput[] | ResearchProjectsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ResearchProjectsCreateOrConnectWithoutTypeInput | ResearchProjectsCreateOrConnectWithoutTypeInput[]
    createMany?: ResearchProjectsCreateManyTypeInputEnvelope
    connect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
  }

  export type Enumpublication_typeFieldUpdateOperationsInput = {
    set?: $Enums.publication_type
  }

  export type PublicationsUpdateManyWithoutTypeNestedInput = {
    create?: XOR<PublicationsCreateWithoutTypeInput, PublicationsUncheckedCreateWithoutTypeInput> | PublicationsCreateWithoutTypeInput[] | PublicationsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PublicationsCreateOrConnectWithoutTypeInput | PublicationsCreateOrConnectWithoutTypeInput[]
    upsert?: PublicationsUpsertWithWhereUniqueWithoutTypeInput | PublicationsUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: PublicationsCreateManyTypeInputEnvelope
    set?: PublicationsWhereUniqueInput | PublicationsWhereUniqueInput[]
    disconnect?: PublicationsWhereUniqueInput | PublicationsWhereUniqueInput[]
    delete?: PublicationsWhereUniqueInput | PublicationsWhereUniqueInput[]
    connect?: PublicationsWhereUniqueInput | PublicationsWhereUniqueInput[]
    update?: PublicationsUpdateWithWhereUniqueWithoutTypeInput | PublicationsUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: PublicationsUpdateManyWithWhereWithoutTypeInput | PublicationsUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: PublicationsScalarWhereInput | PublicationsScalarWhereInput[]
  }

  export type PatentsUpdateManyWithoutTypeNestedInput = {
    create?: XOR<PatentsCreateWithoutTypeInput, PatentsUncheckedCreateWithoutTypeInput> | PatentsCreateWithoutTypeInput[] | PatentsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PatentsCreateOrConnectWithoutTypeInput | PatentsCreateOrConnectWithoutTypeInput[]
    upsert?: PatentsUpsertWithWhereUniqueWithoutTypeInput | PatentsUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: PatentsCreateManyTypeInputEnvelope
    set?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    disconnect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    delete?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    update?: PatentsUpdateWithWhereUniqueWithoutTypeInput | PatentsUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: PatentsUpdateManyWithWhereWithoutTypeInput | PatentsUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: PatentsScalarWhereInput | PatentsScalarWhereInput[]
  }

  export type ResearchProjectsUpdateManyWithoutTypeNestedInput = {
    create?: XOR<ResearchProjectsCreateWithoutTypeInput, ResearchProjectsUncheckedCreateWithoutTypeInput> | ResearchProjectsCreateWithoutTypeInput[] | ResearchProjectsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ResearchProjectsCreateOrConnectWithoutTypeInput | ResearchProjectsCreateOrConnectWithoutTypeInput[]
    upsert?: ResearchProjectsUpsertWithWhereUniqueWithoutTypeInput | ResearchProjectsUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: ResearchProjectsCreateManyTypeInputEnvelope
    set?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    disconnect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    delete?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    connect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    update?: ResearchProjectsUpdateWithWhereUniqueWithoutTypeInput | ResearchProjectsUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: ResearchProjectsUpdateManyWithWhereWithoutTypeInput | ResearchProjectsUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: ResearchProjectsScalarWhereInput | ResearchProjectsScalarWhereInput[]
  }

  export type PublicationsUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<PublicationsCreateWithoutTypeInput, PublicationsUncheckedCreateWithoutTypeInput> | PublicationsCreateWithoutTypeInput[] | PublicationsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PublicationsCreateOrConnectWithoutTypeInput | PublicationsCreateOrConnectWithoutTypeInput[]
    upsert?: PublicationsUpsertWithWhereUniqueWithoutTypeInput | PublicationsUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: PublicationsCreateManyTypeInputEnvelope
    set?: PublicationsWhereUniqueInput | PublicationsWhereUniqueInput[]
    disconnect?: PublicationsWhereUniqueInput | PublicationsWhereUniqueInput[]
    delete?: PublicationsWhereUniqueInput | PublicationsWhereUniqueInput[]
    connect?: PublicationsWhereUniqueInput | PublicationsWhereUniqueInput[]
    update?: PublicationsUpdateWithWhereUniqueWithoutTypeInput | PublicationsUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: PublicationsUpdateManyWithWhereWithoutTypeInput | PublicationsUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: PublicationsScalarWhereInput | PublicationsScalarWhereInput[]
  }

  export type PatentsUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<PatentsCreateWithoutTypeInput, PatentsUncheckedCreateWithoutTypeInput> | PatentsCreateWithoutTypeInput[] | PatentsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PatentsCreateOrConnectWithoutTypeInput | PatentsCreateOrConnectWithoutTypeInput[]
    upsert?: PatentsUpsertWithWhereUniqueWithoutTypeInput | PatentsUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: PatentsCreateManyTypeInputEnvelope
    set?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    disconnect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    delete?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[]
    update?: PatentsUpdateWithWhereUniqueWithoutTypeInput | PatentsUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: PatentsUpdateManyWithWhereWithoutTypeInput | PatentsUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: PatentsScalarWhereInput | PatentsScalarWhereInput[]
  }

  export type ResearchProjectsUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<ResearchProjectsCreateWithoutTypeInput, ResearchProjectsUncheckedCreateWithoutTypeInput> | ResearchProjectsCreateWithoutTypeInput[] | ResearchProjectsUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ResearchProjectsCreateOrConnectWithoutTypeInput | ResearchProjectsCreateOrConnectWithoutTypeInput[]
    upsert?: ResearchProjectsUpsertWithWhereUniqueWithoutTypeInput | ResearchProjectsUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: ResearchProjectsCreateManyTypeInputEnvelope
    set?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    disconnect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    delete?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    connect?: ResearchProjectsWhereUniqueInput | ResearchProjectsWhereUniqueInput[]
    update?: ResearchProjectsUpdateWithWhereUniqueWithoutTypeInput | ResearchProjectsUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: ResearchProjectsUpdateManyWithWhereWithoutTypeInput | ResearchProjectsUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: ResearchProjectsScalarWhereInput | ResearchProjectsScalarWhereInput[]
  }

  export type TYPESCreateNestedOneWithoutPublicationsInput = {
    create?: XOR<TYPESCreateWithoutPublicationsInput, TYPESUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: TYPESCreateOrConnectWithoutPublicationsInput
    connect?: TYPESWhereUniqueInput
  }

  export type JournalPublicationDetailsCreateNestedOneWithoutPublicationInput = {
    create?: XOR<JournalPublicationDetailsCreateWithoutPublicationInput, JournalPublicationDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: JournalPublicationDetailsCreateOrConnectWithoutPublicationInput
    connect?: JournalPublicationDetailsWhereUniqueInput
  }

  export type BookPublicationDetailsCreateNestedOneWithoutPublicationInput = {
    create?: XOR<BookPublicationDetailsCreateWithoutPublicationInput, BookPublicationDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: BookPublicationDetailsCreateOrConnectWithoutPublicationInput
    connect?: BookPublicationDetailsWhereUniqueInput
  }

  export type ConferencePaperDetailsCreateNestedOneWithoutPublicationInput = {
    create?: XOR<ConferencePaperDetailsCreateWithoutPublicationInput, ConferencePaperDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: ConferencePaperDetailsCreateOrConnectWithoutPublicationInput
    connect?: ConferencePaperDetailsWhereUniqueInput
  }

  export type FacultyPublicationLinkCreateNestedManyWithoutPublicationInput = {
    create?: XOR<FacultyPublicationLinkCreateWithoutPublicationInput, FacultyPublicationLinkUncheckedCreateWithoutPublicationInput> | FacultyPublicationLinkCreateWithoutPublicationInput[] | FacultyPublicationLinkUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: FacultyPublicationLinkCreateOrConnectWithoutPublicationInput | FacultyPublicationLinkCreateOrConnectWithoutPublicationInput[]
    createMany?: FacultyPublicationLinkCreateManyPublicationInputEnvelope
    connect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
  }

  export type JournalPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput = {
    create?: XOR<JournalPublicationDetailsCreateWithoutPublicationInput, JournalPublicationDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: JournalPublicationDetailsCreateOrConnectWithoutPublicationInput
    connect?: JournalPublicationDetailsWhereUniqueInput
  }

  export type BookPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput = {
    create?: XOR<BookPublicationDetailsCreateWithoutPublicationInput, BookPublicationDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: BookPublicationDetailsCreateOrConnectWithoutPublicationInput
    connect?: BookPublicationDetailsWhereUniqueInput
  }

  export type ConferencePaperDetailsUncheckedCreateNestedOneWithoutPublicationInput = {
    create?: XOR<ConferencePaperDetailsCreateWithoutPublicationInput, ConferencePaperDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: ConferencePaperDetailsCreateOrConnectWithoutPublicationInput
    connect?: ConferencePaperDetailsWhereUniqueInput
  }

  export type FacultyPublicationLinkUncheckedCreateNestedManyWithoutPublicationInput = {
    create?: XOR<FacultyPublicationLinkCreateWithoutPublicationInput, FacultyPublicationLinkUncheckedCreateWithoutPublicationInput> | FacultyPublicationLinkCreateWithoutPublicationInput[] | FacultyPublicationLinkUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: FacultyPublicationLinkCreateOrConnectWithoutPublicationInput | FacultyPublicationLinkCreateOrConnectWithoutPublicationInput[]
    createMany?: FacultyPublicationLinkCreateManyPublicationInputEnvelope
    connect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
  }

  export type TYPESUpdateOneRequiredWithoutPublicationsNestedInput = {
    create?: XOR<TYPESCreateWithoutPublicationsInput, TYPESUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: TYPESCreateOrConnectWithoutPublicationsInput
    upsert?: TYPESUpsertWithoutPublicationsInput
    connect?: TYPESWhereUniqueInput
    update?: XOR<XOR<TYPESUpdateToOneWithWhereWithoutPublicationsInput, TYPESUpdateWithoutPublicationsInput>, TYPESUncheckedUpdateWithoutPublicationsInput>
  }

  export type JournalPublicationDetailsUpdateOneWithoutPublicationNestedInput = {
    create?: XOR<JournalPublicationDetailsCreateWithoutPublicationInput, JournalPublicationDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: JournalPublicationDetailsCreateOrConnectWithoutPublicationInput
    upsert?: JournalPublicationDetailsUpsertWithoutPublicationInput
    disconnect?: JournalPublicationDetailsWhereInput | boolean
    delete?: JournalPublicationDetailsWhereInput | boolean
    connect?: JournalPublicationDetailsWhereUniqueInput
    update?: XOR<XOR<JournalPublicationDetailsUpdateToOneWithWhereWithoutPublicationInput, JournalPublicationDetailsUpdateWithoutPublicationInput>, JournalPublicationDetailsUncheckedUpdateWithoutPublicationInput>
  }

  export type BookPublicationDetailsUpdateOneWithoutPublicationNestedInput = {
    create?: XOR<BookPublicationDetailsCreateWithoutPublicationInput, BookPublicationDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: BookPublicationDetailsCreateOrConnectWithoutPublicationInput
    upsert?: BookPublicationDetailsUpsertWithoutPublicationInput
    disconnect?: BookPublicationDetailsWhereInput | boolean
    delete?: BookPublicationDetailsWhereInput | boolean
    connect?: BookPublicationDetailsWhereUniqueInput
    update?: XOR<XOR<BookPublicationDetailsUpdateToOneWithWhereWithoutPublicationInput, BookPublicationDetailsUpdateWithoutPublicationInput>, BookPublicationDetailsUncheckedUpdateWithoutPublicationInput>
  }

  export type ConferencePaperDetailsUpdateOneWithoutPublicationNestedInput = {
    create?: XOR<ConferencePaperDetailsCreateWithoutPublicationInput, ConferencePaperDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: ConferencePaperDetailsCreateOrConnectWithoutPublicationInput
    upsert?: ConferencePaperDetailsUpsertWithoutPublicationInput
    disconnect?: ConferencePaperDetailsWhereInput | boolean
    delete?: ConferencePaperDetailsWhereInput | boolean
    connect?: ConferencePaperDetailsWhereUniqueInput
    update?: XOR<XOR<ConferencePaperDetailsUpdateToOneWithWhereWithoutPublicationInput, ConferencePaperDetailsUpdateWithoutPublicationInput>, ConferencePaperDetailsUncheckedUpdateWithoutPublicationInput>
  }

  export type FacultyPublicationLinkUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<FacultyPublicationLinkCreateWithoutPublicationInput, FacultyPublicationLinkUncheckedCreateWithoutPublicationInput> | FacultyPublicationLinkCreateWithoutPublicationInput[] | FacultyPublicationLinkUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: FacultyPublicationLinkCreateOrConnectWithoutPublicationInput | FacultyPublicationLinkCreateOrConnectWithoutPublicationInput[]
    upsert?: FacultyPublicationLinkUpsertWithWhereUniqueWithoutPublicationInput | FacultyPublicationLinkUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: FacultyPublicationLinkCreateManyPublicationInputEnvelope
    set?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    disconnect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    delete?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    connect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    update?: FacultyPublicationLinkUpdateWithWhereUniqueWithoutPublicationInput | FacultyPublicationLinkUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: FacultyPublicationLinkUpdateManyWithWhereWithoutPublicationInput | FacultyPublicationLinkUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: FacultyPublicationLinkScalarWhereInput | FacultyPublicationLinkScalarWhereInput[]
  }

  export type JournalPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput = {
    create?: XOR<JournalPublicationDetailsCreateWithoutPublicationInput, JournalPublicationDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: JournalPublicationDetailsCreateOrConnectWithoutPublicationInput
    upsert?: JournalPublicationDetailsUpsertWithoutPublicationInput
    disconnect?: JournalPublicationDetailsWhereInput | boolean
    delete?: JournalPublicationDetailsWhereInput | boolean
    connect?: JournalPublicationDetailsWhereUniqueInput
    update?: XOR<XOR<JournalPublicationDetailsUpdateToOneWithWhereWithoutPublicationInput, JournalPublicationDetailsUpdateWithoutPublicationInput>, JournalPublicationDetailsUncheckedUpdateWithoutPublicationInput>
  }

  export type BookPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput = {
    create?: XOR<BookPublicationDetailsCreateWithoutPublicationInput, BookPublicationDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: BookPublicationDetailsCreateOrConnectWithoutPublicationInput
    upsert?: BookPublicationDetailsUpsertWithoutPublicationInput
    disconnect?: BookPublicationDetailsWhereInput | boolean
    delete?: BookPublicationDetailsWhereInput | boolean
    connect?: BookPublicationDetailsWhereUniqueInput
    update?: XOR<XOR<BookPublicationDetailsUpdateToOneWithWhereWithoutPublicationInput, BookPublicationDetailsUpdateWithoutPublicationInput>, BookPublicationDetailsUncheckedUpdateWithoutPublicationInput>
  }

  export type ConferencePaperDetailsUncheckedUpdateOneWithoutPublicationNestedInput = {
    create?: XOR<ConferencePaperDetailsCreateWithoutPublicationInput, ConferencePaperDetailsUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: ConferencePaperDetailsCreateOrConnectWithoutPublicationInput
    upsert?: ConferencePaperDetailsUpsertWithoutPublicationInput
    disconnect?: ConferencePaperDetailsWhereInput | boolean
    delete?: ConferencePaperDetailsWhereInput | boolean
    connect?: ConferencePaperDetailsWhereUniqueInput
    update?: XOR<XOR<ConferencePaperDetailsUpdateToOneWithWhereWithoutPublicationInput, ConferencePaperDetailsUpdateWithoutPublicationInput>, ConferencePaperDetailsUncheckedUpdateWithoutPublicationInput>
  }

  export type FacultyPublicationLinkUncheckedUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<FacultyPublicationLinkCreateWithoutPublicationInput, FacultyPublicationLinkUncheckedCreateWithoutPublicationInput> | FacultyPublicationLinkCreateWithoutPublicationInput[] | FacultyPublicationLinkUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: FacultyPublicationLinkCreateOrConnectWithoutPublicationInput | FacultyPublicationLinkCreateOrConnectWithoutPublicationInput[]
    upsert?: FacultyPublicationLinkUpsertWithWhereUniqueWithoutPublicationInput | FacultyPublicationLinkUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: FacultyPublicationLinkCreateManyPublicationInputEnvelope
    set?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    disconnect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    delete?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    connect?: FacultyPublicationLinkWhereUniqueInput | FacultyPublicationLinkWhereUniqueInput[]
    update?: FacultyPublicationLinkUpdateWithWhereUniqueWithoutPublicationInput | FacultyPublicationLinkUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: FacultyPublicationLinkUpdateManyWithWhereWithoutPublicationInput | FacultyPublicationLinkUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: FacultyPublicationLinkScalarWhereInput | FacultyPublicationLinkScalarWhereInput[]
  }

  export type PublicationsCreateNestedOneWithoutJournalPublicationDetailsInput = {
    create?: XOR<PublicationsCreateWithoutJournalPublicationDetailsInput, PublicationsUncheckedCreateWithoutJournalPublicationDetailsInput>
    connectOrCreate?: PublicationsCreateOrConnectWithoutJournalPublicationDetailsInput
    connect?: PublicationsWhereUniqueInput
  }

  export type PublicationsUpdateOneRequiredWithoutJournalPublicationDetailsNestedInput = {
    create?: XOR<PublicationsCreateWithoutJournalPublicationDetailsInput, PublicationsUncheckedCreateWithoutJournalPublicationDetailsInput>
    connectOrCreate?: PublicationsCreateOrConnectWithoutJournalPublicationDetailsInput
    upsert?: PublicationsUpsertWithoutJournalPublicationDetailsInput
    connect?: PublicationsWhereUniqueInput
    update?: XOR<XOR<PublicationsUpdateToOneWithWhereWithoutJournalPublicationDetailsInput, PublicationsUpdateWithoutJournalPublicationDetailsInput>, PublicationsUncheckedUpdateWithoutJournalPublicationDetailsInput>
  }

  export type PublicationsCreateNestedOneWithoutBookPublicationDetailsInput = {
    create?: XOR<PublicationsCreateWithoutBookPublicationDetailsInput, PublicationsUncheckedCreateWithoutBookPublicationDetailsInput>
    connectOrCreate?: PublicationsCreateOrConnectWithoutBookPublicationDetailsInput
    connect?: PublicationsWhereUniqueInput
  }

  export type PublicationsUpdateOneRequiredWithoutBookPublicationDetailsNestedInput = {
    create?: XOR<PublicationsCreateWithoutBookPublicationDetailsInput, PublicationsUncheckedCreateWithoutBookPublicationDetailsInput>
    connectOrCreate?: PublicationsCreateOrConnectWithoutBookPublicationDetailsInput
    upsert?: PublicationsUpsertWithoutBookPublicationDetailsInput
    connect?: PublicationsWhereUniqueInput
    update?: XOR<XOR<PublicationsUpdateToOneWithWhereWithoutBookPublicationDetailsInput, PublicationsUpdateWithoutBookPublicationDetailsInput>, PublicationsUncheckedUpdateWithoutBookPublicationDetailsInput>
  }

  export type PublicationsCreateNestedOneWithoutConferencePaperDetailsInput = {
    create?: XOR<PublicationsCreateWithoutConferencePaperDetailsInput, PublicationsUncheckedCreateWithoutConferencePaperDetailsInput>
    connectOrCreate?: PublicationsCreateOrConnectWithoutConferencePaperDetailsInput
    connect?: PublicationsWhereUniqueInput
  }

  export type PublicationsUpdateOneRequiredWithoutConferencePaperDetailsNestedInput = {
    create?: XOR<PublicationsCreateWithoutConferencePaperDetailsInput, PublicationsUncheckedCreateWithoutConferencePaperDetailsInput>
    connectOrCreate?: PublicationsCreateOrConnectWithoutConferencePaperDetailsInput
    upsert?: PublicationsUpsertWithoutConferencePaperDetailsInput
    connect?: PublicationsWhereUniqueInput
    update?: XOR<XOR<PublicationsUpdateToOneWithWhereWithoutConferencePaperDetailsInput, PublicationsUpdateWithoutConferencePaperDetailsInput>, PublicationsUncheckedUpdateWithoutConferencePaperDetailsInput>
  }

  export type FacultyCreateNestedOneWithoutPublicationsInput = {
    create?: XOR<FacultyCreateWithoutPublicationsInput, FacultyUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutPublicationsInput
    connect?: FacultyWhereUniqueInput
  }

  export type PublicationsCreateNestedOneWithoutFacultyPublicationLinkInput = {
    create?: XOR<PublicationsCreateWithoutFacultyPublicationLinkInput, PublicationsUncheckedCreateWithoutFacultyPublicationLinkInput>
    connectOrCreate?: PublicationsCreateOrConnectWithoutFacultyPublicationLinkInput
    connect?: PublicationsWhereUniqueInput
  }

  export type FacultyUpdateOneRequiredWithoutPublicationsNestedInput = {
    create?: XOR<FacultyCreateWithoutPublicationsInput, FacultyUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutPublicationsInput
    upsert?: FacultyUpsertWithoutPublicationsInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutPublicationsInput, FacultyUpdateWithoutPublicationsInput>, FacultyUncheckedUpdateWithoutPublicationsInput>
  }

  export type PublicationsUpdateOneRequiredWithoutFacultyPublicationLinkNestedInput = {
    create?: XOR<PublicationsCreateWithoutFacultyPublicationLinkInput, PublicationsUncheckedCreateWithoutFacultyPublicationLinkInput>
    connectOrCreate?: PublicationsCreateOrConnectWithoutFacultyPublicationLinkInput
    upsert?: PublicationsUpsertWithoutFacultyPublicationLinkInput
    connect?: PublicationsWhereUniqueInput
    update?: XOR<XOR<PublicationsUpdateToOneWithWhereWithoutFacultyPublicationLinkInput, PublicationsUpdateWithoutFacultyPublicationLinkInput>, PublicationsUncheckedUpdateWithoutFacultyPublicationLinkInput>
  }

  export type FacultyCreateNestedOneWithoutPatentsInput = {
    create?: XOR<FacultyCreateWithoutPatentsInput, FacultyUncheckedCreateWithoutPatentsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutPatentsInput
    connect?: FacultyWhereUniqueInput
  }

  export type TYPESCreateNestedOneWithoutPatentsInput = {
    create?: XOR<TYPESCreateWithoutPatentsInput, TYPESUncheckedCreateWithoutPatentsInput>
    connectOrCreate?: TYPESCreateOrConnectWithoutPatentsInput
    connect?: TYPESWhereUniqueInput
  }

  export type FacultyUpdateOneRequiredWithoutPatentsNestedInput = {
    create?: XOR<FacultyCreateWithoutPatentsInput, FacultyUncheckedCreateWithoutPatentsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutPatentsInput
    upsert?: FacultyUpsertWithoutPatentsInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutPatentsInput, FacultyUpdateWithoutPatentsInput>, FacultyUncheckedUpdateWithoutPatentsInput>
  }

  export type TYPESUpdateOneRequiredWithoutPatentsNestedInput = {
    create?: XOR<TYPESCreateWithoutPatentsInput, TYPESUncheckedCreateWithoutPatentsInput>
    connectOrCreate?: TYPESCreateOrConnectWithoutPatentsInput
    upsert?: TYPESUpsertWithoutPatentsInput
    connect?: TYPESWhereUniqueInput
    update?: XOR<XOR<TYPESUpdateToOneWithWhereWithoutPatentsInput, TYPESUpdateWithoutPatentsInput>, TYPESUncheckedUpdateWithoutPatentsInput>
  }

  export type FacultyCreateNestedOneWithoutResearchProjectsInput = {
    create?: XOR<FacultyCreateWithoutResearchProjectsInput, FacultyUncheckedCreateWithoutResearchProjectsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutResearchProjectsInput
    connect?: FacultyWhereUniqueInput
  }

  export type TYPESCreateNestedOneWithoutResearchProjectsInput = {
    create?: XOR<TYPESCreateWithoutResearchProjectsInput, TYPESUncheckedCreateWithoutResearchProjectsInput>
    connectOrCreate?: TYPESCreateOrConnectWithoutResearchProjectsInput
    connect?: TYPESWhereUniqueInput
  }

  export type FacultyUpdateOneRequiredWithoutResearchProjectsNestedInput = {
    create?: XOR<FacultyCreateWithoutResearchProjectsInput, FacultyUncheckedCreateWithoutResearchProjectsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutResearchProjectsInput
    upsert?: FacultyUpsertWithoutResearchProjectsInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutResearchProjectsInput, FacultyUpdateWithoutResearchProjectsInput>, FacultyUncheckedUpdateWithoutResearchProjectsInput>
  }

  export type TYPESUpdateOneRequiredWithoutResearchProjectsNestedInput = {
    create?: XOR<TYPESCreateWithoutResearchProjectsInput, TYPESUncheckedCreateWithoutResearchProjectsInput>
    connectOrCreate?: TYPESCreateOrConnectWithoutResearchProjectsInput
    upsert?: TYPESUpsertWithoutResearchProjectsInput
    connect?: TYPESWhereUniqueInput
    update?: XOR<XOR<TYPESUpdateToOneWithWhereWithoutResearchProjectsInput, TYPESUpdateWithoutResearchProjectsInput>, TYPESUncheckedUpdateWithoutResearchProjectsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumevent_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.event_type | Enumevent_typeFieldRefInput<$PrismaModel>
    in?: $Enums.event_type[] | ListEnumevent_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.event_type[] | ListEnumevent_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumevent_typeFilter<$PrismaModel> | $Enums.event_type
  }

  export type NestedEnumevent_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.event_type | Enumevent_typeFieldRefInput<$PrismaModel>
    in?: $Enums.event_type[] | ListEnumevent_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.event_type[] | ListEnumevent_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumevent_typeWithAggregatesFilter<$PrismaModel> | $Enums.event_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumevent_typeFilter<$PrismaModel>
    _max?: NestedEnumevent_typeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumrole_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.role_type | Enumrole_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.role_type[] | ListEnumrole_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.role_type[] | ListEnumrole_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrole_typeNullableFilter<$PrismaModel> | $Enums.role_type | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumrole_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role_type | Enumrole_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.role_type[] | ListEnumrole_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.role_type[] | ListEnumrole_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrole_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.role_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumrole_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumrole_typeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumpublication_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.publication_type | Enumpublication_typeFieldRefInput<$PrismaModel>
    in?: $Enums.publication_type[] | ListEnumpublication_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.publication_type[] | ListEnumpublication_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumpublication_typeFilter<$PrismaModel> | $Enums.publication_type
  }

  export type NestedEnumpublication_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.publication_type | Enumpublication_typeFieldRefInput<$PrismaModel>
    in?: $Enums.publication_type[] | ListEnumpublication_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.publication_type[] | ListEnumpublication_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumpublication_typeWithAggregatesFilter<$PrismaModel> | $Enums.publication_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpublication_typeFilter<$PrismaModel>
    _max?: NestedEnumpublication_typeFilter<$PrismaModel>
  }

  export type FacultyCreateWithoutDepartmentInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutDepartmentInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutDepartmentInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutDepartmentInput, FacultyUncheckedCreateWithoutDepartmentInput>
  }

  export type FacultyCreateManyDepartmentInputEnvelope = {
    data: FacultyCreateManyDepartmentInput | FacultyCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type FacultyUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: FacultyWhereUniqueInput
    update: XOR<FacultyUpdateWithoutDepartmentInput, FacultyUncheckedUpdateWithoutDepartmentInput>
    create: XOR<FacultyCreateWithoutDepartmentInput, FacultyUncheckedCreateWithoutDepartmentInput>
  }

  export type FacultyUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: FacultyWhereUniqueInput
    data: XOR<FacultyUpdateWithoutDepartmentInput, FacultyUncheckedUpdateWithoutDepartmentInput>
  }

  export type FacultyUpdateManyWithWhereWithoutDepartmentInput = {
    where: FacultyScalarWhereInput
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type FacultyScalarWhereInput = {
    AND?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
    OR?: FacultyScalarWhereInput[]
    NOT?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
    FacultyID?: IntFilter<"Faculty"> | number
    FirstName?: StringFilter<"Faculty"> | string
    LastName?: StringFilter<"Faculty"> | string
    Gender?: StringFilter<"Faculty"> | string
    DOB?: DateTimeFilter<"Faculty"> | Date | string
    Role?: StringFilter<"Faculty"> | string
    Phone_no?: StringFilter<"Faculty"> | string
    Email?: StringFilter<"Faculty"> | string
    DepartmentID?: IntFilter<"Faculty"> | number
  }

  export type DepartmentCreateWithoutFacultyInput = {
    DepartmentName: string
  }

  export type DepartmentUncheckedCreateWithoutFacultyInput = {
    DepartmentID?: number
    DepartmentName: string
  }

  export type DepartmentCreateOrConnectWithoutFacultyInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
  }

  export type SubjectTaughtCreateWithoutFacultyInput = {
    Level: string
    SubjectName: string
    CourseCode?: string | null
    ProgramName?: string | null
    Note?: string | null
  }

  export type SubjectTaughtUncheckedCreateWithoutFacultyInput = {
    Level: string
    SubjectName: string
    CourseCode?: string | null
    ProgramName?: string | null
    Note?: string | null
  }

  export type SubjectTaughtCreateOrConnectWithoutFacultyInput = {
    where: SubjectTaughtWhereUniqueInput
    create: XOR<SubjectTaughtCreateWithoutFacultyInput, SubjectTaughtUncheckedCreateWithoutFacultyInput>
  }

  export type SubjectTaughtCreateManyFacultyInputEnvelope = {
    data: SubjectTaughtCreateManyFacultyInput | SubjectTaughtCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type FacultyQualificationCreateWithoutFacultyInput = {
    Degree: string
    Institution: string
    YearOfCompletion: Date | string
  }

  export type FacultyQualificationUncheckedCreateWithoutFacultyInput = {
    QualificationID?: number
    Degree: string
    Institution: string
    YearOfCompletion: Date | string
  }

  export type FacultyQualificationCreateOrConnectWithoutFacultyInput = {
    where: FacultyQualificationWhereUniqueInput
    create: XOR<FacultyQualificationCreateWithoutFacultyInput, FacultyQualificationUncheckedCreateWithoutFacultyInput>
  }

  export type FacultyQualificationCreateManyFacultyInputEnvelope = {
    data: FacultyQualificationCreateManyFacultyInput | FacultyQualificationCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type OutReachActivitiesCreateWithoutFacultyInput = {
    ActivityType: string
    ActivityTitle: string
    InstitutionName?: string | null
    ActivityDate: Date | string
    Description?: string | null
  }

  export type OutReachActivitiesUncheckedCreateWithoutFacultyInput = {
    ActivityID?: number
    ActivityType: string
    ActivityTitle: string
    InstitutionName?: string | null
    ActivityDate: Date | string
    Description?: string | null
  }

  export type OutReachActivitiesCreateOrConnectWithoutFacultyInput = {
    where: OutReachActivitiesWhereUniqueInput
    create: XOR<OutReachActivitiesCreateWithoutFacultyInput, OutReachActivitiesUncheckedCreateWithoutFacultyInput>
  }

  export type OutReachActivitiesCreateManyFacultyInputEnvelope = {
    data: OutReachActivitiesCreateManyFacultyInput | OutReachActivitiesCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type EventsOrganisedCreateWithoutFacultyInput = {
    Title: string
    Organizer?: string | null
    Location?: string | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Description?: string | null
    Role?: $Enums.role_type | null
    FundingAgency?: string | null
    Event: EventTypeCreateNestedOneWithoutEventsOrganisedInput
  }

  export type EventsOrganisedUncheckedCreateWithoutFacultyInput = {
    Event_id: number
    Title: string
    Organizer?: string | null
    Location?: string | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Description?: string | null
    Role?: $Enums.role_type | null
    FundingAgency?: string | null
  }

  export type EventsOrganisedCreateOrConnectWithoutFacultyInput = {
    where: EventsOrganisedWhereUniqueInput
    create: XOR<EventsOrganisedCreateWithoutFacultyInput, EventsOrganisedUncheckedCreateWithoutFacultyInput>
  }

  export type EventsOrganisedCreateManyFacultyInputEnvelope = {
    data: EventsOrganisedCreateManyFacultyInput | EventsOrganisedCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type AwardsCreateWithoutFacultyInput = {
    AwardName: string
    AwardingBody?: string | null
    Location?: string | null
    YearAwarded: number
  }

  export type AwardsUncheckedCreateWithoutFacultyInput = {
    AwardID?: number
    AwardName: string
    AwardingBody?: string | null
    Location?: string | null
    YearAwarded: number
  }

  export type AwardsCreateOrConnectWithoutFacultyInput = {
    where: AwardsWhereUniqueInput
    create: XOR<AwardsCreateWithoutFacultyInput, AwardsUncheckedCreateWithoutFacultyInput>
  }

  export type AwardsCreateManyFacultyInputEnvelope = {
    data: AwardsCreateManyFacultyInput | AwardsCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type TeachingExperienceCreateWithoutFacultyInput = {
    OrganizationName: string
    Designation: string
    StartDate: Date | string
    EndDate?: string | null
    NatureOfWork?: string | null
  }

  export type TeachingExperienceUncheckedCreateWithoutFacultyInput = {
    ExperienceID?: number
    OrganizationName: string
    Designation: string
    StartDate: Date | string
    EndDate?: string | null
    NatureOfWork?: string | null
  }

  export type TeachingExperienceCreateOrConnectWithoutFacultyInput = {
    where: TeachingExperienceWhereUniqueInput
    create: XOR<TeachingExperienceCreateWithoutFacultyInput, TeachingExperienceUncheckedCreateWithoutFacultyInput>
  }

  export type TeachingExperienceCreateManyFacultyInputEnvelope = {
    data: TeachingExperienceCreateManyFacultyInput | TeachingExperienceCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type CitationMetricsCreateWithoutFacultyInput = {
    YearRecorded: number
    Source: string
    HIndex?: number | null
    I10Index?: number | null
    TotalCitations?: number | null
    ImpactFactor?: Decimal | DecimalJsLike | number | string | null
  }

  export type CitationMetricsUncheckedCreateWithoutFacultyInput = {
    MetricsID?: number
    YearRecorded: number
    Source: string
    HIndex?: number | null
    I10Index?: number | null
    TotalCitations?: number | null
    ImpactFactor?: Decimal | DecimalJsLike | number | string | null
  }

  export type CitationMetricsCreateOrConnectWithoutFacultyInput = {
    where: CitationMetricsWhereUniqueInput
    create: XOR<CitationMetricsCreateWithoutFacultyInput, CitationMetricsUncheckedCreateWithoutFacultyInput>
  }

  export type CitationMetricsCreateManyFacultyInputEnvelope = {
    data: CitationMetricsCreateManyFacultyInput | CitationMetricsCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type FacultyPublicationLinkCreateWithoutFacultyInput = {
    TypeOfIndexing?: string | null
    Publication: PublicationsCreateNestedOneWithoutFacultyPublicationLinkInput
  }

  export type FacultyPublicationLinkUncheckedCreateWithoutFacultyInput = {
    PublicationID: number
    TypeOfIndexing?: string | null
  }

  export type FacultyPublicationLinkCreateOrConnectWithoutFacultyInput = {
    where: FacultyPublicationLinkWhereUniqueInput
    create: XOR<FacultyPublicationLinkCreateWithoutFacultyInput, FacultyPublicationLinkUncheckedCreateWithoutFacultyInput>
  }

  export type FacultyPublicationLinkCreateManyFacultyInputEnvelope = {
    data: FacultyPublicationLinkCreateManyFacultyInput | FacultyPublicationLinkCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type PatentsCreateWithoutFacultyInput = {
    Title: string
    FilingDate: Date | string
    PublicationDate?: Date | string | null
    PatentNumber: string
    Authority?: string | null
    CollaborationInstitute?: string | null
    Type: TYPESCreateNestedOneWithoutPatentsInput
  }

  export type PatentsUncheckedCreateWithoutFacultyInput = {
    TypeID: string
    Title: string
    FilingDate: Date | string
    PublicationDate?: Date | string | null
    PatentNumber: string
    Authority?: string | null
    CollaborationInstitute?: string | null
  }

  export type PatentsCreateOrConnectWithoutFacultyInput = {
    where: PatentsWhereUniqueInput
    create: XOR<PatentsCreateWithoutFacultyInput, PatentsUncheckedCreateWithoutFacultyInput>
  }

  export type PatentsCreateManyFacultyInputEnvelope = {
    data: PatentsCreateManyFacultyInput | PatentsCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type ResearchProjectsCreateWithoutFacultyInput = {
    Title: string
    FundingAgency?: string | null
    StartDate: Date | string
    EndDate?: Date | string | null
    Budget?: Decimal | DecimalJsLike | number | string | null
    Type: TYPESCreateNestedOneWithoutResearchProjectsInput
  }

  export type ResearchProjectsUncheckedCreateWithoutFacultyInput = {
    TypeID: string
    Title: string
    FundingAgency?: string | null
    StartDate: Date | string
    EndDate?: Date | string | null
    Budget?: Decimal | DecimalJsLike | number | string | null
  }

  export type ResearchProjectsCreateOrConnectWithoutFacultyInput = {
    where: ResearchProjectsWhereUniqueInput
    create: XOR<ResearchProjectsCreateWithoutFacultyInput, ResearchProjectsUncheckedCreateWithoutFacultyInput>
  }

  export type ResearchProjectsCreateManyFacultyInputEnvelope = {
    data: ResearchProjectsCreateManyFacultyInput | ResearchProjectsCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutFacultyInput = {
    update: XOR<DepartmentUpdateWithoutFacultyInput, DepartmentUncheckedUpdateWithoutFacultyInput>
    create: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutFacultyInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutFacultyInput, DepartmentUncheckedUpdateWithoutFacultyInput>
  }

  export type DepartmentUpdateWithoutFacultyInput = {
    DepartmentName?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentUncheckedUpdateWithoutFacultyInput = {
    DepartmentID?: IntFieldUpdateOperationsInput | number
    DepartmentName?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectTaughtUpsertWithWhereUniqueWithoutFacultyInput = {
    where: SubjectTaughtWhereUniqueInput
    update: XOR<SubjectTaughtUpdateWithoutFacultyInput, SubjectTaughtUncheckedUpdateWithoutFacultyInput>
    create: XOR<SubjectTaughtCreateWithoutFacultyInput, SubjectTaughtUncheckedCreateWithoutFacultyInput>
  }

  export type SubjectTaughtUpdateWithWhereUniqueWithoutFacultyInput = {
    where: SubjectTaughtWhereUniqueInput
    data: XOR<SubjectTaughtUpdateWithoutFacultyInput, SubjectTaughtUncheckedUpdateWithoutFacultyInput>
  }

  export type SubjectTaughtUpdateManyWithWhereWithoutFacultyInput = {
    where: SubjectTaughtScalarWhereInput
    data: XOR<SubjectTaughtUpdateManyMutationInput, SubjectTaughtUncheckedUpdateManyWithoutFacultyInput>
  }

  export type SubjectTaughtScalarWhereInput = {
    AND?: SubjectTaughtScalarWhereInput | SubjectTaughtScalarWhereInput[]
    OR?: SubjectTaughtScalarWhereInput[]
    NOT?: SubjectTaughtScalarWhereInput | SubjectTaughtScalarWhereInput[]
    FacultyID?: IntFilter<"SubjectTaught"> | number
    Level?: StringFilter<"SubjectTaught"> | string
    SubjectName?: StringFilter<"SubjectTaught"> | string
    CourseCode?: StringNullableFilter<"SubjectTaught"> | string | null
    ProgramName?: StringNullableFilter<"SubjectTaught"> | string | null
    Note?: StringNullableFilter<"SubjectTaught"> | string | null
  }

  export type FacultyQualificationUpsertWithWhereUniqueWithoutFacultyInput = {
    where: FacultyQualificationWhereUniqueInput
    update: XOR<FacultyQualificationUpdateWithoutFacultyInput, FacultyQualificationUncheckedUpdateWithoutFacultyInput>
    create: XOR<FacultyQualificationCreateWithoutFacultyInput, FacultyQualificationUncheckedCreateWithoutFacultyInput>
  }

  export type FacultyQualificationUpdateWithWhereUniqueWithoutFacultyInput = {
    where: FacultyQualificationWhereUniqueInput
    data: XOR<FacultyQualificationUpdateWithoutFacultyInput, FacultyQualificationUncheckedUpdateWithoutFacultyInput>
  }

  export type FacultyQualificationUpdateManyWithWhereWithoutFacultyInput = {
    where: FacultyQualificationScalarWhereInput
    data: XOR<FacultyQualificationUpdateManyMutationInput, FacultyQualificationUncheckedUpdateManyWithoutFacultyInput>
  }

  export type FacultyQualificationScalarWhereInput = {
    AND?: FacultyQualificationScalarWhereInput | FacultyQualificationScalarWhereInput[]
    OR?: FacultyQualificationScalarWhereInput[]
    NOT?: FacultyQualificationScalarWhereInput | FacultyQualificationScalarWhereInput[]
    QualificationID?: IntFilter<"FacultyQualification"> | number
    FacultyID?: IntFilter<"FacultyQualification"> | number
    Degree?: StringFilter<"FacultyQualification"> | string
    Institution?: StringFilter<"FacultyQualification"> | string
    YearOfCompletion?: DateTimeFilter<"FacultyQualification"> | Date | string
  }

  export type OutReachActivitiesUpsertWithWhereUniqueWithoutFacultyInput = {
    where: OutReachActivitiesWhereUniqueInput
    update: XOR<OutReachActivitiesUpdateWithoutFacultyInput, OutReachActivitiesUncheckedUpdateWithoutFacultyInput>
    create: XOR<OutReachActivitiesCreateWithoutFacultyInput, OutReachActivitiesUncheckedCreateWithoutFacultyInput>
  }

  export type OutReachActivitiesUpdateWithWhereUniqueWithoutFacultyInput = {
    where: OutReachActivitiesWhereUniqueInput
    data: XOR<OutReachActivitiesUpdateWithoutFacultyInput, OutReachActivitiesUncheckedUpdateWithoutFacultyInput>
  }

  export type OutReachActivitiesUpdateManyWithWhereWithoutFacultyInput = {
    where: OutReachActivitiesScalarWhereInput
    data: XOR<OutReachActivitiesUpdateManyMutationInput, OutReachActivitiesUncheckedUpdateManyWithoutFacultyInput>
  }

  export type OutReachActivitiesScalarWhereInput = {
    AND?: OutReachActivitiesScalarWhereInput | OutReachActivitiesScalarWhereInput[]
    OR?: OutReachActivitiesScalarWhereInput[]
    NOT?: OutReachActivitiesScalarWhereInput | OutReachActivitiesScalarWhereInput[]
    ActivityID?: IntFilter<"OutReachActivities"> | number
    FacultyID?: IntFilter<"OutReachActivities"> | number
    ActivityType?: StringFilter<"OutReachActivities"> | string
    ActivityTitle?: StringFilter<"OutReachActivities"> | string
    InstitutionName?: StringNullableFilter<"OutReachActivities"> | string | null
    ActivityDate?: DateTimeFilter<"OutReachActivities"> | Date | string
    Description?: StringNullableFilter<"OutReachActivities"> | string | null
  }

  export type EventsOrganisedUpsertWithWhereUniqueWithoutFacultyInput = {
    where: EventsOrganisedWhereUniqueInput
    update: XOR<EventsOrganisedUpdateWithoutFacultyInput, EventsOrganisedUncheckedUpdateWithoutFacultyInput>
    create: XOR<EventsOrganisedCreateWithoutFacultyInput, EventsOrganisedUncheckedCreateWithoutFacultyInput>
  }

  export type EventsOrganisedUpdateWithWhereUniqueWithoutFacultyInput = {
    where: EventsOrganisedWhereUniqueInput
    data: XOR<EventsOrganisedUpdateWithoutFacultyInput, EventsOrganisedUncheckedUpdateWithoutFacultyInput>
  }

  export type EventsOrganisedUpdateManyWithWhereWithoutFacultyInput = {
    where: EventsOrganisedScalarWhereInput
    data: XOR<EventsOrganisedUpdateManyMutationInput, EventsOrganisedUncheckedUpdateManyWithoutFacultyInput>
  }

  export type EventsOrganisedScalarWhereInput = {
    AND?: EventsOrganisedScalarWhereInput | EventsOrganisedScalarWhereInput[]
    OR?: EventsOrganisedScalarWhereInput[]
    NOT?: EventsOrganisedScalarWhereInput | EventsOrganisedScalarWhereInput[]
    FacultyID?: IntFilter<"EventsOrganised"> | number
    Event_id?: IntFilter<"EventsOrganised"> | number
    Title?: StringFilter<"EventsOrganised"> | string
    Organizer?: StringNullableFilter<"EventsOrganised"> | string | null
    Location?: StringNullableFilter<"EventsOrganised"> | string | null
    StartDate?: DateTimeNullableFilter<"EventsOrganised"> | Date | string | null
    EndDate?: DateTimeNullableFilter<"EventsOrganised"> | Date | string | null
    Description?: StringNullableFilter<"EventsOrganised"> | string | null
    Role?: Enumrole_typeNullableFilter<"EventsOrganised"> | $Enums.role_type | null
    FundingAgency?: StringNullableFilter<"EventsOrganised"> | string | null
  }

  export type AwardsUpsertWithWhereUniqueWithoutFacultyInput = {
    where: AwardsWhereUniqueInput
    update: XOR<AwardsUpdateWithoutFacultyInput, AwardsUncheckedUpdateWithoutFacultyInput>
    create: XOR<AwardsCreateWithoutFacultyInput, AwardsUncheckedCreateWithoutFacultyInput>
  }

  export type AwardsUpdateWithWhereUniqueWithoutFacultyInput = {
    where: AwardsWhereUniqueInput
    data: XOR<AwardsUpdateWithoutFacultyInput, AwardsUncheckedUpdateWithoutFacultyInput>
  }

  export type AwardsUpdateManyWithWhereWithoutFacultyInput = {
    where: AwardsScalarWhereInput
    data: XOR<AwardsUpdateManyMutationInput, AwardsUncheckedUpdateManyWithoutFacultyInput>
  }

  export type AwardsScalarWhereInput = {
    AND?: AwardsScalarWhereInput | AwardsScalarWhereInput[]
    OR?: AwardsScalarWhereInput[]
    NOT?: AwardsScalarWhereInput | AwardsScalarWhereInput[]
    AwardID?: IntFilter<"Awards"> | number
    FacultyID?: IntFilter<"Awards"> | number
    AwardName?: StringFilter<"Awards"> | string
    AwardingBody?: StringNullableFilter<"Awards"> | string | null
    Location?: StringNullableFilter<"Awards"> | string | null
    YearAwarded?: IntFilter<"Awards"> | number
  }

  export type TeachingExperienceUpsertWithWhereUniqueWithoutFacultyInput = {
    where: TeachingExperienceWhereUniqueInput
    update: XOR<TeachingExperienceUpdateWithoutFacultyInput, TeachingExperienceUncheckedUpdateWithoutFacultyInput>
    create: XOR<TeachingExperienceCreateWithoutFacultyInput, TeachingExperienceUncheckedCreateWithoutFacultyInput>
  }

  export type TeachingExperienceUpdateWithWhereUniqueWithoutFacultyInput = {
    where: TeachingExperienceWhereUniqueInput
    data: XOR<TeachingExperienceUpdateWithoutFacultyInput, TeachingExperienceUncheckedUpdateWithoutFacultyInput>
  }

  export type TeachingExperienceUpdateManyWithWhereWithoutFacultyInput = {
    where: TeachingExperienceScalarWhereInput
    data: XOR<TeachingExperienceUpdateManyMutationInput, TeachingExperienceUncheckedUpdateManyWithoutFacultyInput>
  }

  export type TeachingExperienceScalarWhereInput = {
    AND?: TeachingExperienceScalarWhereInput | TeachingExperienceScalarWhereInput[]
    OR?: TeachingExperienceScalarWhereInput[]
    NOT?: TeachingExperienceScalarWhereInput | TeachingExperienceScalarWhereInput[]
    ExperienceID?: IntFilter<"TeachingExperience"> | number
    FacultyID?: IntFilter<"TeachingExperience"> | number
    OrganizationName?: StringFilter<"TeachingExperience"> | string
    Designation?: StringFilter<"TeachingExperience"> | string
    StartDate?: DateTimeFilter<"TeachingExperience"> | Date | string
    EndDate?: StringNullableFilter<"TeachingExperience"> | string | null
    NatureOfWork?: StringNullableFilter<"TeachingExperience"> | string | null
  }

  export type CitationMetricsUpsertWithWhereUniqueWithoutFacultyInput = {
    where: CitationMetricsWhereUniqueInput
    update: XOR<CitationMetricsUpdateWithoutFacultyInput, CitationMetricsUncheckedUpdateWithoutFacultyInput>
    create: XOR<CitationMetricsCreateWithoutFacultyInput, CitationMetricsUncheckedCreateWithoutFacultyInput>
  }

  export type CitationMetricsUpdateWithWhereUniqueWithoutFacultyInput = {
    where: CitationMetricsWhereUniqueInput
    data: XOR<CitationMetricsUpdateWithoutFacultyInput, CitationMetricsUncheckedUpdateWithoutFacultyInput>
  }

  export type CitationMetricsUpdateManyWithWhereWithoutFacultyInput = {
    where: CitationMetricsScalarWhereInput
    data: XOR<CitationMetricsUpdateManyMutationInput, CitationMetricsUncheckedUpdateManyWithoutFacultyInput>
  }

  export type CitationMetricsScalarWhereInput = {
    AND?: CitationMetricsScalarWhereInput | CitationMetricsScalarWhereInput[]
    OR?: CitationMetricsScalarWhereInput[]
    NOT?: CitationMetricsScalarWhereInput | CitationMetricsScalarWhereInput[]
    MetricsID?: IntFilter<"CitationMetrics"> | number
    FacultyID?: IntFilter<"CitationMetrics"> | number
    YearRecorded?: IntFilter<"CitationMetrics"> | number
    Source?: StringFilter<"CitationMetrics"> | string
    HIndex?: IntNullableFilter<"CitationMetrics"> | number | null
    I10Index?: IntNullableFilter<"CitationMetrics"> | number | null
    TotalCitations?: IntNullableFilter<"CitationMetrics"> | number | null
    ImpactFactor?: DecimalNullableFilter<"CitationMetrics"> | Decimal | DecimalJsLike | number | string | null
  }

  export type FacultyPublicationLinkUpsertWithWhereUniqueWithoutFacultyInput = {
    where: FacultyPublicationLinkWhereUniqueInput
    update: XOR<FacultyPublicationLinkUpdateWithoutFacultyInput, FacultyPublicationLinkUncheckedUpdateWithoutFacultyInput>
    create: XOR<FacultyPublicationLinkCreateWithoutFacultyInput, FacultyPublicationLinkUncheckedCreateWithoutFacultyInput>
  }

  export type FacultyPublicationLinkUpdateWithWhereUniqueWithoutFacultyInput = {
    where: FacultyPublicationLinkWhereUniqueInput
    data: XOR<FacultyPublicationLinkUpdateWithoutFacultyInput, FacultyPublicationLinkUncheckedUpdateWithoutFacultyInput>
  }

  export type FacultyPublicationLinkUpdateManyWithWhereWithoutFacultyInput = {
    where: FacultyPublicationLinkScalarWhereInput
    data: XOR<FacultyPublicationLinkUpdateManyMutationInput, FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyInput>
  }

  export type FacultyPublicationLinkScalarWhereInput = {
    AND?: FacultyPublicationLinkScalarWhereInput | FacultyPublicationLinkScalarWhereInput[]
    OR?: FacultyPublicationLinkScalarWhereInput[]
    NOT?: FacultyPublicationLinkScalarWhereInput | FacultyPublicationLinkScalarWhereInput[]
    PublicationID?: IntFilter<"FacultyPublicationLink"> | number
    FacultyID?: IntFilter<"FacultyPublicationLink"> | number
    TypeOfIndexing?: StringNullableFilter<"FacultyPublicationLink"> | string | null
  }

  export type PatentsUpsertWithWhereUniqueWithoutFacultyInput = {
    where: PatentsWhereUniqueInput
    update: XOR<PatentsUpdateWithoutFacultyInput, PatentsUncheckedUpdateWithoutFacultyInput>
    create: XOR<PatentsCreateWithoutFacultyInput, PatentsUncheckedCreateWithoutFacultyInput>
  }

  export type PatentsUpdateWithWhereUniqueWithoutFacultyInput = {
    where: PatentsWhereUniqueInput
    data: XOR<PatentsUpdateWithoutFacultyInput, PatentsUncheckedUpdateWithoutFacultyInput>
  }

  export type PatentsUpdateManyWithWhereWithoutFacultyInput = {
    where: PatentsScalarWhereInput
    data: XOR<PatentsUpdateManyMutationInput, PatentsUncheckedUpdateManyWithoutFacultyInput>
  }

  export type PatentsScalarWhereInput = {
    AND?: PatentsScalarWhereInput | PatentsScalarWhereInput[]
    OR?: PatentsScalarWhereInput[]
    NOT?: PatentsScalarWhereInput | PatentsScalarWhereInput[]
    TypeID?: StringFilter<"Patents"> | string
    FacultyID?: IntFilter<"Patents"> | number
    Title?: StringFilter<"Patents"> | string
    FilingDate?: DateTimeFilter<"Patents"> | Date | string
    PublicationDate?: DateTimeNullableFilter<"Patents"> | Date | string | null
    PatentNumber?: StringFilter<"Patents"> | string
    Authority?: StringNullableFilter<"Patents"> | string | null
    CollaborationInstitute?: StringNullableFilter<"Patents"> | string | null
  }

  export type ResearchProjectsUpsertWithWhereUniqueWithoutFacultyInput = {
    where: ResearchProjectsWhereUniqueInput
    update: XOR<ResearchProjectsUpdateWithoutFacultyInput, ResearchProjectsUncheckedUpdateWithoutFacultyInput>
    create: XOR<ResearchProjectsCreateWithoutFacultyInput, ResearchProjectsUncheckedCreateWithoutFacultyInput>
  }

  export type ResearchProjectsUpdateWithWhereUniqueWithoutFacultyInput = {
    where: ResearchProjectsWhereUniqueInput
    data: XOR<ResearchProjectsUpdateWithoutFacultyInput, ResearchProjectsUncheckedUpdateWithoutFacultyInput>
  }

  export type ResearchProjectsUpdateManyWithWhereWithoutFacultyInput = {
    where: ResearchProjectsScalarWhereInput
    data: XOR<ResearchProjectsUpdateManyMutationInput, ResearchProjectsUncheckedUpdateManyWithoutFacultyInput>
  }

  export type ResearchProjectsScalarWhereInput = {
    AND?: ResearchProjectsScalarWhereInput | ResearchProjectsScalarWhereInput[]
    OR?: ResearchProjectsScalarWhereInput[]
    NOT?: ResearchProjectsScalarWhereInput | ResearchProjectsScalarWhereInput[]
    TypeID?: StringFilter<"ResearchProjects"> | string
    FacultyID?: IntFilter<"ResearchProjects"> | number
    Title?: StringFilter<"ResearchProjects"> | string
    FundingAgency?: StringNullableFilter<"ResearchProjects"> | string | null
    StartDate?: DateTimeFilter<"ResearchProjects"> | Date | string
    EndDate?: DateTimeNullableFilter<"ResearchProjects"> | Date | string | null
    Budget?: DecimalNullableFilter<"ResearchProjects"> | Decimal | DecimalJsLike | number | string | null
  }

  export type FacultyCreateWithoutSubjectsTaughtInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutSubjectsTaughtInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutSubjectsTaughtInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutSubjectsTaughtInput, FacultyUncheckedCreateWithoutSubjectsTaughtInput>
  }

  export type FacultyUpsertWithoutSubjectsTaughtInput = {
    update: XOR<FacultyUpdateWithoutSubjectsTaughtInput, FacultyUncheckedUpdateWithoutSubjectsTaughtInput>
    create: XOR<FacultyCreateWithoutSubjectsTaughtInput, FacultyUncheckedCreateWithoutSubjectsTaughtInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutSubjectsTaughtInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutSubjectsTaughtInput, FacultyUncheckedUpdateWithoutSubjectsTaughtInput>
  }

  export type FacultyUpdateWithoutSubjectsTaughtInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutSubjectsTaughtInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyCreateWithoutQualificationsInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutQualificationsInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutQualificationsInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutQualificationsInput, FacultyUncheckedCreateWithoutQualificationsInput>
  }

  export type FacultyUpsertWithoutQualificationsInput = {
    update: XOR<FacultyUpdateWithoutQualificationsInput, FacultyUncheckedUpdateWithoutQualificationsInput>
    create: XOR<FacultyCreateWithoutQualificationsInput, FacultyUncheckedCreateWithoutQualificationsInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutQualificationsInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutQualificationsInput, FacultyUncheckedUpdateWithoutQualificationsInput>
  }

  export type FacultyUpdateWithoutQualificationsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutQualificationsInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyCreateWithoutOutreachActivitiesInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutOutreachActivitiesInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutOutreachActivitiesInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutOutreachActivitiesInput, FacultyUncheckedCreateWithoutOutreachActivitiesInput>
  }

  export type FacultyUpsertWithoutOutreachActivitiesInput = {
    update: XOR<FacultyUpdateWithoutOutreachActivitiesInput, FacultyUncheckedUpdateWithoutOutreachActivitiesInput>
    create: XOR<FacultyCreateWithoutOutreachActivitiesInput, FacultyUncheckedCreateWithoutOutreachActivitiesInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutOutreachActivitiesInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutOutreachActivitiesInput, FacultyUncheckedUpdateWithoutOutreachActivitiesInput>
  }

  export type FacultyUpdateWithoutOutreachActivitiesInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutOutreachActivitiesInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type EventsOrganisedCreateWithoutEventInput = {
    Title: string
    Organizer?: string | null
    Location?: string | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Description?: string | null
    Role?: $Enums.role_type | null
    FundingAgency?: string | null
    Faculty: FacultyCreateNestedOneWithoutEventsOrganisedInput
  }

  export type EventsOrganisedUncheckedCreateWithoutEventInput = {
    FacultyID: number
    Title: string
    Organizer?: string | null
    Location?: string | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Description?: string | null
    Role?: $Enums.role_type | null
    FundingAgency?: string | null
  }

  export type EventsOrganisedCreateOrConnectWithoutEventInput = {
    where: EventsOrganisedWhereUniqueInput
    create: XOR<EventsOrganisedCreateWithoutEventInput, EventsOrganisedUncheckedCreateWithoutEventInput>
  }

  export type EventsOrganisedCreateManyEventInputEnvelope = {
    data: EventsOrganisedCreateManyEventInput | EventsOrganisedCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventsOrganisedUpsertWithWhereUniqueWithoutEventInput = {
    where: EventsOrganisedWhereUniqueInput
    update: XOR<EventsOrganisedUpdateWithoutEventInput, EventsOrganisedUncheckedUpdateWithoutEventInput>
    create: XOR<EventsOrganisedCreateWithoutEventInput, EventsOrganisedUncheckedCreateWithoutEventInput>
  }

  export type EventsOrganisedUpdateWithWhereUniqueWithoutEventInput = {
    where: EventsOrganisedWhereUniqueInput
    data: XOR<EventsOrganisedUpdateWithoutEventInput, EventsOrganisedUncheckedUpdateWithoutEventInput>
  }

  export type EventsOrganisedUpdateManyWithWhereWithoutEventInput = {
    where: EventsOrganisedScalarWhereInput
    data: XOR<EventsOrganisedUpdateManyMutationInput, EventsOrganisedUncheckedUpdateManyWithoutEventInput>
  }

  export type FacultyCreateWithoutEventsOrganisedInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutEventsOrganisedInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutEventsOrganisedInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutEventsOrganisedInput, FacultyUncheckedCreateWithoutEventsOrganisedInput>
  }

  export type EventTypeCreateWithoutEventsOrganisedInput = {
    EventID: number
    EventType: $Enums.event_type
  }

  export type EventTypeUncheckedCreateWithoutEventsOrganisedInput = {
    EventID: number
    EventType: $Enums.event_type
  }

  export type EventTypeCreateOrConnectWithoutEventsOrganisedInput = {
    where: EventTypeWhereUniqueInput
    create: XOR<EventTypeCreateWithoutEventsOrganisedInput, EventTypeUncheckedCreateWithoutEventsOrganisedInput>
  }

  export type FacultyUpsertWithoutEventsOrganisedInput = {
    update: XOR<FacultyUpdateWithoutEventsOrganisedInput, FacultyUncheckedUpdateWithoutEventsOrganisedInput>
    create: XOR<FacultyCreateWithoutEventsOrganisedInput, FacultyUncheckedCreateWithoutEventsOrganisedInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutEventsOrganisedInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutEventsOrganisedInput, FacultyUncheckedUpdateWithoutEventsOrganisedInput>
  }

  export type FacultyUpdateWithoutEventsOrganisedInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutEventsOrganisedInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type EventTypeUpsertWithoutEventsOrganisedInput = {
    update: XOR<EventTypeUpdateWithoutEventsOrganisedInput, EventTypeUncheckedUpdateWithoutEventsOrganisedInput>
    create: XOR<EventTypeCreateWithoutEventsOrganisedInput, EventTypeUncheckedCreateWithoutEventsOrganisedInput>
    where?: EventTypeWhereInput
  }

  export type EventTypeUpdateToOneWithWhereWithoutEventsOrganisedInput = {
    where?: EventTypeWhereInput
    data: XOR<EventTypeUpdateWithoutEventsOrganisedInput, EventTypeUncheckedUpdateWithoutEventsOrganisedInput>
  }

  export type EventTypeUpdateWithoutEventsOrganisedInput = {
    EventID?: IntFieldUpdateOperationsInput | number
    EventType?: Enumevent_typeFieldUpdateOperationsInput | $Enums.event_type
  }

  export type EventTypeUncheckedUpdateWithoutEventsOrganisedInput = {
    EventID?: IntFieldUpdateOperationsInput | number
    EventType?: Enumevent_typeFieldUpdateOperationsInput | $Enums.event_type
  }

  export type FacultyCreateWithoutAwardsInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutAwardsInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutAwardsInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutAwardsInput, FacultyUncheckedCreateWithoutAwardsInput>
  }

  export type FacultyUpsertWithoutAwardsInput = {
    update: XOR<FacultyUpdateWithoutAwardsInput, FacultyUncheckedUpdateWithoutAwardsInput>
    create: XOR<FacultyCreateWithoutAwardsInput, FacultyUncheckedCreateWithoutAwardsInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutAwardsInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutAwardsInput, FacultyUncheckedUpdateWithoutAwardsInput>
  }

  export type FacultyUpdateWithoutAwardsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutAwardsInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyCreateWithoutTeachingExperiencesInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutTeachingExperiencesInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutTeachingExperiencesInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutTeachingExperiencesInput, FacultyUncheckedCreateWithoutTeachingExperiencesInput>
  }

  export type FacultyUpsertWithoutTeachingExperiencesInput = {
    update: XOR<FacultyUpdateWithoutTeachingExperiencesInput, FacultyUncheckedUpdateWithoutTeachingExperiencesInput>
    create: XOR<FacultyCreateWithoutTeachingExperiencesInput, FacultyUncheckedCreateWithoutTeachingExperiencesInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutTeachingExperiencesInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutTeachingExperiencesInput, FacultyUncheckedUpdateWithoutTeachingExperiencesInput>
  }

  export type FacultyUpdateWithoutTeachingExperiencesInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutTeachingExperiencesInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyCreateWithoutCitationMetricsInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutCitationMetricsInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutCitationMetricsInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutCitationMetricsInput, FacultyUncheckedCreateWithoutCitationMetricsInput>
  }

  export type FacultyUpsertWithoutCitationMetricsInput = {
    update: XOR<FacultyUpdateWithoutCitationMetricsInput, FacultyUncheckedUpdateWithoutCitationMetricsInput>
    create: XOR<FacultyCreateWithoutCitationMetricsInput, FacultyUncheckedCreateWithoutCitationMetricsInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutCitationMetricsInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutCitationMetricsInput, FacultyUncheckedUpdateWithoutCitationMetricsInput>
  }

  export type FacultyUpdateWithoutCitationMetricsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutCitationMetricsInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type PublicationsCreateWithoutTypeInput = {
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    JournalPublicationDetails?: JournalPublicationDetailsCreateNestedOneWithoutPublicationInput
    BookPublicationDetails?: BookPublicationDetailsCreateNestedOneWithoutPublicationInput
    ConferencePaperDetails?: ConferencePaperDetailsCreateNestedOneWithoutPublicationInput
    FacultyPublicationLink?: FacultyPublicationLinkCreateNestedManyWithoutPublicationInput
  }

  export type PublicationsUncheckedCreateWithoutTypeInput = {
    PublicationID?: number
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    JournalPublicationDetails?: JournalPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput
    BookPublicationDetails?: BookPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput
    ConferencePaperDetails?: ConferencePaperDetailsUncheckedCreateNestedOneWithoutPublicationInput
    FacultyPublicationLink?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationsCreateOrConnectWithoutTypeInput = {
    where: PublicationsWhereUniqueInput
    create: XOR<PublicationsCreateWithoutTypeInput, PublicationsUncheckedCreateWithoutTypeInput>
  }

  export type PublicationsCreateManyTypeInputEnvelope = {
    data: PublicationsCreateManyTypeInput | PublicationsCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type PatentsCreateWithoutTypeInput = {
    Title: string
    FilingDate: Date | string
    PublicationDate?: Date | string | null
    PatentNumber: string
    Authority?: string | null
    CollaborationInstitute?: string | null
    Faculty: FacultyCreateNestedOneWithoutPatentsInput
  }

  export type PatentsUncheckedCreateWithoutTypeInput = {
    FacultyID: number
    Title: string
    FilingDate: Date | string
    PublicationDate?: Date | string | null
    PatentNumber: string
    Authority?: string | null
    CollaborationInstitute?: string | null
  }

  export type PatentsCreateOrConnectWithoutTypeInput = {
    where: PatentsWhereUniqueInput
    create: XOR<PatentsCreateWithoutTypeInput, PatentsUncheckedCreateWithoutTypeInput>
  }

  export type PatentsCreateManyTypeInputEnvelope = {
    data: PatentsCreateManyTypeInput | PatentsCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type ResearchProjectsCreateWithoutTypeInput = {
    Title: string
    FundingAgency?: string | null
    StartDate: Date | string
    EndDate?: Date | string | null
    Budget?: Decimal | DecimalJsLike | number | string | null
    Faculty: FacultyCreateNestedOneWithoutResearchProjectsInput
  }

  export type ResearchProjectsUncheckedCreateWithoutTypeInput = {
    FacultyID: number
    Title: string
    FundingAgency?: string | null
    StartDate: Date | string
    EndDate?: Date | string | null
    Budget?: Decimal | DecimalJsLike | number | string | null
  }

  export type ResearchProjectsCreateOrConnectWithoutTypeInput = {
    where: ResearchProjectsWhereUniqueInput
    create: XOR<ResearchProjectsCreateWithoutTypeInput, ResearchProjectsUncheckedCreateWithoutTypeInput>
  }

  export type ResearchProjectsCreateManyTypeInputEnvelope = {
    data: ResearchProjectsCreateManyTypeInput | ResearchProjectsCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type PublicationsUpsertWithWhereUniqueWithoutTypeInput = {
    where: PublicationsWhereUniqueInput
    update: XOR<PublicationsUpdateWithoutTypeInput, PublicationsUncheckedUpdateWithoutTypeInput>
    create: XOR<PublicationsCreateWithoutTypeInput, PublicationsUncheckedCreateWithoutTypeInput>
  }

  export type PublicationsUpdateWithWhereUniqueWithoutTypeInput = {
    where: PublicationsWhereUniqueInput
    data: XOR<PublicationsUpdateWithoutTypeInput, PublicationsUncheckedUpdateWithoutTypeInput>
  }

  export type PublicationsUpdateManyWithWhereWithoutTypeInput = {
    where: PublicationsScalarWhereInput
    data: XOR<PublicationsUpdateManyMutationInput, PublicationsUncheckedUpdateManyWithoutTypeInput>
  }

  export type PublicationsScalarWhereInput = {
    AND?: PublicationsScalarWhereInput | PublicationsScalarWhereInput[]
    OR?: PublicationsScalarWhereInput[]
    NOT?: PublicationsScalarWhereInput | PublicationsScalarWhereInput[]
    PublicationID?: IntFilter<"Publications"> | number
    TypeID?: StringFilter<"Publications"> | string
    Authors?: StringFilter<"Publications"> | string
    Title?: StringFilter<"Publications"> | string
    PublicationYear?: DateTimeFilter<"Publications"> | Date | string
    FundingAgency?: StringNullableFilter<"Publications"> | string | null
  }

  export type PatentsUpsertWithWhereUniqueWithoutTypeInput = {
    where: PatentsWhereUniqueInput
    update: XOR<PatentsUpdateWithoutTypeInput, PatentsUncheckedUpdateWithoutTypeInput>
    create: XOR<PatentsCreateWithoutTypeInput, PatentsUncheckedCreateWithoutTypeInput>
  }

  export type PatentsUpdateWithWhereUniqueWithoutTypeInput = {
    where: PatentsWhereUniqueInput
    data: XOR<PatentsUpdateWithoutTypeInput, PatentsUncheckedUpdateWithoutTypeInput>
  }

  export type PatentsUpdateManyWithWhereWithoutTypeInput = {
    where: PatentsScalarWhereInput
    data: XOR<PatentsUpdateManyMutationInput, PatentsUncheckedUpdateManyWithoutTypeInput>
  }

  export type ResearchProjectsUpsertWithWhereUniqueWithoutTypeInput = {
    where: ResearchProjectsWhereUniqueInput
    update: XOR<ResearchProjectsUpdateWithoutTypeInput, ResearchProjectsUncheckedUpdateWithoutTypeInput>
    create: XOR<ResearchProjectsCreateWithoutTypeInput, ResearchProjectsUncheckedCreateWithoutTypeInput>
  }

  export type ResearchProjectsUpdateWithWhereUniqueWithoutTypeInput = {
    where: ResearchProjectsWhereUniqueInput
    data: XOR<ResearchProjectsUpdateWithoutTypeInput, ResearchProjectsUncheckedUpdateWithoutTypeInput>
  }

  export type ResearchProjectsUpdateManyWithWhereWithoutTypeInput = {
    where: ResearchProjectsScalarWhereInput
    data: XOR<ResearchProjectsUpdateManyMutationInput, ResearchProjectsUncheckedUpdateManyWithoutTypeInput>
  }

  export type TYPESCreateWithoutPublicationsInput = {
    TypeID: string
    Type: $Enums.publication_type
    Status?: string | null
    Patents?: PatentsCreateNestedManyWithoutTypeInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutTypeInput
  }

  export type TYPESUncheckedCreateWithoutPublicationsInput = {
    TypeID: string
    Type: $Enums.publication_type
    Status?: string | null
    Patents?: PatentsUncheckedCreateNestedManyWithoutTypeInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TYPESCreateOrConnectWithoutPublicationsInput = {
    where: TYPESWhereUniqueInput
    create: XOR<TYPESCreateWithoutPublicationsInput, TYPESUncheckedCreateWithoutPublicationsInput>
  }

  export type JournalPublicationDetailsCreateWithoutPublicationInput = {
    Name?: string | null
    VolumeNumber?: string | null
    IssueNumber?: string | null
    ISSN_Number?: number | null
  }

  export type JournalPublicationDetailsUncheckedCreateWithoutPublicationInput = {
    Name?: string | null
    VolumeNumber?: string | null
    IssueNumber?: string | null
    ISSN_Number?: number | null
  }

  export type JournalPublicationDetailsCreateOrConnectWithoutPublicationInput = {
    where: JournalPublicationDetailsWhereUniqueInput
    create: XOR<JournalPublicationDetailsCreateWithoutPublicationInput, JournalPublicationDetailsUncheckedCreateWithoutPublicationInput>
  }

  export type BookPublicationDetailsCreateWithoutPublicationInput = {
    Publisher?: string | null
    Edition?: string | null
    VolumeNumber?: string | null
    ISBN_Number?: string | null
  }

  export type BookPublicationDetailsUncheckedCreateWithoutPublicationInput = {
    Publisher?: string | null
    Edition?: string | null
    VolumeNumber?: string | null
    ISBN_Number?: string | null
  }

  export type BookPublicationDetailsCreateOrConnectWithoutPublicationInput = {
    where: BookPublicationDetailsWhereUniqueInput
    create: XOR<BookPublicationDetailsCreateWithoutPublicationInput, BookPublicationDetailsUncheckedCreateWithoutPublicationInput>
  }

  export type ConferencePaperDetailsCreateWithoutPublicationInput = {
    Publisher?: string | null
    Location?: string | null
    PageNumbers?: string | null
  }

  export type ConferencePaperDetailsUncheckedCreateWithoutPublicationInput = {
    Publisher?: string | null
    Location?: string | null
    PageNumbers?: string | null
  }

  export type ConferencePaperDetailsCreateOrConnectWithoutPublicationInput = {
    where: ConferencePaperDetailsWhereUniqueInput
    create: XOR<ConferencePaperDetailsCreateWithoutPublicationInput, ConferencePaperDetailsUncheckedCreateWithoutPublicationInput>
  }

  export type FacultyPublicationLinkCreateWithoutPublicationInput = {
    TypeOfIndexing?: string | null
    Faculty: FacultyCreateNestedOneWithoutPublicationsInput
  }

  export type FacultyPublicationLinkUncheckedCreateWithoutPublicationInput = {
    FacultyID: number
    TypeOfIndexing?: string | null
  }

  export type FacultyPublicationLinkCreateOrConnectWithoutPublicationInput = {
    where: FacultyPublicationLinkWhereUniqueInput
    create: XOR<FacultyPublicationLinkCreateWithoutPublicationInput, FacultyPublicationLinkUncheckedCreateWithoutPublicationInput>
  }

  export type FacultyPublicationLinkCreateManyPublicationInputEnvelope = {
    data: FacultyPublicationLinkCreateManyPublicationInput | FacultyPublicationLinkCreateManyPublicationInput[]
    skipDuplicates?: boolean
  }

  export type TYPESUpsertWithoutPublicationsInput = {
    update: XOR<TYPESUpdateWithoutPublicationsInput, TYPESUncheckedUpdateWithoutPublicationsInput>
    create: XOR<TYPESCreateWithoutPublicationsInput, TYPESUncheckedCreateWithoutPublicationsInput>
    where?: TYPESWhereInput
  }

  export type TYPESUpdateToOneWithWhereWithoutPublicationsInput = {
    where?: TYPESWhereInput
    data: XOR<TYPESUpdateWithoutPublicationsInput, TYPESUncheckedUpdateWithoutPublicationsInput>
  }

  export type TYPESUpdateWithoutPublicationsInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Type?: Enumpublication_typeFieldUpdateOperationsInput | $Enums.publication_type
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Patents?: PatentsUpdateManyWithoutTypeNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutTypeNestedInput
  }

  export type TYPESUncheckedUpdateWithoutPublicationsInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Type?: Enumpublication_typeFieldUpdateOperationsInput | $Enums.publication_type
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Patents?: PatentsUncheckedUpdateManyWithoutTypeNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type JournalPublicationDetailsUpsertWithoutPublicationInput = {
    update: XOR<JournalPublicationDetailsUpdateWithoutPublicationInput, JournalPublicationDetailsUncheckedUpdateWithoutPublicationInput>
    create: XOR<JournalPublicationDetailsCreateWithoutPublicationInput, JournalPublicationDetailsUncheckedCreateWithoutPublicationInput>
    where?: JournalPublicationDetailsWhereInput
  }

  export type JournalPublicationDetailsUpdateToOneWithWhereWithoutPublicationInput = {
    where?: JournalPublicationDetailsWhereInput
    data: XOR<JournalPublicationDetailsUpdateWithoutPublicationInput, JournalPublicationDetailsUncheckedUpdateWithoutPublicationInput>
  }

  export type JournalPublicationDetailsUpdateWithoutPublicationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IssueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISSN_Number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JournalPublicationDetailsUncheckedUpdateWithoutPublicationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IssueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISSN_Number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookPublicationDetailsUpsertWithoutPublicationInput = {
    update: XOR<BookPublicationDetailsUpdateWithoutPublicationInput, BookPublicationDetailsUncheckedUpdateWithoutPublicationInput>
    create: XOR<BookPublicationDetailsCreateWithoutPublicationInput, BookPublicationDetailsUncheckedCreateWithoutPublicationInput>
    where?: BookPublicationDetailsWhereInput
  }

  export type BookPublicationDetailsUpdateToOneWithWhereWithoutPublicationInput = {
    where?: BookPublicationDetailsWhereInput
    data: XOR<BookPublicationDetailsUpdateWithoutPublicationInput, BookPublicationDetailsUncheckedUpdateWithoutPublicationInput>
  }

  export type BookPublicationDetailsUpdateWithoutPublicationInput = {
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Edition?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISBN_Number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookPublicationDetailsUncheckedUpdateWithoutPublicationInput = {
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Edition?: NullableStringFieldUpdateOperationsInput | string | null
    VolumeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ISBN_Number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConferencePaperDetailsUpsertWithoutPublicationInput = {
    update: XOR<ConferencePaperDetailsUpdateWithoutPublicationInput, ConferencePaperDetailsUncheckedUpdateWithoutPublicationInput>
    create: XOR<ConferencePaperDetailsCreateWithoutPublicationInput, ConferencePaperDetailsUncheckedCreateWithoutPublicationInput>
    where?: ConferencePaperDetailsWhereInput
  }

  export type ConferencePaperDetailsUpdateToOneWithWhereWithoutPublicationInput = {
    where?: ConferencePaperDetailsWhereInput
    data: XOR<ConferencePaperDetailsUpdateWithoutPublicationInput, ConferencePaperDetailsUncheckedUpdateWithoutPublicationInput>
  }

  export type ConferencePaperDetailsUpdateWithoutPublicationInput = {
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    PageNumbers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConferencePaperDetailsUncheckedUpdateWithoutPublicationInput = {
    Publisher?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    PageNumbers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyPublicationLinkUpsertWithWhereUniqueWithoutPublicationInput = {
    where: FacultyPublicationLinkWhereUniqueInput
    update: XOR<FacultyPublicationLinkUpdateWithoutPublicationInput, FacultyPublicationLinkUncheckedUpdateWithoutPublicationInput>
    create: XOR<FacultyPublicationLinkCreateWithoutPublicationInput, FacultyPublicationLinkUncheckedCreateWithoutPublicationInput>
  }

  export type FacultyPublicationLinkUpdateWithWhereUniqueWithoutPublicationInput = {
    where: FacultyPublicationLinkWhereUniqueInput
    data: XOR<FacultyPublicationLinkUpdateWithoutPublicationInput, FacultyPublicationLinkUncheckedUpdateWithoutPublicationInput>
  }

  export type FacultyPublicationLinkUpdateManyWithWhereWithoutPublicationInput = {
    where: FacultyPublicationLinkScalarWhereInput
    data: XOR<FacultyPublicationLinkUpdateManyMutationInput, FacultyPublicationLinkUncheckedUpdateManyWithoutPublicationInput>
  }

  export type PublicationsCreateWithoutJournalPublicationDetailsInput = {
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    Type: TYPESCreateNestedOneWithoutPublicationsInput
    BookPublicationDetails?: BookPublicationDetailsCreateNestedOneWithoutPublicationInput
    ConferencePaperDetails?: ConferencePaperDetailsCreateNestedOneWithoutPublicationInput
    FacultyPublicationLink?: FacultyPublicationLinkCreateNestedManyWithoutPublicationInput
  }

  export type PublicationsUncheckedCreateWithoutJournalPublicationDetailsInput = {
    PublicationID?: number
    TypeID: string
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    BookPublicationDetails?: BookPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput
    ConferencePaperDetails?: ConferencePaperDetailsUncheckedCreateNestedOneWithoutPublicationInput
    FacultyPublicationLink?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationsCreateOrConnectWithoutJournalPublicationDetailsInput = {
    where: PublicationsWhereUniqueInput
    create: XOR<PublicationsCreateWithoutJournalPublicationDetailsInput, PublicationsUncheckedCreateWithoutJournalPublicationDetailsInput>
  }

  export type PublicationsUpsertWithoutJournalPublicationDetailsInput = {
    update: XOR<PublicationsUpdateWithoutJournalPublicationDetailsInput, PublicationsUncheckedUpdateWithoutJournalPublicationDetailsInput>
    create: XOR<PublicationsCreateWithoutJournalPublicationDetailsInput, PublicationsUncheckedCreateWithoutJournalPublicationDetailsInput>
    where?: PublicationsWhereInput
  }

  export type PublicationsUpdateToOneWithWhereWithoutJournalPublicationDetailsInput = {
    where?: PublicationsWhereInput
    data: XOR<PublicationsUpdateWithoutJournalPublicationDetailsInput, PublicationsUncheckedUpdateWithoutJournalPublicationDetailsInput>
  }

  export type PublicationsUpdateWithoutJournalPublicationDetailsInput = {
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: TYPESUpdateOneRequiredWithoutPublicationsNestedInput
    BookPublicationDetails?: BookPublicationDetailsUpdateOneWithoutPublicationNestedInput
    ConferencePaperDetails?: ConferencePaperDetailsUpdateOneWithoutPublicationNestedInput
    FacultyPublicationLink?: FacultyPublicationLinkUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationsUncheckedUpdateWithoutJournalPublicationDetailsInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    TypeID?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    BookPublicationDetails?: BookPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    ConferencePaperDetails?: ConferencePaperDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    FacultyPublicationLink?: FacultyPublicationLinkUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationsCreateWithoutBookPublicationDetailsInput = {
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    Type: TYPESCreateNestedOneWithoutPublicationsInput
    JournalPublicationDetails?: JournalPublicationDetailsCreateNestedOneWithoutPublicationInput
    ConferencePaperDetails?: ConferencePaperDetailsCreateNestedOneWithoutPublicationInput
    FacultyPublicationLink?: FacultyPublicationLinkCreateNestedManyWithoutPublicationInput
  }

  export type PublicationsUncheckedCreateWithoutBookPublicationDetailsInput = {
    PublicationID?: number
    TypeID: string
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    JournalPublicationDetails?: JournalPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput
    ConferencePaperDetails?: ConferencePaperDetailsUncheckedCreateNestedOneWithoutPublicationInput
    FacultyPublicationLink?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationsCreateOrConnectWithoutBookPublicationDetailsInput = {
    where: PublicationsWhereUniqueInput
    create: XOR<PublicationsCreateWithoutBookPublicationDetailsInput, PublicationsUncheckedCreateWithoutBookPublicationDetailsInput>
  }

  export type PublicationsUpsertWithoutBookPublicationDetailsInput = {
    update: XOR<PublicationsUpdateWithoutBookPublicationDetailsInput, PublicationsUncheckedUpdateWithoutBookPublicationDetailsInput>
    create: XOR<PublicationsCreateWithoutBookPublicationDetailsInput, PublicationsUncheckedCreateWithoutBookPublicationDetailsInput>
    where?: PublicationsWhereInput
  }

  export type PublicationsUpdateToOneWithWhereWithoutBookPublicationDetailsInput = {
    where?: PublicationsWhereInput
    data: XOR<PublicationsUpdateWithoutBookPublicationDetailsInput, PublicationsUncheckedUpdateWithoutBookPublicationDetailsInput>
  }

  export type PublicationsUpdateWithoutBookPublicationDetailsInput = {
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: TYPESUpdateOneRequiredWithoutPublicationsNestedInput
    JournalPublicationDetails?: JournalPublicationDetailsUpdateOneWithoutPublicationNestedInput
    ConferencePaperDetails?: ConferencePaperDetailsUpdateOneWithoutPublicationNestedInput
    FacultyPublicationLink?: FacultyPublicationLinkUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationsUncheckedUpdateWithoutBookPublicationDetailsInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    TypeID?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    JournalPublicationDetails?: JournalPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    ConferencePaperDetails?: ConferencePaperDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    FacultyPublicationLink?: FacultyPublicationLinkUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationsCreateWithoutConferencePaperDetailsInput = {
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    Type: TYPESCreateNestedOneWithoutPublicationsInput
    JournalPublicationDetails?: JournalPublicationDetailsCreateNestedOneWithoutPublicationInput
    BookPublicationDetails?: BookPublicationDetailsCreateNestedOneWithoutPublicationInput
    FacultyPublicationLink?: FacultyPublicationLinkCreateNestedManyWithoutPublicationInput
  }

  export type PublicationsUncheckedCreateWithoutConferencePaperDetailsInput = {
    PublicationID?: number
    TypeID: string
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    JournalPublicationDetails?: JournalPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput
    BookPublicationDetails?: BookPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput
    FacultyPublicationLink?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationsCreateOrConnectWithoutConferencePaperDetailsInput = {
    where: PublicationsWhereUniqueInput
    create: XOR<PublicationsCreateWithoutConferencePaperDetailsInput, PublicationsUncheckedCreateWithoutConferencePaperDetailsInput>
  }

  export type PublicationsUpsertWithoutConferencePaperDetailsInput = {
    update: XOR<PublicationsUpdateWithoutConferencePaperDetailsInput, PublicationsUncheckedUpdateWithoutConferencePaperDetailsInput>
    create: XOR<PublicationsCreateWithoutConferencePaperDetailsInput, PublicationsUncheckedCreateWithoutConferencePaperDetailsInput>
    where?: PublicationsWhereInput
  }

  export type PublicationsUpdateToOneWithWhereWithoutConferencePaperDetailsInput = {
    where?: PublicationsWhereInput
    data: XOR<PublicationsUpdateWithoutConferencePaperDetailsInput, PublicationsUncheckedUpdateWithoutConferencePaperDetailsInput>
  }

  export type PublicationsUpdateWithoutConferencePaperDetailsInput = {
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: TYPESUpdateOneRequiredWithoutPublicationsNestedInput
    JournalPublicationDetails?: JournalPublicationDetailsUpdateOneWithoutPublicationNestedInput
    BookPublicationDetails?: BookPublicationDetailsUpdateOneWithoutPublicationNestedInput
    FacultyPublicationLink?: FacultyPublicationLinkUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationsUncheckedUpdateWithoutConferencePaperDetailsInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    TypeID?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    JournalPublicationDetails?: JournalPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    BookPublicationDetails?: BookPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    FacultyPublicationLink?: FacultyPublicationLinkUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type FacultyCreateWithoutPublicationsInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutPublicationsInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutPublicationsInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutPublicationsInput, FacultyUncheckedCreateWithoutPublicationsInput>
  }

  export type PublicationsCreateWithoutFacultyPublicationLinkInput = {
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    Type: TYPESCreateNestedOneWithoutPublicationsInput
    JournalPublicationDetails?: JournalPublicationDetailsCreateNestedOneWithoutPublicationInput
    BookPublicationDetails?: BookPublicationDetailsCreateNestedOneWithoutPublicationInput
    ConferencePaperDetails?: ConferencePaperDetailsCreateNestedOneWithoutPublicationInput
  }

  export type PublicationsUncheckedCreateWithoutFacultyPublicationLinkInput = {
    PublicationID?: number
    TypeID: string
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
    JournalPublicationDetails?: JournalPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput
    BookPublicationDetails?: BookPublicationDetailsUncheckedCreateNestedOneWithoutPublicationInput
    ConferencePaperDetails?: ConferencePaperDetailsUncheckedCreateNestedOneWithoutPublicationInput
  }

  export type PublicationsCreateOrConnectWithoutFacultyPublicationLinkInput = {
    where: PublicationsWhereUniqueInput
    create: XOR<PublicationsCreateWithoutFacultyPublicationLinkInput, PublicationsUncheckedCreateWithoutFacultyPublicationLinkInput>
  }

  export type FacultyUpsertWithoutPublicationsInput = {
    update: XOR<FacultyUpdateWithoutPublicationsInput, FacultyUncheckedUpdateWithoutPublicationsInput>
    create: XOR<FacultyCreateWithoutPublicationsInput, FacultyUncheckedCreateWithoutPublicationsInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutPublicationsInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutPublicationsInput, FacultyUncheckedUpdateWithoutPublicationsInput>
  }

  export type FacultyUpdateWithoutPublicationsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutPublicationsInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type PublicationsUpsertWithoutFacultyPublicationLinkInput = {
    update: XOR<PublicationsUpdateWithoutFacultyPublicationLinkInput, PublicationsUncheckedUpdateWithoutFacultyPublicationLinkInput>
    create: XOR<PublicationsCreateWithoutFacultyPublicationLinkInput, PublicationsUncheckedCreateWithoutFacultyPublicationLinkInput>
    where?: PublicationsWhereInput
  }

  export type PublicationsUpdateToOneWithWhereWithoutFacultyPublicationLinkInput = {
    where?: PublicationsWhereInput
    data: XOR<PublicationsUpdateWithoutFacultyPublicationLinkInput, PublicationsUncheckedUpdateWithoutFacultyPublicationLinkInput>
  }

  export type PublicationsUpdateWithoutFacultyPublicationLinkInput = {
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: TYPESUpdateOneRequiredWithoutPublicationsNestedInput
    JournalPublicationDetails?: JournalPublicationDetailsUpdateOneWithoutPublicationNestedInput
    BookPublicationDetails?: BookPublicationDetailsUpdateOneWithoutPublicationNestedInput
    ConferencePaperDetails?: ConferencePaperDetailsUpdateOneWithoutPublicationNestedInput
  }

  export type PublicationsUncheckedUpdateWithoutFacultyPublicationLinkInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    TypeID?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    JournalPublicationDetails?: JournalPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    BookPublicationDetails?: BookPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    ConferencePaperDetails?: ConferencePaperDetailsUncheckedUpdateOneWithoutPublicationNestedInput
  }

  export type FacultyCreateWithoutPatentsInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutPatentsInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutPatentsInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutPatentsInput, FacultyUncheckedCreateWithoutPatentsInput>
  }

  export type TYPESCreateWithoutPatentsInput = {
    TypeID: string
    Type: $Enums.publication_type
    Status?: string | null
    Publications?: PublicationsCreateNestedManyWithoutTypeInput
    ResearchProjects?: ResearchProjectsCreateNestedManyWithoutTypeInput
  }

  export type TYPESUncheckedCreateWithoutPatentsInput = {
    TypeID: string
    Type: $Enums.publication_type
    Status?: string | null
    Publications?: PublicationsUncheckedCreateNestedManyWithoutTypeInput
    ResearchProjects?: ResearchProjectsUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TYPESCreateOrConnectWithoutPatentsInput = {
    where: TYPESWhereUniqueInput
    create: XOR<TYPESCreateWithoutPatentsInput, TYPESUncheckedCreateWithoutPatentsInput>
  }

  export type FacultyUpsertWithoutPatentsInput = {
    update: XOR<FacultyUpdateWithoutPatentsInput, FacultyUncheckedUpdateWithoutPatentsInput>
    create: XOR<FacultyCreateWithoutPatentsInput, FacultyUncheckedCreateWithoutPatentsInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutPatentsInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutPatentsInput, FacultyUncheckedUpdateWithoutPatentsInput>
  }

  export type FacultyUpdateWithoutPatentsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutPatentsInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type TYPESUpsertWithoutPatentsInput = {
    update: XOR<TYPESUpdateWithoutPatentsInput, TYPESUncheckedUpdateWithoutPatentsInput>
    create: XOR<TYPESCreateWithoutPatentsInput, TYPESUncheckedCreateWithoutPatentsInput>
    where?: TYPESWhereInput
  }

  export type TYPESUpdateToOneWithWhereWithoutPatentsInput = {
    where?: TYPESWhereInput
    data: XOR<TYPESUpdateWithoutPatentsInput, TYPESUncheckedUpdateWithoutPatentsInput>
  }

  export type TYPESUpdateWithoutPatentsInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Type?: Enumpublication_typeFieldUpdateOperationsInput | $Enums.publication_type
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Publications?: PublicationsUpdateManyWithoutTypeNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutTypeNestedInput
  }

  export type TYPESUncheckedUpdateWithoutPatentsInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Type?: Enumpublication_typeFieldUpdateOperationsInput | $Enums.publication_type
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Publications?: PublicationsUncheckedUpdateManyWithoutTypeNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type FacultyCreateWithoutResearchProjectsInput = {
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    Department: DepartmentCreateNestedOneWithoutFacultyInput
    SubjectsTaught?: SubjectTaughtCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkCreateNestedManyWithoutFacultyInput
    Patents?: PatentsCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutResearchProjectsInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
    DepartmentID: number
    SubjectsTaught?: SubjectTaughtUncheckedCreateNestedManyWithoutFacultyInput
    Qualifications?: FacultyQualificationUncheckedCreateNestedManyWithoutFacultyInput
    OutreachActivities?: OutReachActivitiesUncheckedCreateNestedManyWithoutFacultyInput
    EventsOrganised?: EventsOrganisedUncheckedCreateNestedManyWithoutFacultyInput
    Awards?: AwardsUncheckedCreateNestedManyWithoutFacultyInput
    TeachingExperiences?: TeachingExperienceUncheckedCreateNestedManyWithoutFacultyInput
    CitationMetrics?: CitationMetricsUncheckedCreateNestedManyWithoutFacultyInput
    Publications?: FacultyPublicationLinkUncheckedCreateNestedManyWithoutFacultyInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutResearchProjectsInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutResearchProjectsInput, FacultyUncheckedCreateWithoutResearchProjectsInput>
  }

  export type TYPESCreateWithoutResearchProjectsInput = {
    TypeID: string
    Type: $Enums.publication_type
    Status?: string | null
    Publications?: PublicationsCreateNestedManyWithoutTypeInput
    Patents?: PatentsCreateNestedManyWithoutTypeInput
  }

  export type TYPESUncheckedCreateWithoutResearchProjectsInput = {
    TypeID: string
    Type: $Enums.publication_type
    Status?: string | null
    Publications?: PublicationsUncheckedCreateNestedManyWithoutTypeInput
    Patents?: PatentsUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TYPESCreateOrConnectWithoutResearchProjectsInput = {
    where: TYPESWhereUniqueInput
    create: XOR<TYPESCreateWithoutResearchProjectsInput, TYPESUncheckedCreateWithoutResearchProjectsInput>
  }

  export type FacultyUpsertWithoutResearchProjectsInput = {
    update: XOR<FacultyUpdateWithoutResearchProjectsInput, FacultyUncheckedUpdateWithoutResearchProjectsInput>
    create: XOR<FacultyCreateWithoutResearchProjectsInput, FacultyUncheckedCreateWithoutResearchProjectsInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutResearchProjectsInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutResearchProjectsInput, FacultyUncheckedUpdateWithoutResearchProjectsInput>
  }

  export type FacultyUpdateWithoutResearchProjectsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentUpdateOneRequiredWithoutFacultyNestedInput
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutResearchProjectsInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    DepartmentID?: IntFieldUpdateOperationsInput | number
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type TYPESUpsertWithoutResearchProjectsInput = {
    update: XOR<TYPESUpdateWithoutResearchProjectsInput, TYPESUncheckedUpdateWithoutResearchProjectsInput>
    create: XOR<TYPESCreateWithoutResearchProjectsInput, TYPESUncheckedCreateWithoutResearchProjectsInput>
    where?: TYPESWhereInput
  }

  export type TYPESUpdateToOneWithWhereWithoutResearchProjectsInput = {
    where?: TYPESWhereInput
    data: XOR<TYPESUpdateWithoutResearchProjectsInput, TYPESUncheckedUpdateWithoutResearchProjectsInput>
  }

  export type TYPESUpdateWithoutResearchProjectsInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Type?: Enumpublication_typeFieldUpdateOperationsInput | $Enums.publication_type
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Publications?: PublicationsUpdateManyWithoutTypeNestedInput
    Patents?: PatentsUpdateManyWithoutTypeNestedInput
  }

  export type TYPESUncheckedUpdateWithoutResearchProjectsInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Type?: Enumpublication_typeFieldUpdateOperationsInput | $Enums.publication_type
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Publications?: PublicationsUncheckedUpdateManyWithoutTypeNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type FacultyCreateManyDepartmentInput = {
    FacultyID?: number
    FirstName: string
    LastName: string
    Gender: string
    DOB: Date | string
    Role: string
    Phone_no: string
    Email: string
  }

  export type FacultyUpdateWithoutDepartmentInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    SubjectsTaught?: SubjectTaughtUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutDepartmentInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    SubjectsTaught?: SubjectTaughtUncheckedUpdateManyWithoutFacultyNestedInput
    Qualifications?: FacultyQualificationUncheckedUpdateManyWithoutFacultyNestedInput
    OutreachActivities?: OutReachActivitiesUncheckedUpdateManyWithoutFacultyNestedInput
    EventsOrganised?: EventsOrganisedUncheckedUpdateManyWithoutFacultyNestedInput
    Awards?: AwardsUncheckedUpdateManyWithoutFacultyNestedInput
    TeachingExperiences?: TeachingExperienceUncheckedUpdateManyWithoutFacultyNestedInput
    CitationMetrics?: CitationMetricsUncheckedUpdateManyWithoutFacultyNestedInput
    Publications?: FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyNestedInput
    Patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput
    ResearchProjects?: ResearchProjectsUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateManyWithoutDepartmentInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    DOB?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: StringFieldUpdateOperationsInput | string
    Phone_no?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectTaughtCreateManyFacultyInput = {
    Level: string
    SubjectName: string
    CourseCode?: string | null
    ProgramName?: string | null
    Note?: string | null
  }

  export type FacultyQualificationCreateManyFacultyInput = {
    QualificationID?: number
    Degree: string
    Institution: string
    YearOfCompletion: Date | string
  }

  export type OutReachActivitiesCreateManyFacultyInput = {
    ActivityID?: number
    ActivityType: string
    ActivityTitle: string
    InstitutionName?: string | null
    ActivityDate: Date | string
    Description?: string | null
  }

  export type EventsOrganisedCreateManyFacultyInput = {
    Event_id: number
    Title: string
    Organizer?: string | null
    Location?: string | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Description?: string | null
    Role?: $Enums.role_type | null
    FundingAgency?: string | null
  }

  export type AwardsCreateManyFacultyInput = {
    AwardID?: number
    AwardName: string
    AwardingBody?: string | null
    Location?: string | null
    YearAwarded: number
  }

  export type TeachingExperienceCreateManyFacultyInput = {
    ExperienceID?: number
    OrganizationName: string
    Designation: string
    StartDate: Date | string
    EndDate?: string | null
    NatureOfWork?: string | null
  }

  export type CitationMetricsCreateManyFacultyInput = {
    MetricsID?: number
    YearRecorded: number
    Source: string
    HIndex?: number | null
    I10Index?: number | null
    TotalCitations?: number | null
    ImpactFactor?: Decimal | DecimalJsLike | number | string | null
  }

  export type FacultyPublicationLinkCreateManyFacultyInput = {
    PublicationID: number
    TypeOfIndexing?: string | null
  }

  export type PatentsCreateManyFacultyInput = {
    TypeID: string
    Title: string
    FilingDate: Date | string
    PublicationDate?: Date | string | null
    PatentNumber: string
    Authority?: string | null
    CollaborationInstitute?: string | null
  }

  export type ResearchProjectsCreateManyFacultyInput = {
    TypeID: string
    Title: string
    FundingAgency?: string | null
    StartDate: Date | string
    EndDate?: Date | string | null
    Budget?: Decimal | DecimalJsLike | number | string | null
  }

  export type SubjectTaughtUpdateWithoutFacultyInput = {
    Level?: StringFieldUpdateOperationsInput | string
    SubjectName?: StringFieldUpdateOperationsInput | string
    CourseCode?: NullableStringFieldUpdateOperationsInput | string | null
    ProgramName?: NullableStringFieldUpdateOperationsInput | string | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubjectTaughtUncheckedUpdateWithoutFacultyInput = {
    Level?: StringFieldUpdateOperationsInput | string
    SubjectName?: StringFieldUpdateOperationsInput | string
    CourseCode?: NullableStringFieldUpdateOperationsInput | string | null
    ProgramName?: NullableStringFieldUpdateOperationsInput | string | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubjectTaughtUncheckedUpdateManyWithoutFacultyInput = {
    Level?: StringFieldUpdateOperationsInput | string
    SubjectName?: StringFieldUpdateOperationsInput | string
    CourseCode?: NullableStringFieldUpdateOperationsInput | string | null
    ProgramName?: NullableStringFieldUpdateOperationsInput | string | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyQualificationUpdateWithoutFacultyInput = {
    Degree?: StringFieldUpdateOperationsInput | string
    Institution?: StringFieldUpdateOperationsInput | string
    YearOfCompletion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyQualificationUncheckedUpdateWithoutFacultyInput = {
    QualificationID?: IntFieldUpdateOperationsInput | number
    Degree?: StringFieldUpdateOperationsInput | string
    Institution?: StringFieldUpdateOperationsInput | string
    YearOfCompletion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyQualificationUncheckedUpdateManyWithoutFacultyInput = {
    QualificationID?: IntFieldUpdateOperationsInput | number
    Degree?: StringFieldUpdateOperationsInput | string
    Institution?: StringFieldUpdateOperationsInput | string
    YearOfCompletion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutReachActivitiesUpdateWithoutFacultyInput = {
    ActivityType?: StringFieldUpdateOperationsInput | string
    ActivityTitle?: StringFieldUpdateOperationsInput | string
    InstitutionName?: NullableStringFieldUpdateOperationsInput | string | null
    ActivityDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OutReachActivitiesUncheckedUpdateWithoutFacultyInput = {
    ActivityID?: IntFieldUpdateOperationsInput | number
    ActivityType?: StringFieldUpdateOperationsInput | string
    ActivityTitle?: StringFieldUpdateOperationsInput | string
    InstitutionName?: NullableStringFieldUpdateOperationsInput | string | null
    ActivityDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OutReachActivitiesUncheckedUpdateManyWithoutFacultyInput = {
    ActivityID?: IntFieldUpdateOperationsInput | number
    ActivityType?: StringFieldUpdateOperationsInput | string
    ActivityTitle?: StringFieldUpdateOperationsInput | string
    InstitutionName?: NullableStringFieldUpdateOperationsInput | string | null
    ActivityDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventsOrganisedUpdateWithoutFacultyInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Organizer?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableEnumrole_typeFieldUpdateOperationsInput | $Enums.role_type | null
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    Event?: EventTypeUpdateOneRequiredWithoutEventsOrganisedNestedInput
  }

  export type EventsOrganisedUncheckedUpdateWithoutFacultyInput = {
    Event_id?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    Organizer?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableEnumrole_typeFieldUpdateOperationsInput | $Enums.role_type | null
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventsOrganisedUncheckedUpdateManyWithoutFacultyInput = {
    Event_id?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    Organizer?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableEnumrole_typeFieldUpdateOperationsInput | $Enums.role_type | null
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AwardsUpdateWithoutFacultyInput = {
    AwardName?: StringFieldUpdateOperationsInput | string
    AwardingBody?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    YearAwarded?: IntFieldUpdateOperationsInput | number
  }

  export type AwardsUncheckedUpdateWithoutFacultyInput = {
    AwardID?: IntFieldUpdateOperationsInput | number
    AwardName?: StringFieldUpdateOperationsInput | string
    AwardingBody?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    YearAwarded?: IntFieldUpdateOperationsInput | number
  }

  export type AwardsUncheckedUpdateManyWithoutFacultyInput = {
    AwardID?: IntFieldUpdateOperationsInput | number
    AwardName?: StringFieldUpdateOperationsInput | string
    AwardingBody?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    YearAwarded?: IntFieldUpdateOperationsInput | number
  }

  export type TeachingExperienceUpdateWithoutFacultyInput = {
    OrganizationName?: StringFieldUpdateOperationsInput | string
    Designation?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableStringFieldUpdateOperationsInput | string | null
    NatureOfWork?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingExperienceUncheckedUpdateWithoutFacultyInput = {
    ExperienceID?: IntFieldUpdateOperationsInput | number
    OrganizationName?: StringFieldUpdateOperationsInput | string
    Designation?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableStringFieldUpdateOperationsInput | string | null
    NatureOfWork?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingExperienceUncheckedUpdateManyWithoutFacultyInput = {
    ExperienceID?: IntFieldUpdateOperationsInput | number
    OrganizationName?: StringFieldUpdateOperationsInput | string
    Designation?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableStringFieldUpdateOperationsInput | string | null
    NatureOfWork?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CitationMetricsUpdateWithoutFacultyInput = {
    YearRecorded?: IntFieldUpdateOperationsInput | number
    Source?: StringFieldUpdateOperationsInput | string
    HIndex?: NullableIntFieldUpdateOperationsInput | number | null
    I10Index?: NullableIntFieldUpdateOperationsInput | number | null
    TotalCitations?: NullableIntFieldUpdateOperationsInput | number | null
    ImpactFactor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CitationMetricsUncheckedUpdateWithoutFacultyInput = {
    MetricsID?: IntFieldUpdateOperationsInput | number
    YearRecorded?: IntFieldUpdateOperationsInput | number
    Source?: StringFieldUpdateOperationsInput | string
    HIndex?: NullableIntFieldUpdateOperationsInput | number | null
    I10Index?: NullableIntFieldUpdateOperationsInput | number | null
    TotalCitations?: NullableIntFieldUpdateOperationsInput | number | null
    ImpactFactor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CitationMetricsUncheckedUpdateManyWithoutFacultyInput = {
    MetricsID?: IntFieldUpdateOperationsInput | number
    YearRecorded?: IntFieldUpdateOperationsInput | number
    Source?: StringFieldUpdateOperationsInput | string
    HIndex?: NullableIntFieldUpdateOperationsInput | number | null
    I10Index?: NullableIntFieldUpdateOperationsInput | number | null
    TotalCitations?: NullableIntFieldUpdateOperationsInput | number | null
    ImpactFactor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type FacultyPublicationLinkUpdateWithoutFacultyInput = {
    TypeOfIndexing?: NullableStringFieldUpdateOperationsInput | string | null
    Publication?: PublicationsUpdateOneRequiredWithoutFacultyPublicationLinkNestedInput
  }

  export type FacultyPublicationLinkUncheckedUpdateWithoutFacultyInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    TypeOfIndexing?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyPublicationLinkUncheckedUpdateManyWithoutFacultyInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    TypeOfIndexing?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentsUpdateWithoutFacultyInput = {
    Title?: StringFieldUpdateOperationsInput | string
    FilingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PatentNumber?: StringFieldUpdateOperationsInput | string
    Authority?: NullableStringFieldUpdateOperationsInput | string | null
    CollaborationInstitute?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: TYPESUpdateOneRequiredWithoutPatentsNestedInput
  }

  export type PatentsUncheckedUpdateWithoutFacultyInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    FilingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PatentNumber?: StringFieldUpdateOperationsInput | string
    Authority?: NullableStringFieldUpdateOperationsInput | string | null
    CollaborationInstitute?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentsUncheckedUpdateManyWithoutFacultyInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    FilingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PatentNumber?: StringFieldUpdateOperationsInput | string
    Authority?: NullableStringFieldUpdateOperationsInput | string | null
    CollaborationInstitute?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResearchProjectsUpdateWithoutFacultyInput = {
    Title?: StringFieldUpdateOperationsInput | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Type?: TYPESUpdateOneRequiredWithoutResearchProjectsNestedInput
  }

  export type ResearchProjectsUncheckedUpdateWithoutFacultyInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ResearchProjectsUncheckedUpdateManyWithoutFacultyInput = {
    TypeID?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EventsOrganisedCreateManyEventInput = {
    FacultyID: number
    Title: string
    Organizer?: string | null
    Location?: string | null
    StartDate?: Date | string | null
    EndDate?: Date | string | null
    Description?: string | null
    Role?: $Enums.role_type | null
    FundingAgency?: string | null
  }

  export type EventsOrganisedUpdateWithoutEventInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Organizer?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableEnumrole_typeFieldUpdateOperationsInput | $Enums.role_type | null
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutEventsOrganisedNestedInput
  }

  export type EventsOrganisedUncheckedUpdateWithoutEventInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    Organizer?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableEnumrole_typeFieldUpdateOperationsInput | $Enums.role_type | null
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventsOrganisedUncheckedUpdateManyWithoutEventInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    Organizer?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableEnumrole_typeFieldUpdateOperationsInput | $Enums.role_type | null
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublicationsCreateManyTypeInput = {
    PublicationID?: number
    Authors: string
    Title: string
    PublicationYear: Date | string
    FundingAgency?: string | null
  }

  export type PatentsCreateManyTypeInput = {
    FacultyID: number
    Title: string
    FilingDate: Date | string
    PublicationDate?: Date | string | null
    PatentNumber: string
    Authority?: string | null
    CollaborationInstitute?: string | null
  }

  export type ResearchProjectsCreateManyTypeInput = {
    FacultyID: number
    Title: string
    FundingAgency?: string | null
    StartDate: Date | string
    EndDate?: Date | string | null
    Budget?: Decimal | DecimalJsLike | number | string | null
  }

  export type PublicationsUpdateWithoutTypeInput = {
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    JournalPublicationDetails?: JournalPublicationDetailsUpdateOneWithoutPublicationNestedInput
    BookPublicationDetails?: BookPublicationDetailsUpdateOneWithoutPublicationNestedInput
    ConferencePaperDetails?: ConferencePaperDetailsUpdateOneWithoutPublicationNestedInput
    FacultyPublicationLink?: FacultyPublicationLinkUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationsUncheckedUpdateWithoutTypeInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    JournalPublicationDetails?: JournalPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    BookPublicationDetails?: BookPublicationDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    ConferencePaperDetails?: ConferencePaperDetailsUncheckedUpdateOneWithoutPublicationNestedInput
    FacultyPublicationLink?: FacultyPublicationLinkUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationsUncheckedUpdateManyWithoutTypeInput = {
    PublicationID?: IntFieldUpdateOperationsInput | number
    Authors?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    PublicationYear?: DateTimeFieldUpdateOperationsInput | Date | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentsUpdateWithoutTypeInput = {
    Title?: StringFieldUpdateOperationsInput | string
    FilingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PatentNumber?: StringFieldUpdateOperationsInput | string
    Authority?: NullableStringFieldUpdateOperationsInput | string | null
    CollaborationInstitute?: NullableStringFieldUpdateOperationsInput | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutPatentsNestedInput
  }

  export type PatentsUncheckedUpdateWithoutTypeInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    FilingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PatentNumber?: StringFieldUpdateOperationsInput | string
    Authority?: NullableStringFieldUpdateOperationsInput | string | null
    CollaborationInstitute?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentsUncheckedUpdateManyWithoutTypeInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    FilingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PatentNumber?: StringFieldUpdateOperationsInput | string
    Authority?: NullableStringFieldUpdateOperationsInput | string | null
    CollaborationInstitute?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResearchProjectsUpdateWithoutTypeInput = {
    Title?: StringFieldUpdateOperationsInput | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutResearchProjectsNestedInput
  }

  export type ResearchProjectsUncheckedUpdateWithoutTypeInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ResearchProjectsUncheckedUpdateManyWithoutTypeInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    Title?: StringFieldUpdateOperationsInput | string
    FundingAgency?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type FacultyPublicationLinkCreateManyPublicationInput = {
    FacultyID: number
    TypeOfIndexing?: string | null
  }

  export type FacultyPublicationLinkUpdateWithoutPublicationInput = {
    TypeOfIndexing?: NullableStringFieldUpdateOperationsInput | string | null
    Faculty?: FacultyUpdateOneRequiredWithoutPublicationsNestedInput
  }

  export type FacultyPublicationLinkUncheckedUpdateWithoutPublicationInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    TypeOfIndexing?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyPublicationLinkUncheckedUpdateManyWithoutPublicationInput = {
    FacultyID?: IntFieldUpdateOperationsInput | number
    TypeOfIndexing?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}